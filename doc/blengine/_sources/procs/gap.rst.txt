
.. this file is auto generated by BLEngine/docs/procedures.py

=============================
gap Procedures
=============================

.. raw:: html
    
    
    <input class="search input" type="text" placeholder="Live Search" style="width: 100%; padding: 10px;">
    <div>&nbsp</div>
    <div id="search-loader" style="display:none;">please wait...</div>
    
.. _proc-gap.get_bd_addr:

gap.get_bd_addr_
****************


    return the MAC Address
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gap import get_bd_addr

    get_bd_addr(engine, conn_handle=0)


**CLI usage**

.. code-block:: bash

    blengine run GAP.get_bd_addr [-h] conn_handle

*Positional arguments:*

:conn_handle:

    Connection Handle


options:
  -h, --help   show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GAP.", parser=get_bd_addr_parser)
    def get_bd_addr(engine, conn_handle=0):
        '''
        return the MAC Address
        '''
        if engine.bluetooth_host_stack == "EMB":
            if conn_handle > 0:
                raise NotImplementedError(f"Getting remote BD_ADDR not implemented for EMSHI {engine.bluetooth_host_stack}")
    
            # This command is implemented in EMB emshi to only get the bd addr from
            # NVM Info. Therefore, it will always be the public address.
            pkt = engine.send("EMSHI_DM_GetBdAddr")
            return pkt.response.get("status") == 0, pkt.response.get("LocalAddress"), MACAddressType.PUBLIC
    
        else:
            if conn_handle > 0:
                pkt = engine.send("EMSHI_GAP_GetBdAddr", Conn_Handle=conn_handle)
            else:
                pkt = engine.send("EMSHI_GAP_GetLocalBdAddr")
            return pkt.response.get("status") == 0, pkt.response.get("LocalAddress"), pkt.response.get("LocalAddressType")
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gap.set_name:

gap.set_name_
*************

 
    Set Bluetooth Device Name.
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gap import set_name

    set_name(engine, name, IsWritable=False)


**CLI usage**

.. code-block:: bash

    blengine run GAP.set_name [-h] [--IsWritable ISWRITABLE] name

*Positional arguments:*

:name:

    Device Name


options:
  -h, --help            show this help message and exit
  --IsWritable ISWRITABLE
                        Indicate if the device name is writable (True) or not
                        (False)


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GAP.", parser=set_name_parser)
    def set_name(engine, name, IsWritable=False):
        ''' 
        Set Bluetooth Device Name.
        '''
        if engine.bluetooth_host_stack == "EMB":
            name_bytes = name.encode()
            advdata_name = bytearray([len(name_bytes)+1, GAP_AD_TYPES["GAP_ADV_TYPE_SHORT_NAME"]]) + name_bytes # [Length, DM_ADV_TYPE_SHORT_NAME, name]
            rsp = engine.send("EMSHI_DM_AdvSetData", advHandle=0, op=3, location=DM_DATA_LOC_ADV, len=len(advdata_name), Data=advdata_name)
            if rsp.response.get("status") != 0:
                return False, "name not set, error: %s" % rsp.status_text
            return rsp.response.get("status") == 0, "name set to %s" % name
        else:
            if IsWritable:
                rsp = engine.send("EMSHI_GAP_SetLocalBluetoothDeviceNameEx", 
                                  NameLen=len(name.encode('utf-8')), 
                                  Name=name.encode('utf-8'), 
                                  IsWritable=1,
                                  MaximumWritableLen=32)
            else:
                rsp = engine.send("EMSHI_GAP_SetLocalBluetoothDeviceName", NameLen=len(name.encode('utf-8')), Name=name.encode('utf-8'), retry=1)
    
            if rsp.response.get("status") != 0:
                return False, "name not set, error: %s" % rsp.status_text
            return rsp.response.get("status") == 0, "name set to %s" % name
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gap.set_appearance:

gap.set_appearance_
*******************

 
    Set Appearance data type
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gap import set_appearance

    set_appearance(engine, appearance=1, IsWritable=False)


**CLI usage**

.. code-block:: bash

    blengine run GAP.set_appearance [-h] [--name NAME] [--IsWritable ISWRITABLE]


options:
  -h, --help            show this help message and exit
  --name NAME           Appearance value (from Assigned Numbers). Default:
                        0x0001 (Appearance Unknown)
  --IsWritable ISWRITABLE
                        Indicate if the appearance is writable (True) or not
                        (False)


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GAP.", parser=set_appearance_parser)
    def set_appearance(engine, appearance=0x0001, IsWritable=False):
        ''' 
        Set Appearance data type
        '''
        if engine.bluetooth_host_stack == "EMB":
            #### TO DO: Packetcraft steps ####
            pass
        else:
            if IsWritable:
                rsp = engine.send("EMSHI_GAP_SetLocalAppearanceEx", 
                                  Appearance=appearance, 
                                  IsWritable=1)
            else:
                rsp = engine.send("EMSHI_GAP_SetLocalAppearance", Appearance=appearance, retry=1)
    
            if rsp.response.get("status") != 0:
                return False, "Appearance not set, error: %s" % rsp.status_text
            return rsp.response.get("status") == 0, "Appearance set to %s" % appearance
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gap.set_role:

gap.set_role_
*************

 
    Set Bluetooth Device Role.
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gap import set_role

    set_role(engine, roles)


**CLI usage**

.. code-block:: bash

    blengine run GAP.set_role [-h] roles

*Positional arguments:*

:roles:

    Can be any combination, separated by commas, of the following
              values: BROADCASTER,OBSERVER,PERIPHERAL,CENTRAL


options:
  -h, --help  show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GAP.", parser=set_role_parser)
    def set_role(engine, roles):
        ''' 
        Set Bluetooth Device Role.
        '''
        role = 0
        if isinstance(roles, str):
            roles = roles.split(',')
    
        if isinstance(roles, list):
            for r in roles:
                role += GAP_ROLES[r.strip().upper()]
        else:
            role = roles
        
        def general_init():
            engine.send("EMSHI_DM_Register")
            engine.send("EMSHI_DM_ConnRegister", clientId=3)
            pkt = engine.send("EMSHI_DM_DevReset")
            return pkt
    
        if engine.bluetooth_host_stack == "EMB":
            
            pkt=general_init()
            
            if role=="CENTRAL" or role==0x08:
                ###Central Initialisations            
                engine.send("EMSHI_DM_ScanInit")
                engine.send("EMSHI_DM_ConnMasterInit")
                engine.send("EMSHI_L2CAP_emb_MasterInit")
                engine.send("EMSHI_SMPI_Init")
                engine.send("EMSHI_SMPI_SCInit")
                engine.send("EMSHI_HCI_MaxRxAclen")
                ###Central Initialisations
                
                pkt = engine.send("EMSHI_DM_ConnSetConnSpec", 
                                  connIntervalMin=40,
                                  connIntervalMax=40, 
                                  connLatency=0, 
                                  supTimeout=600, 
                                  minCeLen=0, 
                                  maxCeLen=0)
                
            if role=="PERIPHERAL" or role==0x04:
                ###Peripheral Initialisations
                engine.send("EMSHI_DM_AdvInit")
                engine.send("EMSHI_DM_ConnSlaveInit")
                engine.send("EMSHI_L2CAP_emb_SlaveHandlerInit")
                engine.send("EMSHI_L2CAP_emb_SlaveInit")
                engine.send("EMSHI_SMPR_Init")
                engine.send("EMSHI_SMPR_SCInit")
                engine.send("EMSHI_HCI_MaxRxAclen")
                ###Peripheral Initialisations
    
    
            if role=="OBSERVER" or role==0x02:
                ###Observer Initialisations
                engine.send("EMSHI_DM_ScanInit")
                engine.send("EMSHI_L2CAP_emb_MasterInit")
                
                engine.send("EMSHI_L2CAP_emb_SlaveHandlerInit")
                engine.send("EMSHI_L2CAP_emb_SlaveInit")
                engine.send("EMSHI_SMPI_Init")
                engine.send("EMSHI_SMPI_SCInit")
                engine.send("EMSHI_HCI_MaxRxAclen")
                ###Observer Initialisations
                
            if role=="BROADCASTER" or role==0x01:
                ###Broadcaster Initialisations
                engine.send("EMSHI_DM_AdvInit")
                engine.send("EMSHI_L2CAP_emb_SlaveHandlerInit")
                engine.send("EMSHI_L2CAP_emb_SlaveInit")
                engine.send("EMSHI_SMPR_Init")
                engine.send("EMSHI_SMPR_SCInit")
                engine.send("EMSHI_HCI_MaxRxAclen")
                ###Broadcaster Initialisations
                
                
                
            if pkt.response.get("status") == 0:
                return True, "Role set to 0x%x" % role
            else:
                return False, "Cannot set role"
        else:
            pkt = engine.send("EMSHI_GAP_RegisterDevice", Role=role, retry=2)
            if pkt.response.get("status") == 0:
                return True, "Role set to 0x%x" % role
            else:
                return False, "Cannot set role, error: %s" % pkt.status_text
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gap.set_mode:

gap.set_mode_
*************

 
    Set Bluetooth Device Mode. (EMSHI only)
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gap import set_mode

    set_mode(engine, modes, adv_data_param=None, interval=None, address=None, addrtype=0)


**CLI usage**

.. code-block:: bash

    blengine run GAP.set_manufacturer_data [-h] [--addrtype ADDRTYPE]
                                      [--adv_data_param ADV_DATA_PARAM]
                                      modes interval address

*Positional arguments:*

:modes:

    can be any combination, separated by commas, of the
                        following values: CONNECTABLE_DISCOVERABLE,NOT_CONNECT
                        ABLE,CONNECTABLE,DIRECT_CONNECTABLE,NOT_DISCOVERABLE,D
                        ISCOVERABLE,LIMITED_DISCOVERABLE,EXTENDED_ADVERTISING,
                        PERIODIC_ADVERTISING

:interval:

    The discoverable/connectable interval

:address:

    Address of the remote device (for directed mode)


options:
  -h, --help            show this help message and exit
  --addrtype ADDRTYPE   Address Type of the remote device (for directed mode)
  --adv_data_param ADV_DATA_PARAM
                        Advertisement data


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GAP.", parser=set_mode_parser)
    def set_mode(engine,
                 modes,
                 adv_data_param=None,
                 interval=None,
                 address=None,
                 addrtype=0x00):
        ''' 
        Set Bluetooth Device Mode. (EMSHI only)
        '''
        mode = 0x00
        if isinstance(modes, str):
            modes = modes.split(',')
    
        if isinstance(modes, list):
            for m in modes:
                mode += GAP_MODES[m.strip().upper()]
        else:
            mode = modes
    
        if engine.bluetooth_host_stack == "EMB":
            
            global ADVERTISEMENT_DATA_LENGTH
            global ADVERTISEMENT_DATA
            
            global SCAN_DATA_LENGTH
            global SCAN_DATA
            
            # Set the ADV Data Flags
            adv_flags = DM_FLAG_LE_BREDR_NOT_SUP 
            if mode == 0x10 or mode == 0x11: # DISCOVERABLE
                adv_flags = DM_FLAG_LE_GENERAL_DISC | DM_FLAG_LE_BREDR_NOT_SUP
            elif mode == 0x20 or mode == 0x21: # LIMITED DISCOVERABLE
                adv_flags = DM_FLAG_LE_LIMITED_DISC | DM_FLAG_LE_BREDR_NOT_SUP
    
            # Set the ADV event type
            if mode == 0x00 or mode == 0x10 or mode == 0x20:
                adv_type = DM_ADV_NONCONN_UNDIRECT
            elif mode == 0x02:
                adv_type = DM_ADV_CONN_DIRECT
            else:
                adv_type = DM_ADV_CONN_UNDIRECT
            if ADVERTISEMENT_DATA == 0 or adv_data_param is not None: # Not AD type has been set with set_ad_type procedure
                # Set advertising data
                ADVERTISEMENT_DATA = bytearray([0x02, GAP_AD_TYPES["GAP_ADV_TYPE_FLAGS"], adv_flags, 0x02, GAP_AD_TYPES["GAP_ADV_TYPE_TX_POWER"], 0x00])
                ADVERTISEMENT_DATA_LENGTH = len(ADVERTISEMENT_DATA)
                engine.send("EMSHI_DM_Advdatacb", dataType=1, dataLen=ADVERTISEMENT_DATA_LENGTH, pData=ADVERTISEMENT_DATA)
    
            # Set scan data
            SCAN_DATA = bytearray([0x03, GAP_AD_TYPES["GAP_ADV_TYPE_LOCAL_NAME"], 0x45, 0x4D])
            SCAN_DATA_LENGTH = len(SCAN_DATA)
            engine.send("EMSHI_DM_Advdatacb", dataType=0, dataLen=SCAN_DATA_LENGTH, pData=SCAN_DATA)
    
            engine.send("EMSHI_DM_AdvSetData", advHandle=0, op=3, location=DM_DATA_LOC_ADV, len=ADVERTISEMENT_DATA_LENGTH)
            engine.send("EMSHI_DM_AdvSetData", advHandle=0, op=3, location=DM_DATA_LOC_SCAN, len=SCAN_DATA_LENGTH)
    
            if interval is not None:
                engine.send("EMSHI_DM_AdvSetInterval", advHandle=0, intervalMin=interval, intervalMax=interval)
    
            peerAddress = address if address is not None else 0
            
            engine.send("EMSHI_DM_AdvConfig", advHandle=0, adtype=adv_type, peerAddrType=addrtype, PeerAddr=peerAddress)
            rsp = engine.send("EMSHI_DM_AdvStart", numSets=1, AdvHandles=0, Duration=0, MaxEaEvents=0)
            
            msg =  "Mode set to 0x%x" % mode
    
        else:
            if interval is not None:
                rsp = engine.send("EMSHI_GAP_SetModeWithIntervalsEx", Mode=mode, AdvertisementInterval=interval, Addr=address, AddrType=addrtype)
            rsp = engine.send("EMSHI_GAP_SetMode", Mode=mode, retry=2)
            msg =  "Mode set to 0x%x" % mode
    
        if rsp.response.get("status") != 0:
            msg = "Cannot set mode to {} , Error: {}".format(mode, rsp.response.get("status"))
    
        return rsp.response.get("status") == 0, msg
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gap.set_manufacturer_data:

gap.set_manufacturer_data_
**************************


    Set manufacturer specific data
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gap import set_manufacturer_data

    set_manufacturer_data(engine, data)


**CLI usage**

.. code-block:: bash

    blengine run GAP.set_manufacturer_data [-h] [--addrtype ADDRTYPE]
                                      [--adv_data_param ADV_DATA_PARAM]
                                      modes interval address

*Positional arguments:*

:modes:

    can be any combination, separated by commas, of the
                        following values: CONNECTABLE_DISCOVERABLE,NOT_CONNECT
                        ABLE,CONNECTABLE,DIRECT_CONNECTABLE,NOT_DISCOVERABLE,D
                        ISCOVERABLE,LIMITED_DISCOVERABLE,EXTENDED_ADVERTISING,
                        PERIODIC_ADVERTISING

:interval:

    The discoverable/connectable interval

:address:

    Address of the remote device (for directed mode)


options:
  -h, --help            show this help message and exit
  --addrtype ADDRTYPE   Address Type of the remote device (for directed mode)
  --adv_data_param ADV_DATA_PARAM
                        Advertisement data


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GAP.", parser=set_mode_parser)
    def set_manufacturer_data(engine, data):
        """
        Set manufacturer specific data
        """
        if engine.bluetooth_host_stack == "EMB":
            #### TO DO: Packetcraft steps ####
            pass
        else:
            pkt = engine.send("EMSHI_GAP_SetManufacturerSpecificData", Len=len(data), Value=data)
        #assert pkt.response.get("status") == 0, "Cannot set manufacturer specific data, error: %s" % pkt.status_text
        return pkt.response.get("status") == 0
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gap.set_ad_type:

gap.set_ad_type_
****************


    Set GAP AD Types for advertising
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gap import set_ad_type

    set_ad_type(engine, ad_types, ad_value=None)


**CLI usage**

.. code-block:: bash

    blengine run GAP.set_ad_type [-h] ad_types ad_value

*Positional arguments:*

:ad_types:

    AD Type to be set for advertising. Can be any of the following
              values: GAP_ADV_TYPE_FLAGS,GAP_ADV_TYPE_16_UUID_PART,GAP_ADV_TYP
              E_16_UUID,GAP_ADV_TYPE_32_UUID_PART,GAP_ADV_TYPE_32_UUID,GAP_ADV
              _TYPE_128_UUID_PART,GAP_ADV_TYPE_128_UUID,GAP_ADV_TYPE_SHORT_NAM
              E,GAP_ADV_TYPE_LOCAL_NAME,GAP_ADV_TYPE_TX_POWER,GAP_ADV_TYPE_SM_
              TK_VALUE,GAP_ADV_TYPE_SM_OOB_FLAGS,GAP_ADV_TYPE_CONN_INTERVAL,GA
              P_ADV_TYPE_SIGNED_DATA,GAP_ADV_TYPE_16_SOLICIT,GAP_ADV_TYPE_128_
              SOLICIT,GAP_ADV_TYPE_SERVICE_DATA,GAP_ADV_TYPE_PUBLIC_TARGET,GAP
              _ADV_TYPE_RANDOM_TARGET,GAP_ADV_TYPE_ADV_INTERVAL,GAP_ADV_TYPE_A
              PPEARANCE,GAP_ADV_TYPE_BD_ADDR,GAP_ADV_TYPE_ROLE,GAP_ADV_TYPE_32
              _SOLICIT,GAP_ADV_TYPE_SVC_DATA_32,GAP_ADV_TYPE_SVC_DATA_128,GAP_
              ADV_TYPE_LESC_CONFIRM,GAP_ADV_TYPE_LESC_RANDOM,GAP_ADV_TYPE_URI,
              GAP_ADV_TYPE_INDOOR_POS,GAP_ADV_TYPE_TRANS_DISC,GAP_ADV_TYPE_LE_
              SUP_FEAT,GAP_ADV_TYPE_CH_MAP_UPD_IND,GAP_ADV_TYPE_PB_ADV,GAP_ADV
              _TYPE_MESH_MSG,GAP_ADV_TYPE_MESH_BEACON,GAP_ADV_TYPE_BIG_INFO,GA
              P_ADV_TYPE_BCAST_CODE,GAP_ADV_TYPE_PRSI,GAP_ADV_TYPE_ADV_INTERVA
              L_LG,GAP_ADV_TYPE_BCASTER_NAME,GAP_ADV_TYPE_ENC_ADV_DATA,GAP_ADV
              _TYPE_3D_INFO_DATA,GAP_ADV_TYPE_MANUFACTURER

:ad_value:

    Service UUID for ServiceUUID AD type


options:
  -h, --help  show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GAP.", parser=set_ad_type_parser)
    def set_ad_type(engine, 
                    ad_types,
                    ad_value=None):
        """
        Set GAP AD Types for advertising
        """
        if isinstance(ad_types, str):
            ad_types = ad_types.split(',')
    
        if ad_value is None:
            return False, "Error: Value to set in AD type not specified in parameters"
    
        if engine.bluetooth_host_stack == "EMB":
            global ADVERTISEMENT_DATA_LENGTH
            global ADVERTISEMENT_DATA
            
            global SCAN_DATA_LENGTH
            global SCAN_DATA
    
            if ADVERTISEMENT_DATA == 0:
                adv_flags = 0x06
                adv_data = bytearray([0x02, GAP_AD_TYPES["GAP_ADV_TYPE_FLAGS"], adv_flags])
                scan_data = bytearray([0x0B, GAP_AD_TYPES["GAP_ADV_TYPE_LOCAL_NAME"],69,77,57,51,48,53,95,72,82,83])
            
                ADVERTISEMENT_DATA = adv_data
                ADVERTISEMENT_DATA_LENGTH = len(adv_data)
    
                SCAN_DATA = scan_data
                SCAN_DATA_LENGTH = len(scan_data)
                # Set default data
                engine.send("EMSHI_DM_Advdatacb", dataType=1, pAdvData=ADVERTISEMENT_DATA, advDataLen=ADVERTISEMENT_DATA_LENGTH)
                engine.send("EMSHI_DM_Advdatacb", dataType=0, pAdvData=SCAN_DATA, advDataLen=SCAN_DATA_LENGTH)
    
            for ad_type in ad_types:
                ad_type_int = GAP_AD_TYPES[ad_type]
                # Set specified adType
                pkt = engine.send("EMSHI_DM_AdvSetAdValue",
                            adType=ad_type_int,
                            len=len(ad_value),
                            advDataBufLen=20,
                            Value=ad_value)
                
                # Updating length value
                ADVERTISEMENT_DATA_LENGTH = ADVERTISEMENT_DATA_LENGTH+len(ad_value)+2
    
            return pkt.response.get("status")
    
        else:
            rsp = 1
            if "GAP_ADV_TYPE_16_UUID" in ad_types:
                pkt = engine.send("EMSHI_GAP_Add16BitsServiceUUID", UUID=ad_value)
                rsp = pkt.response.get("status")
            elif "GAP_ADV_TYPE_LOCAL_NAME" in ad_types:
                rsp = set_name(engine, name=ad_value, IsWritable=False)
            elif "GAP_ADV_TYPE_FLAGS" in ad_types:
                pass # In AW Stack, flags are set by default
            elif "GAP_ADV_TYPE_MANUFACTURER" in ad_types:
                rsp = set_manufacturer_data(engine, data=ad_value)
            elif "GAP_ADV_TYPE_TX_POWER" in ad_types:
                pkt = engine.send("EMSHI_GAP_SetTXPowerLevelADData", txPowerLevelValue=ad_value)
                rsp = pkt.response.get("status")
            elif "GAP_ADV_TYPE_16_UUID" in ad_types:
                ServiceDataValue=bytearray(b'SetServiceDataValue') 
                pkt = engine.send("EMSHI_GAP_SetServiceDataValue", UUID=ad_value, Len=len(ServiceDataValue), Value=ServiceDataValue)
                rsp = pkt.response.get("status")
            elif "GAP_ADV_TYPE_APPEARANCE" in ad_types:
                rsp = set_appearance(engine, appearance=ad_value, IsWritable=True)
            
            if isinstance(rsp, list):
                if False in rsp:
                    return False
            elif rsp != 0:
                return False
            
            return True
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gap.start_broadcast:

gap.start_broadcast_
********************


    Start broadcasting from a GAP Broadcaster
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gap import start_broadcast

    start_broadcast(engine, broadcast_interval, broadcast_data=None)


**CLI usage**

.. code-block:: bash

    blengine run GAP.start_broadcast [-h] broadcast_interval broadcast_data

*Positional arguments:*

:broadcast_interval:

    Broadcast Interval

:broadcast_data:

    Broadcast Data


options:
  -h, --help          show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GAP.", parser=start_broadcast_parser)
    def start_broadcast(engine, broadcast_interval, broadcast_data=None):
        """
        Start broadcasting from a GAP Broadcaster
        """
        if engine.bluetooth_host_stack == "EMB":
    
            adv_data = bytearray([0x02, GAP_AD_TYPES["GAP_ADV_TYPE_FLAGS"],DM_NO_FLAG, len(broadcast_data)+1, GAP_AD_TYPES["GAP_ADV_TYPE_SERVICE_DATA"]]) + broadcast_data
                
            status = set_mode(engine, modes="NOT_CONNECTABLE", adv_data_param = adv_data)
            return status
        else:
            engine.send("EMSHI_GAP_StartBroadcastProcedure", broadcastInterval=broadcast_interval)
            if broadcast_data is not None:
                engine.send("EMSHI_GAP_SetServiceDataValue", UUID=0x0001, Len=len(broadcast_data), Value=broadcast_data)
            engine.send("EMSHI_GAP_ApplyBroadcastValue")
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gap.stop_broadcast:

gap.stop_broadcast_
*******************


    Stop broadcasting from a GAP Broadcaster
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gap import stop_broadcast

    stop_broadcast(engine)


**CLI usage**

.. code-block:: bash

    blengine run GAP.stop_broadcast [-h]


options:
  -h, --help  show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GAP.", parser=stop_broadcast_parser)
    def stop_broadcast(engine):
        """
        Stop broadcasting from a GAP Broadcaster
        """
        if engine.bluetooth_host_stack == "EMB":
            engine.send("EMSHI_DM_AdvStop",
                        numSets=1,
                        AdvHandles=0)
        else:
            engine.send("EMSHI_GAP_StopBroadcastProcedure")
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gap.set_random_address:

gap.set_random_address_
***********************


    Set a random address for GAP advertising
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gap import set_random_address

    set_random_address(engine, addr_type=3, adv_handle=1, address='44:11:22:33:44:55')


**CLI usage**

.. code-block:: bash

    blengine run GAP.set_random_address [-h] [--adv_handle ADV_HANDLE]
                                   [--address ADDRESS]
                                   addr_type

*Positional arguments:*

:addr_type:

    The type of PRIVATE Address that the application wants
                        to generate and set (1 is Random Static, 2 is Random
                        Non Resolvable and 3 is Random Resolvable). Not
                        required for EMB.


options:
  -h, --help            show this help message and exit
  --adv_handle ADV_HANDLE
                        Advertising handle. Not required for AW stack
  --address ADDRESS     Random device address to be set. Not required for AW
                        stack


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GAP.", parser=set_random_address_parser)
    def set_random_address(engine, addr_type=0x03, adv_handle=1, address="44:11:22:33:44:55"):
        """
        Set a random address for GAP advertising
        """
        if engine.bluetooth_host_stack == "EMB":
            
            if(addr_type==RESOLV_PRIV_ADDR):
                # Resolvable Private address
                AddrResEnable=True
            elif(addr_type==NON_RESOLV_PRIV_ADDR):
                # Non Resolvable Private address
                AddrResEnable=False
    
            engine.send("EMSHI_DM_PrivSetAddrResEnable",enable = AddrResEnable)
            pkt=engine.send("EMSHI_DM_DevPrivStart",changeInterval=60) 
            
            return pkt.response.get("status") == 0
        else:
            pkt = engine.send("EMSHI_SM_GenerateAndSetRandomAddress", Type=addr_type)
            return pkt.response.get("status") == 0
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gap.enable_address_resolution:

gap.enable_address_resolution_
******************************


    Enable or disable Address Resolution
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gap import enable_address_resolution

    enable_address_resolution(engine, enable)


**CLI usage**

.. code-block:: bash

    blengine run GAP.enable_address_resolution [-h] enable

*Positional arguments:*

:enable:

    Enable (1) or disable (0) address resolution in the controller


options:
  -h, --help  show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GAP.", parser=enable_address_resolution_parser)
    def enable_address_resolution(engine, enable):
        """
        Enable or disable Address Resolution
        """
        if engine.bluetooth_host_stack == "EMB":
            pkt = engine.send("EMSHI_DM_PrivSetAddrResEnable", enable=enable)
            return pkt.response.get("status") == 0
        else:
            pkt = engine.send("EMSHI_SM_PrivacyConfigureAddressResolution", enableAddressResolution=enable)
            return pkt.response.get("status") == 0
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gap.add_device_to_resolving_list:

gap.add_device_to_resolving_list_
*********************************


    Add a device to the Controller Resolving List from GAP level
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gap import add_device_to_resolving_list

    add_device_to_resolving_list(engine, address, addr_type, peer_irk=0, local_irk=0, enable=0)


**CLI usage**

.. code-block:: bash

    blengine run GAP.add_device_to_resolving_list [-h] [--peer_irk PEER_IRK]
                                             [--local_irk LOCAL_IRK]
                                             [--enable ENABLE]
                                             address addr_type

*Positional arguments:*

:address:

    Bluetooth device address of the remote device

:addr_type:

    Bluetooth device address type of the remote device


options:
  -h, --help            show this help message and exit
  --peer_irk PEER_IRK   The peer's identity resolving key
  --local_irk LOCAL_IRK
                        The local identity resolving key
  --enable ENABLE       Set to TRUE to enable address resolution in LL


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GAP.", parser=add_device_to_resolving_list_parser)
    def add_device_to_resolving_list(engine, address, addr_type, peer_irk=0, local_irk=0, enable=0):
        """
        Add a device to the Controller Resolving List from GAP level
        """
        if engine.bluetooth_host_stack == "EMB":
            pkt = engine.send("EMSHI_DM_PrivAddDevToResList", 
                              addrType=addr_type,
                              IdentityAddr=address,
                              PeerIrk=peer_irk,
                              LocalIrk=local_irk,
                              enableLlPriv=enable,
                              param=0x0000) #### TO DO: Check meaning and use of param parameter in EMB stack (related to callback?)
            return pkt.response.get("status") == 0
        else:
            pkt = engine.send("EMSHI_SM_PrivacyAddDeviceInResolvingList",
                               Addr=address,
                               AddrType=addr_type)
            return pkt.response.get("status") == 0
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gap.connect:

gap.connect_
************

 
    Connect to a Remote Device - EMSHI
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gap import connect

    connect(engine, bd_addr, addrtype=0, retry=3, scan_interval_ms=30, scan_window_ms=30, conn_interval_ms=7.5, conn_timeout_ms=1000)


**CLI usage**

.. code-block:: bash

    blengine run GAP.connect [-h] [--retry RETRY]
                        [--scan_interval_ms SCAN_INTERVAL_MS]
                        [--scan_window_ms SCAN_WINDOW_MS]
                        [--conn_interval_ms CONN_INTERVAL_MS]
                        [--conn_timeout_ms CONN_TIMEOUT_MS]
                        address

*Positional arguments:*

:address:

    Bluetooth Address to connect to, call scan() to get a
                        list


options:
  -h, --help            show this help message and exit
  --retry RETRY         Number oif times to retry
  --scan_interval_ms SCAN_INTERVAL_MS
                        Scan Interval in milliseconds
  --scan_window_ms SCAN_WINDOW_MS
                        Scan Window in milliseconds
  --conn_interval_ms CONN_INTERVAL_MS
                        COnnection Interval in milliseconds
  --conn_timeout_ms CONN_TIMEOUT_MS
                        Connection Timeout in milliseconds


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GAP.", parser=connect_parser)
    def connect(engine, bd_addr, 
                addrtype=0x00, 
                retry=3, 
                scan_interval_ms=30, 
                scan_window_ms=30, 
                conn_interval_ms=7.5, 
                conn_timeout_ms=1000):
        ''' 
        Connect to a Remote Device - EMSHI
        '''
        device_connected = threading.Event()
        device_disconnected = threading.Event()
    
        status = False
    
        def on_gap_connected(pkt):
            nonlocal status 
            status = pkt.get("status")
            if pkt.get("status") == 0:
                device_connected.set()
    
        def on_gap_disconnected(pkt):
            nonlocal status 
            status = pkt.get("DisconnectionReason")
            device_disconnected.set()
    
        engine.bind("on_BLEGAP_EVENT_CONNECTED", on_gap_connected)
        engine.bind("on_BLEGAP_EVENT_DISCONNECTED", on_gap_disconnected)
    
        pkt = engine.send(  "EMSHI_GAP_ConnectWithIntervalsEx",
                            Addr=bd_addr, AddrType=addrtype,
                            ScanInterval=int(scan_interval_ms * 1.6),  # ratio 1/0.625
                            ScanWindow=int(scan_window_ms * 1.6),  # ratio 1/0.625
                            ConnectionInterval=int(conn_interval_ms * 0.8),  # ratio 1/1.25
                            ConnectionTimeout=int(conn_timeout_ms / 10),  # 10ms
                            timeout=conn_timeout_ms / 1000,
                            retry=retry)
    
        '''
        pkt = engine.send("EMSHI_GAP_Connect",
                        Addr=bd_addr, AddrType=0x00)
        '''
    
        ok = device_connected.wait(timeout=0.1 + (conn_timeout_ms / 1000))
    
    
        engine.unbind("on_BLEGAP_EVENT_CONNECTED", on_gap_connected)
    
        nok = device_disconnected.wait(timeout=0.1 + (conn_interval_ms * 8) / 1000)
    
        engine.unbind("on_BLEGAP_EVENT_DISCONNECTED", on_gap_disconnected)
    
        msg = "Connected to %s" % mac(bd_addr)
    
        if ok is False:
            msg = "Cannot connect to %s, status: %s" % (mac(bd_addr), status)
    
        if nok is True:
            ok = False
            msg = "Connected, then Disconnected from %s, status: %s" % (mac(bd_addr), status)
    
        return ok, msg
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gap.scan:

gap.scan_
*********


    Scan for devices and return a advertising packets list. (EMSHI only)

    Two callbacks can be provided for the advertising packets and for the scan
    response.

    :param      engine:            The engine
    :param      mode:              The mode
    :param      duration_ms:       The duration milliseconds
    :param      scan_interval_ms:  The scan interval milliseconds
    :param      scan_window_ms:    The scan window milliseconds
    :param      address_filter:    The address filter
    :param      name_filter:       The name filter
    :param      uuid_filter:       The uuid filter
    :param      nearest:           The nearest filter
    :param      retry:             The retry
    :param      on_advertising:    On advertising Callback
    :param      on_scan_response:  On scan response Callback

    :returns:   status and advertising packets
    :rtype:     tuple(str, list)
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gap import scan

    scan(engine, mode=2, scan_Type=1, duration_ms=3000, scan_interval_ms=250, scan_window_ms=250, address_filter=None, name_filter=None, uuid_filter=None, retry=0, on_advertising=None, on_scan_response=None)


**CLI usage**

.. code-block:: bash

    blengine run GAP.scan [-h] [--mode MODE] [--scan_Type SCAN_TYPE]
                     [--duration_ms DURATION_MS]
                     [--scan_interval_ms SCAN_INTERVAL_MS]
                     [--scan_window_ms SCAN_WINDOW_MS]
                     [--address_filter ADDRESS_FILTER]
                     [--name_filter NAME_FILTER] [--uuid_filter UUID_FILTER]


options:
  -h, --help            show this help message and exit
  --mode MODE           Connection Mode, 0x01:External, 0x02:General
  --scan_Type SCAN_TYPE
                        Scan Type , 0x00:Passive, 0x01:Active
  --duration_ms DURATION_MS
                        Duration of the scan in milliseconds
  --scan_interval_ms SCAN_INTERVAL_MS
                        Scan interval in milliseconds
  --scan_window_ms SCAN_WINDOW_MS
                        Advertisement Window in ^milliseconds
  --address_filter ADDRESS_FILTER
                        Filter Devices based on this MAC Address
  --name_filter NAME_FILTER
                        Filter Devices which name contain this string
  --uuid_filter UUID_FILTER
                        Filter the devices that advertise the specific uuid


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GAP.", parser=scan_parser)
    def scan(engine,
             mode=0x02,
             scan_Type=0x01,
             duration_ms=3000,
             scan_interval_ms=250,
             scan_window_ms=250,
             address_filter=None,
             name_filter=None,
             uuid_filter=None,
             retry=0,
             on_advertising=None,
             on_scan_response=None):
        """
        Scan for devices and return a advertising packets list. (EMSHI only)
    
        Two callbacks can be provided for the advertising packets and for the scan
        response.
    
        :param      engine:            The engine
        :param      mode:              The mode
        :param      duration_ms:       The duration milliseconds
        :param      scan_interval_ms:  The scan interval milliseconds
        :param      scan_window_ms:    The scan window milliseconds
        :param      address_filter:    The address filter
        :param      name_filter:       The name filter
        :param      uuid_filter:       The uuid filter
        :param      nearest:           The nearest filter
        :param      retry:             The retry
        :param      on_advertising:    On advertising Callback
        :param      on_scan_response:  On scan response Callback
    
        :returns:   status and advertising packets
        :rtype:     tuple(str, list)
        """
        if engine.bluetooth_host_stack == "EMB":
            
            results = []
            status = False
            
            def on_scan_report(pkt):
                nonlocal status          
                results.append(pkt)
                status = pkt.get("status")
            
            engine.send("EMSHI_DM_ScanSetInterval", scanPhys=0x01, scanInterval_arr=scan_interval_ms, scanWindow_arr=scan_window_ms)
            engine.bind("on_DM_SCAN_REPORT_IND", on_scan_report)
            
            engine.send("EMSHI_DM_ScanStart", 
                        scanPhys=0x01,
                        mode=mode, 
                        ScanType=scan_Type, 
                        filterDup=0, # Filter duplicates disabled
                        duration=duration_ms,
                        period=0)    # periodic scanning disabled
            
            time.sleep(4)         
             
            engine.send("EMSHI_DM_ScanStop")
            engine.unbind("on_DM_SCAN_REPORT_IND")
            
            return status, results #The status is success only when DM_SCAN_REPORT is generated, which is when scanning take place.
            
        else:
    
            if uuid_filter:
                uuid_filter = UUID(uuid_filter)
    
            results = []
    
            added_parsing_time_ms = 100
    
            scan_complete = threading.Event()
    
            last_rx_time = time.perf_counter()
    
            def process_adv_packet(pkt):
                # if it does not pass the address filter, discard it right away
                if address_filter and pkt.get("LocalAddress") != address_filter:
                    return
    
                data = gap_ad_storage.decode_adv_data(pkt.get("data"))
    
                # get rid of this packet if it doesn't pass the filter.
                if not filter_adv_pkt(pkt, name_filter, uuid_filter):
                    return
    
                # add the Decoded advertising Data to the Packet.
                pkt.frag("AdvData").extend(data)
    
                return True
    
            def on_advertising_packet(pkt):
                '''
                Callback method executed when a advertisement event is received
                '''
                nonlocal last_rx_time
                pkt.is_scan_response = False
    
                if process_adv_packet(pkt):
                    if callable(on_advertising):
                        if on_advertising(pkt) is False:
                            scan_complete.set()
                    results.append(pkt)
    
                last_rx_time = time.perf_counter()
    
            def on_scan_response_packet(pkt):
                pkt.is_scan_response = True
    
                if process_adv_packet(pkt):
                    if callable(on_scan_response):
                        on_scan_response(pkt)
                    results.append(pkt)
    
            scan_interval = int(scan_interval_ms * 1.6)
            scan_window = int(scan_window_ms * 1.6)
    
            engine.bind("on_BLEGAP_EVENT_INQUIRYRESULT", on_advertising_packet)
            engine.bind("on_BLEGAP_EVENT_INQUIRYRESULT_EXT", on_scan_response_packet)
    
            def on_inquiry_complete(pkt):
                if pkt.get("status") == 0:
                    scan_complete.set()
    
            # raise the scan complete flag when inquiry complete packet is received
            engine.bind("on_BLEGAP_EVENT_INQUIRYCOMPLETE", on_inquiry_complete)
    
            timeout = 1 + (duration_ms/1000)
    
            inquiry_pkt = engine.send(  "EMSHI_GAP_StartInquiryWithIntervals",
                                        Mode=mode,
                                        ScanInterval=scan_interval, 
                                        ScanWindow=scan_window, 
                                        Duration=duration_ms, 
                                        retry=1,
                                        timeout=timeout,
                                        wait_ack=True)
    
            #if inquiry_pkt.response.get("status") == 0:
            # wait for the scan to be complete (device side)
            scan_complete.wait(timeout=timeout)
    
            #logger.get("scan").info(inquiry_pkt)
    
            # wait for processing time before unbinding events, there can be many events 
            # and we have to wait on the parser.
            # we wait max 500ms but while True is bad ! consider refactoring
            while True:
                if (time.perf_counter() - last_rx_time) * 1000 > added_parsing_time_ms:
                    break
    
                time.sleep(0.05)
    
            engine.unbind("on_BLEGAP_EVENT_INQUIRYRESULT", on_advertising_packet)
            engine.unbind("on_BLEGAP_EVENT_INQUIRYRESULT_EXT", on_scan_response)
            engine.unbind("on_BLEGAP_EVENT_INQUIRYCOMPLETE", on_inquiry_complete)
    
            return inquiry_pkt.response.get("status") == 0, results
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-observe:

observe_
********


    Scan for devices and return a device list. (EMSHI only)
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gap import observe

    observe(engine, mode=2, whitelist_address=None, filter_duplicate=True, duration_ms=5000, scan_interval_ms=250, scan_window_ms=250, retry=0)


**CLI usage**

.. code-block:: bash

    blengine run observe [-h]
                    mode whitelist_address filter_duplicate duration_ms
                    scan_interval_ms scan_window_ms

*Positional arguments:*

:mode:

    Connection Mode, 0x01:External, 0x02:General

:whitelist_address:

    the mac address to whitelist

:filter_duplicate:

    Filter duplicates

:duration_ms:

    Duration of the scan in milliseconds

:scan_interval_ms:

    Scan interval in milliseconds

:scan_window_ms:

    Advertisement Window in ^milliseconds


options:
  -h, --help         show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(parser=obs_parser)
    def observe(engine,
                mode=0x02,
                whitelist_address=None,
                filter_duplicate=True,
                duration_ms=5000,
                scan_interval_ms=250,
                scan_window_ms=250,
                retry=0):
        """
        Scan for devices and return a device list. (EMSHI only)
        """
        results = []
    
        added_parsing_time_ms = 500
    
        observation_complete = threading.Event()
        response_lock = threading.Lock()
    
        def on_obs_response(pkt):
            '''
            Callback method executed when a advertisement event is received
            '''
    
            # if it does not pass the address filter, discard it right away
            if address_filter and bytearray(pkt.get("LocalAddress").hex()) != address_filter:
                return
    
            data = gap_ad_storage.decode_adv_data(pkt.get("data"))
    
            # add the Decoded advertising Data to the Packet.
            pkt.frag("AdvData").extend(data)
    
            results.append( pkt )
            last_rx_time = datetime.datetime.datetime.now()
    
        scan_interval = int(scan_interval_ms * 1.6)
        scan_window = int(scan_window_ms * 1.6)
    
        if whitelist_address:
            engine.send("EMSHI_WHITELIST_AddDevice", Addr=whitelist_address, AddrType=0x00)
            engine.send("EMSHI_WHITELIST_SetScanningFilterPolicy", ScanningFilterPolicy=0x01)
    
        engine.bind("on_BLEGAP_EVENT_OBSERVEMODE_DATA", on_obs_response)
    
        last_rx_time = datetime.datetime.datetime.now()
    
        timeout = 1+(duration_ms/1000)
        pkt = engine.send("EMSHI_GAP_StartObserveProcedureWithIntervals", DuplicateFiltering=int(filter_duplicate),
            ScanInterval=scan_interval, ScanWindow=scan_window, timeout=timeout, Duration=duration_ms, retry=1)
    
        # wait for the scan to be complete (device side)
        observation_complete.wait(timeout=timeout)
    
        # wait for processing time before unbinding events, there can be many events and we have to wait on the parser.
        # we wait max 500ms but while True is bad ! consider refactoring
        while True:
            with response_lock:
                if datetime.datetime.datetime.now() - last_rx_time > datetime.timedelta(milliseconds=added_parsing_time_ms):
                    break
    
            time.sleep(0.05)
    
        engine.unbind("on_BLEGAP_EVENT_OBSERVEMODE_DATA", on_obs_response)
    
        if whitelist_address:
            engine.send("EMSHI_WHITELIST_RemoveDevice", Addr=whitelist_address, AddrType=0x00)
            engine.send("EMSHI_WHITELIST_SetScanningFilterPolicy", ScanningFilterPolicy=0x00)
    
        return pkt.response.get("status") == 0, results
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-connection_update:

connection_update_
******************


    Perform a GAP Connection Parameter Update procedure to modify connection interval, latency or supervision timeout
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gap import connection_update

    connection_update(engine, conn_handle, interval_min=10, interval_max=3200, latency=0, timeout=1000)


**CLI usage**

.. code-block:: bash

    blengine run connection_update [-h] [--interval_min INTERVAL_MIN]
                              [--interval_max INTERVAL_MAX]
                              [--latency LATENCY] [--timeout TIMEOUT]
                              conn_handle

*Positional arguments:*

:conn_handle:

    Connection Handle


options:
  -h, --help            show this help message and exit
  --interval_min INTERVAL_MIN
                        Minimum value for the connection interval
  --interval_max INTERVAL_MAX
                        Maximum value for the connection interval
  --latency LATENCY     Peripheral latency for the connection in number of
                        connection events
  --timeout TIMEOUT     Connection timeout


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(parser=connection_update_parser)
    def connection_update(engine,
                          conn_handle,
                          interval_min=0x000A,
                          interval_max=0x0C80,
                          latency=0,
                          timeout=1000):
        """
        Perform a GAP Connection Parameter Update procedure to modify connection interval, latency or supervision timeout
        """
        if engine.bluetooth_host_stack == "EMB":
            pkt = engine.send("EMSHI_DM_ConnUpdate",
                              connId=conn_handle,
                              connIntervalMin=interval_min,
                              connIntervalMax=interval_max,
                              connLatency=latency,
                              supTimeout=timeout,
                              minCeLen=0,
                              maxCeLen=0,
                              )
            return pkt.response.get("status") == 0
        else:
            pkt = engine.send("EMSHI_GAP_UpdateConnectionIntervalEx",
                                    ConnHandle=conn_handle,
                                    ConnectionIntervalMin=interval_min,
                                    ConnectionIntervalMax=interval_max,
                                    ConnLatency=latency,
                                    ConnTimeout=timeout)
            return pkt.response.get("status") == 0
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gap.connect_simple:

gap.connect_simple_
*******************


    Initiate a GAP connection to a given address
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gap import connect_simple

    connect_simple(engine, address, addrtype=0)


**CLI usage**

.. code-block:: bash

    blengine run GAP.connect_simple [-h] [--addrtype ADDRTYPE] address

*Positional arguments:*

:address:

    Bluetooth Address to connect to


options:
  -h, --help           show this help message and exit
  --addrtype ADDRTYPE  Address Type of the device to connect to


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GAP.", parser=connect_simple_parser)
    def connect_simple(engine, address, addrtype=0x00):
        '''
        Initiate a GAP connection to a given address
        '''
        if engine.bluetooth_host_stack == "EMB":
            engine.send("EMSHI_DM_ConnOpen",
                        clientId=3,
                        initPhys=0x01,
                        addrType=addrtype,
                        Addr=address)
        else:
            engine.send("EMSHI_GAP_Connect", retry=1, Addr=address, AddrType=addrtype)
            pkt = engine.send("EMSHI_GAP_GetConnectionHandle", Addr=address)
            return True, pkt.response.get("ConnHandle")
    


.. raw:: html
    
    </details>
    <hr>

this page is auto generated by BLEngine/docs/procedures.py