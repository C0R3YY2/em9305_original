
.. this file is auto generated by BLEngine/docs/procedures.py

=============================
hci Procedures
=============================

.. raw:: html
    
    
    <input class="search input" type="text" placeholder="Live Search" style="width: 100%; padding: 10px;">
    <div>&nbsp</div>
    <div id="search-loader" style="display:none;">please wait...</div>
    
.. _proc-hci.get_local_device_infos:

hci.get_local_device_infos_
***************************


    
    Get all saort of devices informations and try to identify which device is connected.

    Also gather informations about an eventual dvk.
    
    the decision flow chart is as follow (subject to change):
    
    if there is a DVK (DVK_Get_Product_Name)
    then
          DVK commands supported
          get dvk informations
    
    if it's a HCI controller ? (Read_local_....)
    then
         if it's a EM controller (Company_identifier EM or PC)
         then 
             firmware is EM HCI (EMB) 
             Some vendor commands are supported (Enter config mode, ....)
             
         else
             Firmware HCI Generic
             Unknown HCI Controller unknown Vendor commands
         anyway 
             standard HCI Features detection (LE, ACL, ...)
    else
         if it's EMSHI (EMSHI_ARC_VersionBleHost)
         then 
             Firmware EMSHI (EMB or AW)
             detect host stack and version (EMB, AW)
             and other stuff TBD
         else if it's EMCore (EMSG_Get_EMCore_Information)
             Firmware EMCore
             get EMCore infos (Mac Address, Memory Usage, ...)
             And other stuff TBD
         else if device is in config mode (EMSG_Read_Product_Information)
             Firmware ROM
             get firmware header and other stuff
             authentication
         else
             it's a SOC Application
             if it's unity (Unity_init)
                 Firmware Unity, informations TBD
             else
                 Firmware Standalone SOC  

    :param      engine:  The engine
    
    :returns:   The device infos.
    :rtype:     dictionary
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.hci import get_local_device_infos

    get_local_device_infos(engine)


**CLI usage**

.. code-block:: bash

    No Help

.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @storage.procedure(prefix="HCI.")
    def get_local_device_infos(engine):
        """
        
        Get all saort of devices informations and try to identify which device is connected.
    
        Also gather informations about an eventual dvk.
        
        the decision flow chart is as follow (subject to change):
        
        if there is a DVK (DVK_Get_Product_Name)
        then
              DVK commands supported
              get dvk informations
        
        if it's a HCI controller ? (Read_local_....)
        then
             if it's a EM controller (Company_identifier EM or PC)
             then 
                 firmware is EM HCI (EMB) 
                 Some vendor commands are supported (Enter config mode, ....)
                 
             else
                 Firmware HCI Generic
                 Unknown HCI Controller unknown Vendor commands
             anyway 
                 standard HCI Features detection (LE, ACL, ...)
        else
             if it's EMSHI (EMSHI_ARC_VersionBleHost)
             then 
                 Firmware EMSHI (EMB or AW)
                 detect host stack and version (EMB, AW)
                 and other stuff TBD
             else if it's EMCore (EMSG_Get_EMCore_Information)
                 Firmware EMCore
                 get EMCore infos (Mac Address, Memory Usage, ...)
                 And other stuff TBD
             else if device is in config mode (EMSG_Read_Product_Information)
                 Firmware ROM
                 get firmware header and other stuff
                 authentication
             else
                 it's a SOC Application
                 if it's unity (Unity_init)
                     Firmware Unity, informations TBD
                 else
                     Firmware Standalone SOC  
    
        :param      engine:  The engine
        
        :returns:   The device infos.
        :rtype:     dictionary
        """
        infos = {}
    
        timeout = 0.1
        
        # CHECK FOR DVK
    
        pkt_check_dvk = engine.send("DVK_Get_Product_Name", timeout=timeout)
    
        if pkt_check_dvk.response.get("status") == 0x00:
    
            infos["Firmware"] = "Unknown"
    
            infos["DVK"] = pkt_check_dvk.response.get("name")
    
            pkt = engine.send("DVK_Get_Product_Serial_Number")
    
            infos["DVK_Serial"] = pkt.response.get("serial_number").hex()
    
            pkt = engine.send("DVK_Get_Product_Hardware_Version")
    
            infos["DVK_Hardware_Version"] = pkt.response.get("hardware_version")
    
            pkt = engine.send("DVK_Get_Product_Software_Version")
    
            infos["DVK_Software_Version"] = pkt.response.get("software_version")
    
        # HCI Controller check
    
        pkt_check_hci = engine.send("Read_BD_ADDR", timeout=timeout)
    
        if pkt_check_hci.response.get("status") == 0:
    
            infos["MAC"] = str(pkt_check_hci.response.get("BD_ADDR"))
    
            pkt = engine.send("Read_Local_Version_Information", timeout=timeout)
    
            if pkt.response.get("status") == 0:
    
                infos["HCI_Version"] = pkt.response.get("HCI_Version")
                infos["HCI_SubVersion"] = pkt.response.get("HCI_SubVersion")
                infos["LMP_Version"] = pkt.response.get("LMP_Version")
                infos["Company_Id"] = pkt.response.get("Company_identifier")
                infos["LMP_Subversion"] = pkt.response.get("LMP_SubVersion")
    
                infos["Bluetooth_Version"] = HCI_BT_VERSIONS.get(infos["HCI_Version"], 'Unknown')
                infos["Company"] = COMPANY_IDENTIFIERS.get(infos["Company_Id"], 'Unknown')
    
            if infos.get("Company") in ["EM", "PacketCraft"]:
                infos["Firmware"] = "EM HCI Controller"
            else:
                infos["Firmware"] = "Generic HCI Controller"
    
            # Standard HCI Features Detection
    
            pkt = engine.send("Read_Local_Supported_Features", timeout=timeout)
    
            infos["LMP_Features"] = pkt.response.get("LMP_Features")
    
            infos["LMP_Supported_Features"] = bitfield_map(infos["LMP_Features"] or [], LMP_FEATURES_SUPPORT)
    
            pkt = engine.send("Read_Local_Extended_Features", Page_Number=1, timeout=timeout)
    
            infos["LMP_Features_Page_1"] = pkt.response.get("Extended_LMP_Features")
    
            pkt = engine.send("Read_Local_Extended_Features", Page_Number=2, timeout=timeout)
    
            infos["LMP_Features_Page_2"] = pkt.response.get("Extended_LMP_Features")
    
    
            pkt = engine.send("Read_Buffer_Size", timeout=timeout)
    
            if pkt.response.get("status") == 0:
    
                infos["ACL_Data_Packet_Length"] = pkt.response.get("ACL_Data_Packet_Length")
                
                infos["Synchronous_Data_Packet_Length"] = pkt.response.get("Synchronous_Data_Packet_Length")
                
                infos["Total_Num_ACL_Data_Packets"] = pkt.response.get("Total_Num_ACL_Data_Packets")
                
                infos["Total_Num_Synchronous_Data_Packets"] = pkt.response.get("Total_Num_Synchronous_Data_Packets")
    
            # if LE is supported
            if infos["LMP_Features"][38] == '1':
    
                pkt = engine.send("LE_Read_Local_Supported_Features", timeout=timeout)
    
                infos["LE_Features"] = pkt.response.get("LE_Features")
    
                infos["LE_Supported_Features"] = bitfield_map(infos["LE_Features"] or [], LE_FEATURES_SUPPORT_BITS)
    
                pkt = engine.send("LE_Read_Supported_States", timeout=timeout)
    
                infos["LE_Supported_States"] = pkt.response.get("LE_States") or []
    
                pkt = engine.send("LE_Read_Buffer_Size_V1", timeout=timeout)
    
                if pkt.response.get("status") == 0:
    
                    infos["LE_ACL_Data_Packet_Length"] = pkt.response.get("LE_ACL_Data_Packet_Length")
                    
                    infos["Total_Num_LE_ACL_Data_Packets"] = pkt.response.get("Total_Num_LE_ACL_Data_Packets")
                
                pkt = engine.send("LE_Read_Buffer_Size_V2", timeout=timeout)
    
                if pkt.response.get("status") == 0:
    
                    infos["LE_ACL_Data_Packet_Length"] = pkt.response.get("LE_ACL_Data_Packet_Length")
                    
                    infos["Total_Num_LE_ACL_Data_Packets"] = pkt.response.get("Total_Num_LE_ACL_Data_Packets")
                    
                    infos["ISO_Data_Packet_Length"] = pkt.response.get("ISO_Data_Packet_Length")
                    
                    infos["Total_Num_ISO_Data_Packets"] = pkt.response.get("Total_Num_ISO_Data_Packets")
    
                pkt = engine.send("LE_Read_Suggested_Default_Data_Length", timeout=timeout)
    
                if pkt.response.get("status") == 0:
    
                    infos["Suggested_Max_TX_Octets"] = pkt.response.get("Suggested_Max_TX_Octets")
                    
                    infos["Suggested_Max_TX_Time"] = pkt.response.get("Suggested_Max_TX_Time")
                
                pkt = engine.send("LE_Read_Maximum_Data_Length", timeout=timeout)
    
                infos["Supported_Max_TX_Octets"] = pkt.response.get("Suggested_Max_TX_Octets") or 31
                
                pkt = engine.send("LE_Read_Antenna_Information", timeout=timeout)
    
                if pkt.response.get("status") == 0:
    
                    infos["Supported_Switching_Sampling_Rates"] = pkt.response.get("Supported_Switching_Sampling_Rates")
                    
                    infos["Num_Antennae"] = pkt.response.get("Num_Antennae")
                    
                    infos["Max_Switching_Pattern_Length"] = pkt.response.get("Max_Switching_Pattern_Length")
                    
                    infos["Max_CTE_Length"] = pkt.response.get("Max_CTE_Length")
                
                pkt = engine.send("LE_Read_RF_Path_Compensation", timeout=timeout)
    
                if pkt.response.get("status") == 0:
    
                    infos["RF_TX_Path_Compensation_Value"] = pkt.response.get("RF_TX_Path_Compensation_Value")
                    
                    infos["RF_RX_Path_Compensation_Value"] = pkt.response.get("RF_RX_Path_Compensation_Value")
                
                pkt = engine.send("LE_Read_Transmit_Power", timeout=timeout)
    
                if pkt.response.get("status") == 0:
    
                    infos["Min_TX_Power"] = pkt.response.get("Min_TX_Power")
                
                    infos["Max_TX_Power"] = pkt.response.get("Max_TX_Power")
                
                pkt = engine.send("LE_Read_Number_of_Supported_Advertising_Sets", timeout=timeout)
    
                infos["Num_Supported_Advertising_Sets"] = pkt.response.get("Num_Supported_Advertising_Sets")
    
                '''
                # If LE Data Packet Length Extension (bit position 5) or LE Coded PHY features (bit position 11), the default data length shall be 251
    
                if infos["LE_Features"][5] == "1" or infos["LE_Features"][11] == "1":
                    engine.send("LE_Write_Suggested_Default_Data_Length", Suggested_Max_TX_Octets=251, Suggested_Max_TX_Time = 328, timeout=timeout)
                '''
    
                pkt = engine.send("LE_Read_Advertising_Channel_Tx_Power", timeout=timeout)
    
                if pkt.response.get("status") == 0:
                    
                    infos["Advertising_TX_Power_Level"] = pkt.response.get("TX_Power_Level")
    
            else:   # LE no supported
    
                pkt = engine.send("Read_Data_Block_Size", timeout=timeout)
    
                if pkt.response.get("status") == 0:
    
                    infos["Max_ACL_Data_Packet_Length"] = pkt.response.get("Max_ACL_Data_Packet_Length")
                    
                    infos["Data_Block_Length"] = pkt.response.get("Data_Block_Length")
                    
                    infos["Total_Num_Data_Blocks"] = pkt.response.get("Total_Num_Data_Blocks")      
    
        else: # It's NOT a HCI Controller
    
            pkt_check_emshi = engine.send("EMSHI_ARC_VersionBleHost", timeout=timeout)
    
            if pkt_check_emshi.response.get("status") == 0:
    
                infos["Firmware"] = "EMSHI"
    
                v = [ str(s) for s in pkt.response.get("Version", []) ]
    
                infos["Firmware_Version"] = ".".join(v)
    
                infos["Firmware_Stack"] = HOST_STACK.get(pkt.response.get("Stack")) or pkt.response.get("Stack")
    
            # EMCORE Check
            
            pkt_check_emcore = engine.send("EMSG_Get_EMCore_Information", timeout=timeout)
    
            if pkt_check_emcore.response.get("status") == 0x00:
    
                infos["Firmware"] = "EMCore"
    
                infos["EMCore_Flavor"] = EMCORE_FLAVORS.get(pkt_check_emcore.response.get("Variant_ID")) \
                                                or pkt_check_emcore.response.get("Variant_ID")
    
                infos["EMCore_Version"] = pkt_check_emcore.response.get("Version")
    
            # CHECK FOR CONFIG MODE
    
            firmwares = []
    
            # ! This will work almost everytime
            pkt_check_rom = engine.send("EMSG_Read_Product_Information", timeout=0.2)
    
            if pkt_check_rom.response.get("status") == 0x00:
    
                infos["Firmware"] = "ROM"
    
                rsp = pkt_check_rom.response
    
                infos["Product_Infos_Version"] = rsp.get("Product_Information_Structure_Version")
    
                infos["Product_IC_Family_ID"] = rsp.get("IC_Family_ID")
    
                infos["Product_Lot_ID"] = rsp.get("Lot_ID")
    
                infos["Product_Wafer_Number"] = rsp.get("Wafer_Number")
    
                infos["Product_X_Position"] = rsp.get("X_Position")
    
                infos["Product_Y_Position"] = rsp.get("Y_Position")
    
                infos["Product_Maskset"] = rsp.get("Maskset")
    
                infos["Product_Test_Program_Revision"] = rsp.get("Test_Program_Revision")
    
                infos["Product_Test_Program_Version"] = rsp.get("Test_Program_Version")
    
                infos["Product_Package_Type"] = rsp.get("Package_Type")
    
            pkt = engine.send("EMSG_Read_MAC_Address", timeout = timeout)
    
            infos["MAC"] = pkt.response.get("LocalAddress")
    
            pkt = engine.send("EMSG_Get_Memory_Usage", timeout=timeout)
    
            infos["RAM_Pool_Size"] = pkt.response.get("RAM_Pool_Size")
    
            infos["PRAM_Used"] = pkt.response.get("PRAM_Used")
    
            infos["NPRAM_Used"] = pkt.response.get("NPRAM_Used")
    
            infos["PRAM_Reserved"] = pkt.response.get("PRAM_Reserved")
    
        return True, infos
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-hci.get_remote_device_infos:

hci.get_remote_device_infos_
****************************


    
    :param      engine:  The engine
    
    :returns:   The device infos.
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.hci import get_remote_device_infos

    get_remote_device_infos(engine, conn_handle)


**CLI usage**

.. code-block:: bash

    blengine run HCI.get_remote_device_infos [-h] conn_handle

*Positional arguments:*

:conn_handle:

    Connection Handle


options:
  -h, --help   show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @storage.procedure(prefix="HCI.", parser=remote_infos_parser)
    def get_remote_device_infos(engine, conn_handle):
        """
        
        :param      engine:  The engine
        
        :returns:   The device infos.
        :rtype:     { return_type_description }
        """
        infos = {}
    
        pkt = engine.send("LE_Read_PHY", Connection_Handle=conn_handle, timeout=0.1)
    
        infos["TX_PHY"] = pkt.response.get("TX_PHY")
    
        infos["RX_PHY"] = pkt.response.get("RX_PHY")
            
    
        return True, infos
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-send_acl_data:

send_acl_data_
**************


    :param      engine:          The engine
    :param      conn_handle:     The connection handle
    :param      data:            The data
    :param      flushable:       The flushable
    :param      broadcast_flag:  The broadcast flag
    :param      max_size:        The maximum size
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.hci import send_acl_data

    send_acl_data(engine, conn_handle, data=None, ascii_data=True, flushable=False, broadcast_flag=0, max_size=None, no_wait=False, pause=0, buffered=False)


**CLI usage**

.. code-block:: bash

    blengine run send_acl_data [-h] [--ascii_data] [--flushable] [--broadcast_flag]
                          [--max_size MAX_SIZE] [--pause PAUSE] [--buffered]
                          conn_handle data

*Positional arguments:*

:conn_handle:

    Connection Handle

:data:

    Data


options:
  -h, --help           show this help message and exit
  --ascii_data         Do not convert data to bytes
  --flushable          flushable flag
  --broadcast_flag     broadcast flag
  --max_size MAX_SIZE  Maximum Chunk Size in bytes
  --pause PAUSE        Pause between send ACL, in seconds
  --buffered           Create all the payloads and send all at once


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def send_acl_data(engine, conn_handle, data=None, ascii_data=True, flushable=False, broadcast_flag=0x00, max_size=None, no_wait=False, pause=0, buffered=False):
        """
        :param      engine:          The engine
        :param      conn_handle:     The connection handle
        :param      data:            The data
        :param      flushable:       The flushable
        :param      broadcast_flag:  The broadcast flag
        :param      max_size:        The maximum size
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        """
        pflag = 0b00
    
        device_max_size = engine.device_infos.get("LE_ACL_Data_Packet_Length", 0x000a)
    
        max_size = max_size or device_max_size or 24
    
        timeout = 3
    
        if ascii_data:
            data = str.encode(data)
    #    else:
    #        data = bytes.fromhex(data)
    
        if(len(data) > max_size):
            if flushable:
                pflag = 0b10
            else:
                pflag = 0b00
    
        chunks = math.ceil(len(data) / max_size)
    
        completed_packets = 0
        
        def on_packet_complete(pkt):
            nonlocal completed_packets
            if pkt.get("Connection_Handles") == conn_handle:
                completed_packets += (pkt.get("Num_Completed_Packets") or 0)
    
        engine.bind("on_Number_Of_Completed_Packets", on_packet_complete)
    
        start_time = time.perf_counter()
    
        if buffered is True:
    
            _bytes = bytearray()
    
            for i in range(chunks):
                d = data[i*max_size:i*max_size+max_size]
                
                if i > 0 and len(data) > max_size:
                    pflag = 0b01
                
                pkt = engine.make("HCI_ACL_DATA", 
                    Connection_Handle=conn_handle,
                    Packet_Boundary_Flag=pflag,
                    Broadcast_Flag=broadcast_flag,
                    length=len(d),
                    data=d,
                    #wait_ack=Falseiterable
                )
    
                _bytes.extend(pkt.encode())
    
            engine.send_raw(_bytes)
    
        else:
            for i in range(chunks):
                d = data[i*max_size:i*max_size+max_size]
                
                if i > 0 and len(data) > max_size:
                    pflag = 0b01
    
                pkt = engine.send("HCI_ACL_DATA", 
                    Connection_Handle=conn_handle,
                    Packet_Boundary_Flag=pflag,
                    Broadcast_Flag=broadcast_flag,
                    length=len(d),
                    data=d,
                    #wait_ack=Falseiterable
                )
    
                time.sleep(pause)
    
        total_time = time.perf_counter() - start_time
    
        speed_kb = (len(data) / 1000) / total_time
    
        logger.get("ACL").info("sent %s bytes in %ss (%skb/s)" % (len(data), total_time, speed_kb))
    
        if no_wait == False:
            while time.perf_counter() - start_time < timeout:
                if completed_packets == chunks:
                    break
    
        engine.unbind("on_Number_Of_Completed_Packets", on_packet_complete)
    
        return completed_packets == chunks, "sent %s of %s packets" % (completed_packets, chunks)
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-send_iso_data:

send_iso_data_
**************


    BLUETOOTH CORE SPECIFICATION Version 5.3 | Vol 4, Part E page 1816
    Host Controller Interface Functional Specification
    5.4.5 HCI ISO Data packets
    
    :param      engine:       The engine
    :param      conn_handle:  The connection handle
    :param      data:         The data
    :param      broadcast:    The broadcast
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.hci import send_iso_data

    send_iso_data(engine, conn_handle, data, ascii_data=False, ts_flag=False, max_size=None, interval_ms=20)


**CLI usage**

.. code-block:: bash

    blengine run send_iso_data [-h] [--ascii_data] [--ts_flag]
                          [--max_size MAX_SIZE] [--interval_ms INTERVAL_MS]
                          conn_handle data

*Positional arguments:*

:conn_handle:

    Connection Handle

:data:

    Data


options:
  -h, --help            show this help message and exit
  --ascii_data          Do not convert data to bytes
  --ts_flag             TS Flag
  --max_size MAX_SIZE   Maximum Chunk Size in bytes
  --interval_ms INTERVAL_MS
                        Throttle interval between ISO_Data commands in
                        milliseconds


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def send_iso_data(engine, conn_handle, data, ascii_data=False, ts_flag=False, max_size=None, interval_ms=20):
        """
        BLUETOOTH CORE SPECIFICATION Version 5.3 | Vol 4, Part E page 1816
        Host Controller Interface Functional Specification
        5.4.5 HCI ISO Data packets
        
        :param      engine:       The engine
        :param      conn_handle:  The connection handle
        :param      data:         The data
        :param      broadcast:    The broadcast
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        """
        pb_flag = 0b10 # default is a complete fragment
    
        device_max_size = engine.device_infos.get("ISO_Data_Packet_Length", 0x000a)
    
        max_size = max_size or device_max_size
    
        timeout = 1
    
        interval_s = interval_ms * 0.001
    
        if ascii_data:
            data = data
        else:
            data = bytes.fromhex(data)
    
        if(len(data) > max_size):
            pb_flag = 0b00 # first fragment
    
        chunks = math.ceil(len(data) / max_size)
    
        completed_packets = 0
        
        def on_packet_complete(pkt):
            nonlocal completed_packets
            if pkt.get("Connection_Handles") == conn_handle:
                print(pkt.get("status"))
                completed_packets += pkt.get("Num_Completed_Packets")
    
        engine.bind("on_Number_Of_Completed_Packets", on_packet_complete)
    
        print("Will send %s in %s chunks" % (data, chunks))
    
        start_time = time.perf_counter()
    
        sdu_fragments = []
    
        for i in range(chunks):
            chunk = data[i*max_size:i*max_size+max_size]
            
            if i > 0:
                pb_flag = 0b01  # continuation
    
            if chunks > 1 and i == chunks-1:
                pb_flag = 0b11 # last
    
            ts_flag = ts_flag and pb_flag in [0b00, 0b10]
    
            sdu_fragment = ISODataLoad()
            sdu_fragment.TS_Flag = ts_flag
            sdu_fragment.set("Packet_Sequence_Number", i+1)
            sdu_fragment.set("ISO_SDU_Length", len(data))
            sdu_fragment.set("ISO_SDU_Fragment", chunk)
    
            d = sdu_fragment.encode()
    
    
            sdu_fragments.append(sdu_fragment)
    
            pkt = engine.send("HCI_ISO_DATA", 
                Connection_Handle=conn_handle,
                PB_Flag=pb_flag,
                TS_Flag=ts_flag,
                length=len(d),
                ISO_Data_Load=d,
                wait_ack=False
            )
    
            # we need to pause because of possible hardware error
            time.sleep(interval_s)
    
        while time.perf_counter() - start_time < timeout:
            if completed_packets == chunks:
                break
    
        engine.unbind("on_Number_Of_Completed_Packets", on_packet_complete)
    
        return completed_packets == chunks, "sent %s of %s packets" % (completed_packets, chunks)
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-hci_init:

hci_init_
*********


    init host controller
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.hci import hci_init

    hci_init(engine, reset=True)


**CLI usage**

.. code-block:: bash

    blengine run hci_init [-h] [--reset RESET]


options:
  -h, --help     show this help message and exit
  --reset RESET  Send HCI Reset command


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def hci_init(engine, reset=True):
        """
        init host controller
        """
        # this is a reset
    
        log = logger.get("init procedure")
    
        if reset is True:
            log.info("reset")
            engine.send("Reset")
    
        r = engine.send("LE_Rand")
    
        rnd = bytearray([   0xc2, 0xea, 0x6b, 0x6e, 0x88, 0x6a, 0xdd, 0xf9, 
                            0xc2, 0xea, 0x6b, 0x6e, 0x88, 0x6a, 0xdd, 0xf9])
    
        print(engine.send("Read_Local_Version_Information"))
    
        logger.get("init procedure").info("Sending random " + str(rnd))
    
        pkt = engine.send("LE_Encrypt", Key=rnd, Plaintext_Data=rnd)
    
        data = pkt.response.get("Encrypted_Data")
    
        logger.get("init procedure").info("Got Encrypted Data")
    
        print(engine.send("Read_Local_Supported_Features"))
    
        print(engine.send("LE_Read_Local_Supported_Features"))
    
        engine.send("LE_Read_Buffer_Size_V1")
        engine.send("LE_Set_Event_Mask", LE_Event_Mask=bytearray(
            [0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]))
    
        log.info("done")
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-connect:

connect_
********


    if len(name) > 0:
        bdAddress = self.myHciEngine.advDevices.getBDAddress(args.name)
    else:
        bdAddress = macaddress.MACAddress(args.mac)
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.hci import connect

    connect(engine, name='', address=None)


**CLI usage**

.. code-block:: bash

    blengine run connect [-h] [--name NAME] [--address ADDRESS]


options:
  -h, --help         show this help message and exit
  --name NAME        Local Name
  --address ADDRESS  MAC Address


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def connect(engine, name="", address=None):
        '''
        if len(name) > 0:
            bdAddress = self.myHciEngine.advDevices.getBDAddress(args.name)
        else:
            bdAddress = macaddress.MACAddress(args.mac)
        '''
        if address is not None:
            engine.send("CONNECT_TO", address=address)
            # self.myHciEngine.sendHciLeCreateConnection(bdAddress)
            # self.connectionHandles.append(0x0001)
        else:
            engine.logger.info("Device not found")
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-set_event_mask:

set_event_mask_
***************


    set event mask
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.hci import set_event_mask

    set_event_mask(engine, mask=None, mask_page_2=None, LE_mask=None)


**CLI usage**

.. code-block:: bash

    blengine run set_event_mask [-h] [--mask MASK] [--mask_page_2 MASK_PAGE_2]
                           [--LE_mask LE_MASK]


options:
  -h, --help            show this help message and exit
  --mask MASK           Mask
  --mask_page_2 MASK_PAGE_2
                        Mask Page 2
  --LE_mask LE_MASK     LE Mask


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def set_event_mask(engine, mask = None, mask_page_2 = None, LE_mask = None):
        '''
        set event mask
        '''
        if mask is not None:
            pkt = engine.send("Set_Event_Mask", Event_Mask=mask)
        if mask_page_2 is not None:
            pkt = engine.send("Set_Event_Mask_Page_2", Event_Mask_Page_2=mask_page_2)
        if LE_mask is not None:
            pkt = engine.send("LE_Set_Event_Mask", LE_Event_Mask=LE_mask)
    
        return True, "mask set"
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-scan:

scan_
*****


    scan
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.hci import scan

    scan(engine)


**CLI usage**

.. code-block:: bash

    blengine run scan [-h] [--state STATE]


options:
  -h, --help     show this help message and exit
  --state STATE  Scan state (start/stop)


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def scan(engine):
        '''
        scan
        '''
    
        enable = 0x00
    
        if state == "start":
            enable = 0x01
            engine.send("LE_Set_Scan_Parameters",
                        LE_Scan_Type=0x01,
                        LE_Scan_Interval=0x0030,
                        LE_Scan_Window=0x0030
                        )
    
        engine.send("LE_Set_Scan_Enable",
                    LE_Scan_Enable=enable,
                    Filter_Duplicates=0x01
                    )
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-inquiry:

inquiry_
********


    inquiry
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.hci import inquiry

    inquiry(engine)


**CLI usage**

.. code-block:: bash

    No Help

.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def inquiry(engine):
        '''
        inquiry
        '''
        adv_devices_mac = dict()
    
        def register_device(pkt):
            # store mac address as key, it provide uniqueness and sorting
            adv_devices_mac[pkt.parameters.get("Address")] = pkt.parameters.get("Data")
    
        engine.bind("on_LE_Advertising_Report", register_device)
    
        scan(engine, "start")
    
        time.sleep(1)
    
        scan(engine, "stop")
    
        engine.unbind("on_LE_Advertising_Report", register_device)
    
        return "\n".join([ str(k) for k, v in adv_devices_mac.items()])
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-test_tmp:

test_tmp_
*********


    test_tmp is used for sanity check
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.hci import test_tmp

    test_tmp(engine)


**CLI usage**

.. code-block:: bash

    No Help

.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def test_tmp(engine):
        '''
        test_tmp is used for sanity check
        '''
        pkt = engine.send("EMSMM_Write_Continue_Without_Response", Data=bytearray(4))
        print(pkt)
        pkt = engine.send("EMSMM_Write_At_Address_Without_Response", Start_Address=0, Data=bytearray(4))
        print(pkt)
        pkt = engine.send("EMSMM_Write_At_Address_Without_Response", Start_Address=0, Data=bytearray(4))
        print(pkt)
    


.. raw:: html
    
    </details>
    <hr>

this page is auto generated by BLEngine/docs/procedures.py