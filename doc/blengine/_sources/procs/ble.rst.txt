
.. this file is auto generated by BLEngine/docs/procedures.py

=============================
ble Procedures
=============================

.. raw:: html
    
    
    <input class="search input" type="text" placeholder="Live Search" style="width: 100%; padding: 10px;">
    <div>&nbsp</div>
    <div id="search-loader" style="display:none;">please wait...</div>
    
.. _proc-get_conn_handle:

get_conn_handle_
****************


    Get the connection handle of a Device. (EMSHI only)
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import get_conn_handle

    get_conn_handle(engine, address)


**CLI usage**

.. code-block:: bash

    blengine run get_conn_handle [-h] address

*Positional arguments:*

:address:

    Bluetooth Address to connect to, call scan() to get a list


options:
  -h, --help  show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(parser=get_conn_handle_parser)
    def get_conn_handle(engine, address):
        '''
        Get the connection handle of a Device. (EMSHI only)
        '''
        pkt = engine.send("EMSHI_GAP_GetConnectionHandle", Addr=mac(address))
        return pkt.response.get("status") == 0, pkt.response.get("ConnHandle")
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-disconnect:

disconnect_
***********


    Disconnect from a Remote Device. (EMSHI only)
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import disconnect

    disconnect(engine, conn_handle)


**CLI usage**

.. code-block:: bash

    blengine run disconnect [-h] conn_handle

*Positional arguments:*

:conn_handle:

    Connection Handle


options:
  -h, --help   show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(parser=disconnect_parser)
    def disconnect(engine, conn_handle):
        '''
        Disconnect from a Remote Device. (EMSHI only)
        '''
        pkt = engine.send("Disconnect", Connection_Handle=conn_handle, wait_ack = True)
        return True, "Sent Disconnect Packet"
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.set_legacy_advertising_data:

ble.set_legacy_advertising_data_
********************************

 
    Set ONE Advertising Data
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import set_legacy_advertising_data

    set_legacy_advertising_data(engine, data=None, adv_dict=False)


**CLI usage**

.. code-block:: bash

    blengine run BLE.set_legacy_advertising_data [-h] data

*Positional arguments:*

:data:

    Raw data to advertise in hex form


options:
  -h, --help  show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix=prefix, parser=set_legacy_adv_data_parser)
    def set_legacy_advertising_data(engine, data=None, adv_dict=False):
        ''' 
        Set ONE Advertising Data
        '''
        if "Legacy_Advertising_Data" not in engine.device_infos:
            engine.device_infos.update({ "Legacy_Advertising_Data": {} })
    
        if data is None:
            adv_dict = adv_dict or engine.device_infos["Legacy_Advertising_Data"]
            data = make_advertising_data(adv_dict)
        else:
            data = bytearray.fromhex(data)
    
        rsp = engine.send("LE_Set_Advertising_Data",
                        Advertising_Data_Length=len(data),
                        Advertising_Data=padortrim(31, data))
    
        #assert rsp.response.get("status") == 0, "Cannot set name, Error: %s" % rsp.status_text
        if rsp.response.get("status") != 0:
            return False, "name not set, error: %s" % rsp.status_text
        
        return True, "Advertising Data set to %s" % data.hex()
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.set_scan_response_data:

ble.set_scan_response_data_
***************************

 
    Set LE Bluetooth Device Name.
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import set_scan_response_data

    set_scan_response_data(engine, name, value)


**CLI usage**

.. code-block:: bash

    blengine run BLE.set_scan_response_data [-h] name value

*Positional arguments:*

:name:

    Data Type Name

:value:

    Value


options:
  -h, --help  show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix=prefix, parser=set_scan_response_parser)
    def set_scan_response_data(engine, name, value):
        ''' 
        Set LE Bluetooth Device Name.
        '''
        adv_pkt = engine.make(name, { "data": value })
        
        adv_pkt.encode()
    
        rsp = engine.send("LE_Set_Scan_Response_Data",
                            Scan_Response_Data_Length=len(adv_pkt.bytes_value()),
                            Scan_Response_Data=adv_pkt.pad_value(31))
    
        #assert rsp.response.get("status") == 0, "Cannot set name, Error: %s" % rsp.status_text
        if rsp.response.get("status") != 0:
            return False, "name not set, error: %s" % rsp.status_text
        return rsp.response.get("status") == 0, "name set to %s" % name
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.set_name:

ble.set_name_
*************

 
    Set LE Bluetooth Device Name.
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import set_name

    set_name(engine, name, shortname=None)


**CLI usage**

.. code-block:: bash

    blengine run BLE.set_name [-h] [--shortname SHORTNAME] name

*Positional arguments:*

:name:

    Device Name


options:
  -h, --help            show this help message and exit
  --shortname SHORTNAME
                        Device Short Name


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix=prefix, parser=set_name_parser)
    def set_name(engine, name, shortname=None):
        ''' 
        Set LE Bluetooth Device Name.
        '''
    
        adv = {
            "GAP_AD_Complete_Local_Name": name,
        }
    
        if shortname is not None:
            adv.update({ "GAP_AD_Short_Local_Name": shortname })
    
        return True, "name set to %s" % name
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.set_role:

ble.set_role_
*************


    Set LE Bluetooth Device Role.
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import set_role

    set_role(engine, role)


**CLI usage**

.. code-block:: bash

    blengine run BLE.set_role [-h] role

*Positional arguments:*

:role:

    Can be any combination, separated by commas, of the following
              values:
              PeripheralOnly,CentralOnly,PeripheralPreferred,CentralPreferred


options:
  -h, --help  show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="BLE.", parser=set_role_parser)
    def set_role(engine, role):
        '''
        Set LE Bluetooth Device Role.
        '''
    
        pkt = None
    
        pkt = engine.send("Read_BD_ADDR", timeout = 0.2)
    
        bd_addr = pkt.response.get("BD_ADDR")
    
        if "PeripheralOnly" in role:
            pkt = engine.send("LE_Set_Advertising_Parameters", Peer_Address=bd_addr)
            pkt = engine.send("LE_Set_Advertising_Enable", Advertising_Enable=0x01)
    
        if "CentralOnly" in role:
            pkt = engine.send("LE_Set_Advertising_Enable", Advertising_Enable=0x00)
    
        return True, pkt
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.set_mode:

ble.set_mode_
*************

 
    Set LE Bluetooth Device Mode.
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import set_mode

    set_mode(engine, modes)


**CLI usage**

.. code-block:: bash

    blengine run BLE.set_manufacturer_data [-h] modes

*Positional arguments:*

:modes:

    can be any combination, separated by commas, of the following
              values: LimitedDiscoverable,GeneralDiscoverable,BrEdrNotSupporte
              d,LEandBrEdrSupported (Controller),LEandBrEdrSupported (Host)


options:
  -h, --help  show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="BLE.", parser=set_mode_parser)
    def set_mode(engine, modes):
        ''' 
        Set LE Bluetooth Device Mode.
        '''
        mode = 0x00
        if isinstance(modes, str):
            modes = modes.split(',')
    
        if isinstance(modes, list):
            for m in modes:
                mode += LE_ADV_FLAGS.get(m.strip(), 0)
        else:
            mode = modes
    
        engine.advertise({
                        "GAP_AD_Flags": mode,
                         })
    
        return True, mode
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.set_manufacturer_data:

ble.set_manufacturer_data_
**************************


    Set manufacturer specific data
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import set_manufacturer_data

    set_manufacturer_data(engine, data)


**CLI usage**

.. code-block:: bash

    blengine run BLE.set_manufacturer_data [-h] modes

*Positional arguments:*

:modes:

    can be any combination, separated by commas, of the following
              values: LimitedDiscoverable,GeneralDiscoverable,BrEdrNotSupporte
              d,LEandBrEdrSupported (Controller),LEandBrEdrSupported (Host)


options:
  -h, --help  show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="BLE.", parser=set_mode_parser)
    def set_manufacturer_data(engine, data):
        """
        Set manufacturer specific data
        """
        pkt = engine.send("EMSHI_GAP_SetManufacturerSpecificData", Len=len(data), Value=data)
        #assert pkt.response.get("status") == 0, "Cannot set manufacturer specific data, error: %s" % pkt.status_text
        return pkt.response.get("status") == 0
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.connect:

ble.connect_
************

 
    Connect to a Remote Device. (LE)

    return (status, connection_handle)
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import connect

    connect(engine, address, address_type=0, filter_policy=0, scan_interval_ms=30, scan_window_ms=30, conn_interval_min_ms=30, conn_interval_max_ms=30, max_latency=0, min_ce_length=0, max_ce_length=0, conn_timeout_ms=5000, retry=1)


**CLI usage**

.. code-block:: bash

    blengine run BLE.connect [-h] [--address_type ADDRESS_TYPE]
                        [--scan_interval_ms SCAN_INTERVAL_MS]
                        [--scan_window_ms SCAN_WINDOW_MS]
                        [--conn_interval_min_ms CONN_INTERVAL_MIN_MS]
                        [--conn_interval_max_ms CONN_INTERVAL_MAX_MS]
                        [--max_latency MAX_LATENCY]
                        [--conn_timeout_ms CONN_TIMEOUT_MS]
                        [--min_ce_length MIN_CE_LENGTH]
                        [--max_ce_length MAX_CE_LENGTH]
                        address

*Positional arguments:*

:address:

    Bluetooth Address to connect to, call scan() to get a
                        list


options:
  -h, --help            show this help message and exit
  --address_type ADDRESS_TYPE
                        Bluetooth Address Type
  --scan_interval_ms SCAN_INTERVAL_MS
                        Scan Interval in milliseconds
  --scan_window_ms SCAN_WINDOW_MS
                        Scan Window in milliseconds
  --conn_interval_min_ms CONN_INTERVAL_MIN_MS
                        Scan Interval in milliseconds
  --conn_interval_max_ms CONN_INTERVAL_MAX_MS
                        Scan Window in milliseconds
  --max_latency MAX_LATENCY
                        Maximum Peripheral Latency
  --conn_timeout_ms CONN_TIMEOUT_MS
                        Supervision timeout for LE Link in ms
  --min_ce_length MIN_CE_LENGTH
                        Minimum length of connection event
  --max_ce_length MAX_CE_LENGTH
                        Maximum length of connection event


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="BLE.", parser=connect_parser)
    def connect(engine, address, 
                address_type=0x00,
                filter_policy=0x00,
                scan_interval_ms=30,
                scan_window_ms=30,
                conn_interval_min_ms=30,
                conn_interval_max_ms=30,
                max_latency=0x0000,
                min_ce_length = 0x0000,
                max_ce_length = 0x0000,
                conn_timeout_ms=5000,
                retry=1):
        ''' 
        Connect to a Remote Device. (LE)
    
        return (status, connection_handle)
        '''
    
    
        pkt = engine.send(  "LE_Create_Connection",
                            Peer_Address=address, 
                            Peer_Address_Type=address_type,
                            Own_Address_Type=0x00,
                            LE_Scan_Interval=int(scan_interval_ms * 1.6),  # ratio 1/0.625 ms
                            LE_Scan_Window=int(scan_window_ms * 1.6),  # ratio 1/0.625 ms
                            Initiator_Filter_Policy=filter_policy,
                            Connection_Interval_Min=int(conn_interval_min_ms * 0.8), # ratio 1/1.25 ms
                            Connection_Interval_Max=int(conn_interval_max_ms * 0.8),# ratio 1/1.25 ms
                            Supervision_Timeout=int(conn_timeout_ms / 10),  # 10ms
                            Max_Latency=max_latency,
                            Min_CE_Length=min_ce_length,
                            Max_CE_Length=max_ce_length,
                            wait_ack = True,
                            retry = retry,
                            timeout = 5)
    
        if "Connection_Complete" in pkt.response.name:
    
            if pkt.response.get("status") == 0x00:
                return True,  pkt.response
    
            if pkt.response.get("status") == 0x0b:
                return True, pkt.response
    
        if pkt.response.get("status") == 0x0c:
            pkt = engine.send("LE_Create_Connection_Cancel")
            return False, "Command Disallowed"
    
    
        return False, pkt.status_text or "Command Status Timeout"
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.connect_ext:

ble.connect_ext_
****************

 
    Extended Connection to a Remote Device. (LE)

    return (status, connection_handle)
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import connect_ext

    connect_ext(engine, address, address_type=0, initiating_phys=1, filter_policy=0, scan_interval_ms=30, scan_window_ms=30, conn_interval_min_ms=20, conn_interval_max_ms=50, max_latency=0, min_ce_length=0, max_ce_length=6400, conn_timeout_ms=3000, retry=3)


**CLI usage**

.. code-block:: bash

    blengine run BLE.connect_ext [-h] [--address_type ADDRESS_TYPE]
                            [--initiating_phys INITIATING_PHYS]
                            [--scan_interval_ms SCAN_INTERVAL_MS]
                            [--scan_window_ms SCAN_WINDOW_MS]
                            [--conn_interval_min_ms CONN_INTERVAL_MIN_MS]
                            [--conn_interval_max_ms CONN_INTERVAL_MAX_MS]
                            [--max_latency MAX_LATENCY]
                            [--conn_timeout_ms CONN_TIMEOUT_MS]
                            [--min_ce_length MIN_CE_LENGTH]
                            [--max_ce_length MAX_CE_LENGTH]
                            address

*Positional arguments:*

:address:

    Bluetooth Address to connect to, call scan() to get a
                        list


options:
  -h, --help            show this help message and exit
  --address_type ADDRESS_TYPE
                        Bluetooth Address Type
  --initiating_phys INITIATING_PHYS
                        Initiating PHYs
  --scan_interval_ms SCAN_INTERVAL_MS
                        Scan Interval in milliseconds
  --scan_window_ms SCAN_WINDOW_MS
                        Scan Window in milliseconds
  --conn_interval_min_ms CONN_INTERVAL_MIN_MS
                        Scan Interval in milliseconds
  --conn_interval_max_ms CONN_INTERVAL_MAX_MS
                        Scan Window in milliseconds
  --max_latency MAX_LATENCY
                        Maximum Peripheral Latency
  --conn_timeout_ms CONN_TIMEOUT_MS
                        Supervision timeout for LE Link in ms
  --min_ce_length MIN_CE_LENGTH
                        Minimum length of connection event
  --max_ce_length MAX_CE_LENGTH
                        Maximum length of connection event


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="BLE.", parser=connect_ext_parser)
    def connect_ext(engine, address, 
                address_type=0x00,
                initiating_phys=0x01,
                filter_policy=0x00,
                scan_interval_ms=30,
                scan_window_ms=30,
                conn_interval_min_ms=20,
                conn_interval_max_ms=50,
                max_latency=0x0000,
                min_ce_length = 0,
                max_ce_length = 6400,
                conn_timeout_ms=3000,
                retry=3):
        ''' 
        Extended Connection to a Remote Device. (LE)
    
        return (status, connection_handle)
        '''
    
        pkt = engine.send(  "LE_Extended_Create_Connection",
                            Peer_Address=mac(address).to_bytes(), 
                            Peer_Address_Type=address_type,
                            Own_Address_Type=0x00,
                            Initiating_PHYs=initiating_phys,
                            Scan_Interval=int(scan_interval_ms * 1.6),
                            Scan_Window=int(scan_window_ms * 1.6),
                            Initiator_Filter_Policy=filter_policy,
                            Connection_Interval_Min=int(conn_interval_min_ms * 0.8),
                            Connection_Interval_Max=int(conn_interval_max_ms * 0.8),
                            Supervision_Timeout=int(conn_timeout_ms / 10),
                            Max_Latency=max_latency,
                            Min_CE_Length=min_ce_length,
                            Max_CE_Length=max_ce_length,
                            wait_ack = True,
                            retry = 3,
                            timeout = 5)
    
        if "Enhanced_Connection_Complete" in pkt.response.name:
            if pkt.response.get("status") == 0x00:
                return True, "Connected"
        else:
            if pkt.response.get("status") == 0x0b:
                # we are already connected
                return True, "Already Connected"
    
        if pkt.response.get("status") == 0x0c:
            pkt = engine.send("LE_Create_Connection_Cancel")
            return False, "Command Disallowed"
    
        return False, pkt.status_text or "Command Status Timeout"
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.scan:

ble.scan_
*********


    Scan for devices and return a advertising packets list.

    Two callbacks can be provided for the advertising packets and for the scan
    response.



    :param      engine:            The engine
    :param      mode:              The mode
    :param      duration_ms:       The duration milliseconds
    :param      scan_interval_ms:  The scan interval milliseconds
    :param      scan_window_ms:    The scan window milliseconds
    :param      address_filter:    The address filter
    :param      name_filter:       The name filter
    :param      uuid_filter:       The uuid filter
    :param      nearest:           The nearest filter
    :param      retry:             The retry
    :param      on_advertising:    On advertising Callback
    :param      on_scan_response:  On scan response Callback

    :returns:   status and advertising packets
    :rtype:     tuple(str, list)
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import scan

    scan(engine, legacy=False, duration_ms=1000, scan_interval_ms=250, scan_window_ms=250, scanning_filter_policy=0, scanning_phys=1, scan_type=1, filter_duplicates=1, address_filter=None, name_filter=None, uuid_filter=None, retry=0, on_advertising=None, on_scan_response=None)


**CLI usage**

.. code-block:: bash

    blengine run BLE.scan [-h] [--legacy LEGACY] [--duration_ms DURATION_MS]
                     [--scan_interval_ms SCAN_INTERVAL_MS]
                     [--scan_window_ms SCAN_WINDOW_MS]
                     [--scanning_filter_policy SCANNING_FILTER_POLICY]
                     [--scanning_phys SCANNING_PHYS] [--scan_type SCAN_TYPE]
                     [--filter_duplicates FILTER_DUPLICATES]
                     [--address_filter ADDRESS_FILTER]
                     [--name_filter NAME_FILTER] [--uuid_filter UUID_FILTER]


options:
  -h, --help            show this help message and exit
  --legacy LEGACY       Extended scan by default, specify legacy for LE Scan
  --duration_ms DURATION_MS
                        Duration of the scan in milliseconds
  --scan_interval_ms SCAN_INTERVAL_MS
                        Scan interval in milliseconds
  --scan_window_ms SCAN_WINDOW_MS
                        Advertisement Window in milliseconds
  --scanning_filter_policy SCANNING_FILTER_POLICY
                        Filter Devices based on this MAC Address
  --scanning_phys SCANNING_PHYS
                        PhYs (ext only)
  --scan_type SCAN_TYPE
                        s
  --filter_duplicates FILTER_DUPLICATES
                        Filter Duplicates
  --address_filter ADDRESS_FILTER
                        Filter Devices based on this MAC Address
  --name_filter NAME_FILTER
                        Filter Devices which name contain this string
  --uuid_filter UUID_FILTER
                        Filter the devices that advertise the specific uuid


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="BLE.", parser=scan_parser)
    def scan(engine,
             legacy=False,
             duration_ms=1000,
             scan_interval_ms=250,
             scan_window_ms=250,
             scanning_filter_policy = 0x00,
             scanning_phys = 0x01, 
             scan_type = 0x01,
             filter_duplicates = 0x01,
             address_filter=None,
             name_filter=None,
             uuid_filter=None,
             retry=0,
             on_advertising=None,
             on_scan_response=None):
        """
        Scan for devices and return a advertising packets list.
    
        Two callbacks can be provided for the advertising packets and for the scan
        response.
    
    
    
        :param      engine:            The engine
        :param      mode:              The mode
        :param      duration_ms:       The duration milliseconds
        :param      scan_interval_ms:  The scan interval milliseconds
        :param      scan_window_ms:    The scan window milliseconds
        :param      address_filter:    The address filter
        :param      name_filter:       The name filter
        :param      uuid_filter:       The uuid filter
        :param      nearest:           The nearest filter
        :param      retry:             The retry
        :param      on_advertising:    On advertising Callback
        :param      on_scan_response:  On scan response Callback
    
        :returns:   status and advertising packets
        :rtype:     tuple(str, list)
        """
    
        if uuid_filter:
            uuid_filter = UUID(uuid_filter)
    
        results = []
    
        added_parsing_time_ms = 100
    
        scan_complete = threading.Event()
    
        last_rx_time = time.perf_counter()
    
    
        def process_adv_packet(pkt):
            # if it does not pass the address filter, discard it right away
            #if address_filter and pkt.get("Address") != address_filter:
            #   return False
    
            if legacy:
                data = gap_ad_storage.decode_adv_data(pkt.get("Advertising_Data")[:-1])
            else:
                data = gap_ad_storage.decode_adv_data(pkt.get("Data"))
            
            # add the Decoded advertising Data to the Packet.
            pkt.frag("AdvData").extend(data)
    
            return True
    
        def on_advertising_packet(pkt):
            '''
            Callback method executed when a advertisement event is received
            '''
            nonlocal last_rx_time
            nonlocal results
    
            pkt.is_scan_response = False
    
    
            if process_adv_packet(pkt):
                if callable(on_advertising):
                    if on_advertising(pkt) is False:
                        scan_complete.set()
                results.append(pkt)
    
            last_rx_time = time.perf_counter()
    
        scan_interval = int(scan_interval_ms * 1.6)
        scan_window = int(scan_window_ms * 1.6)
    
        engine.bind("on_LE_Advertising_Report", on_advertising_packet)
        engine.bind("on_LE_Extended_Advertising_Report", on_advertising_packet)
    
        #engine.bind("on_rx", on_rx)
    
        timeout = 1 + (duration_ms/1000)
    
        #print(engine.send("LE_Set_Event_Mask", LE_Event_Mask=0xffffffffffffffff))
        #print(engine.send("Set_Event_Mask_Page_2", LE_Event_Mask=0xffffffffffffffff))
        if legacy:
            param_pkt = engine.send("LE_Set_Scan_Parameters",
                                        LE_Scan_Type     = scan_type,
                                        Own_Address_Type = 0x00,
                                        LE_Scan_Interval = scan_interval,
                                        LE_Scan_Window = scan_window,
                                        Scanning_Filter_Policy = scanning_filter_policy)
    
            scan_pkt = engine.send("LE_Set_Scan_Enable", 
                                        LE_Scan_Enable    = 0x01,
                                        Filter_Duplicates = filter_duplicates)
    
        else:
            param_pkt = engine.send("LE_Set_Extended_Scan_Parameters",
                            Own_Address_Type       = 0x00,
                            Scanning_Filter_Policy = scanning_filter_policy,
                            Scanning_PHYs          = scanning_phys,
                            Scan_Type              = scan_type, 
                            Scan_Interval          = scan_interval,
                            Scan_Window            = scan_window)
    
            if param_pkt.response.get("status") == 0x0c:
                scan_pkt = engine.send("LE_Set_Extended_Scan_Enable",
                            Enable                = 0x00,
                            Filter_Duplicates     = filter_duplicates,
                            Duration              = 0,
                            Period                = 0x0000)
    
                param_pkt = engine.send_pkt(param_pkt)
    
    
            scan_pkt = engine.send("LE_Set_Extended_Scan_Enable",
                            Enable                = 0x01,
                            Filter_Duplicates     = filter_duplicates,
                            Duration              = 0,
                            Period                = 0x0000)
    
    
        if scan_pkt.response.get("status") == 0:
            # wait for the scan to be complete (device side)
            scan_complete.wait(timeout=timeout)
    
            #logger.get("scan").info(inquiry_pkt)
    
            # wait for processing time before unbinding events, there can be many events 
            # and we have to wait on the parser.
            # we wait max 500ms but while True is bad ! consider refactoring
            while True:
                if (time.perf_counter() - last_rx_time) * 1000 > added_parsing_time_ms:
                    break
    
                time.sleep(0.05)
    
        if legacy:
            scan_pkt = engine.send("LE_Set_Scan_Enable", LE_Scan_Enable=0x00)
        else:
            scan_pkt = engine.send("LE_Set_Extended_Scan_Enable",
                                Enable=0x00,
                                Filter_Duplicates=0x01,
                                Duration=0,
                                Period = 0x0000)
    
        engine.unbind("on_LE_Advertising_Report", on_advertising_packet)
        engine.unbind("on_LE_Extended_Advertising_Report", on_advertising_packet)
    
        return scan_pkt.response.get("status") == 0, results
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.update_phy:

ble.update_phy_
***************


    
    Set the PHY mapping
    
    :param      engine:       The engine
    :param      conn_handle:  The connection handle
    :param      rx:           The receive speed
    :param      tx:           The transmit speed
    :param      options:      The options
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import update_phy

    update_phy(engine, conn_handle, rx_phy, tx_phy, coded_option=0, all_phy=0)


**CLI usage**

.. code-block:: bash

    blengine run BLE.update_phy [-h] [--coded_option CODED_OPTION]
                           [--preferred_phy PREFERRED_PHY]
                           conn_handle rx_phy tx_phy

*Positional arguments:*

:conn_handle:

    Conenction Handle

:rx_phy:

    RX PHY : 1M, 2M or Coded

:tx_phy:

    TX PHY : 1M, 2M or Coded


options:
  -h, --help            show this help message and exit
  --coded_option CODED_OPTION
                        Coded options : None, S=2, S=8
  --preferred_phy PREFERRED_PHY
                        Preferred PHY : None, TX, RX, Both


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="BLE.", parser=set_phy_parser)
    def update_phy(engine, conn_handle, rx_phy, tx_phy, coded_option=0, all_phy=0):
        """
        
        Set the PHY mapping
        
        :param      engine:       The engine
        :param      conn_handle:  The connection handle
        :param      rx:           The receive speed
        :param      tx:           The transmit speed
        :param      options:      The options
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        """
        phy_mapping = { "1M": 1, "2M": 2, "Coded": 4 }
        coded_options_mapping = { "None": 0, "S=2": 1, "S=8": 2 }
        all_phys_mapping = { "None": 0, "TX": 1, "RX": 2, "Both": 3 }
        
        if isinstance(rx_phy, str):
            if rx_phy not in phy_mapping:
                return False, "RX must be either %s. was %s" % (" ".join(phy_mapping.keys()), rx_phy)
            rx_phy = phy_mapping[rx_phy]
    
        if isinstance(tx_phy, str):
            if tx_phy not in phy_mapping:
                return False, "TX must be either %s. was %s" % (" ".join(phy_mapping.keys()), tx_phy)
            tx_phy = phy_mapping[tx_phy]
    
        if isinstance(coded_option, str):
            if coded_option not in coded_options_mapping:
                return False, "Coded Option must be %s. was %s" % (" ".join(coded_options_mapping.keys()), coded_option)
            coded_option = coded_options_mapping[coded_option]
    
        if isinstance(all_phy, str):
            if all_phy not in all_phys_mapping:
                return False, "Preferred PHY must be %s. was %s" % (" ".join(all_phys_mapping.keys()), all_phy)
            all_phy = all_phys_mapping[all_phy]
    
        pkt = engine.send("LE_Set_PHY", Connection_Handle=conn_handle, All_PHYs=all_phy, TX_PHYs=tx_phy, RX_PHYs=rx_phy, PHY_Options=coded_option)
    
        msg = "Set PHY sent"
    
        if pkt.response.get("status") != 0:
            msg = pkt.status_text
    
        return pkt.response.get("status") == 0, msg
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.set_private_address:

ble.set_private_address_
************************


    Set the random private address for Advertising, Scanning or Initiating connection with privacy
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import set_private_address

    set_private_address(engine, resolvable, advertising_handle=1, local_irk=bytearray(b'Hee-Haw!BR-549JS'), rnd=bytearray(b'\xea^o\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'))


**CLI usage**

.. code-block:: bash

    blengine run BLE.set_private_address [-h]
                                    [--advertising_handle ADVERTISING_HANDLE]
                                    [--local_irk LOCAL_IRK] [--rnd RND]
                                    resolvable

*Positional arguments:*

:resolvable:

    Set to True if the private address to be set is RPA,
                        set to False if it is NRPA


options:
  -h, --help            show this help message and exit
  --advertising_handle ADVERTISING_HANDLE
                        Advertising Handle when settind random address for an
                        advertiser
  --local_irk LOCAL_IRK
                        Local IRK
  --rnd RND             Random number for the encrypt function to generate RPA


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="BLE.", parser=set_private_address_parser)
    def set_private_address(engine,
                            resolvable,
                            advertising_handle=0x0001, 
                            local_irk=bytearray([0x48, 0x65, 0x65, 0x2d, 0x48, 0x61, 0x77, 0x21, 0x42, 0x52, 0x2d, 0x35, 0x34, 0x39, 0x4a, 0x53]),
                            rnd=bytearray([0xea, 0x5e, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]), 
                            ):
        """
        Set the random private address for Advertising, Scanning or Initiating connection with privacy
        """
    
        if resolvable:
    
            # If the address to be set is Resolvable Private Address (RPA)
            # RPA generated as specified in Core Spec Vol 6, Part B, section 1.3.2.2
    
            #r = self.send("LE_Rand")
    
            pkt = engine.send("LE_Encrypt", Key=local_irk, Plaintext_Data=rnd) # e(IRK, prand')
    
            data = pkt.response.get("Encrypted_Data") # hash
    
            private_address = mac((rnd[0:3][::-1] + data[0:3][::-1]), 1) # prand || hash
    
            print("Setting RPA random address: %s" % private_address)
    
        elif resolvable is False:
    
            # If the address to be set is Non Resolvable Private Address (NRPA)
            private_address = mac("00:00:00:01:02:03", 1)  # NRPA Address (starts with 0b00 = 0x0,1,2,3)
            print("Setting NRPA random address: %s", private_address)
    
        legacy = "LE Extended Advertising" not in engine.device_infos.get("LE_Supported_Features", [])
    
        engine.send("LE_Set_Random_Address", Random_Address=private_address)
            
        if legacy is False:
            engine.send("LE_Set_Advertising_Set_Random_Address", Advertising_Handle=advertising_handle, Advertising_Random_Address=private_address) # If Extended Advertising is supported, this command shall be used to set the random address for Advertising
    
        return private_address
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.clear_filter_accept_list:

ble.clear_filter_accept_list_
*****************************


    Clear the Filter Accept List stored in the controller
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import clear_filter_accept_list

    clear_filter_accept_list(engine)


**CLI usage**

.. code-block:: bash

    No Help

.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="BLE.")
    def clear_filter_accept_list(engine):
        '''
        Clear the Filter Accept List stored in the controller
        '''
        pkt = engine.send("LE_Clear_Filter_Accept_List")
    
        msg = "Sent Clear Filter Accept List"
    
        if pkt.response.get("status") > 0:
            msg = pkt.status_text
    
        return pkt.response.get("status") == 0, msg
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.read_filter_accept_list_size:

ble.read_filter_accept_list_size_
*********************************


    Read the Filter Accept List size
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import read_filter_accept_list_size

    read_filter_accept_list_size(engine)


**CLI usage**

.. code-block:: bash

    No Help

.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="BLE.")
    def read_filter_accept_list_size(engine):
        '''
        Read the Filter Accept List size
        '''
        pkt = engine.send("LE_Read_Filter_Accept_List_Size")
        size = pkt.response.get("Filter_Accept_List_Size")
    
        msg = "Sent Read Filter Accept List Size. Size is %s " % size
    
        if pkt.response.get("status") > 0:
            msg = pkt.status_text
    
        return pkt.response.get("status") == 0, msg, size
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.add_device_filter_accept_list:

ble.add_device_filter_accept_list_
**********************************


    Add a peer device to the Filter Accept List of the controller
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import add_device_filter_accept_list

    add_device_filter_accept_list(engine, address, address_type=0)


**CLI usage**

.. code-block:: bash

    blengine run BLE.add_device_filter_accept_list [-h]
                                              [--address_type ADDRESS_TYPE]
                                              address

*Positional arguments:*

:address:

    Bluetooth Address of the device to be added to the
                        Filter Accept List


options:
  -h, --help            show this help message and exit
  --address_type ADDRESS_TYPE
                        Bluetooth Address Type


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="BLE.", parser=add_device_filter_accept_list_parser)
    def add_device_filter_accept_list(engine, address, address_type=0x00):
        '''
        Add a peer device to the Filter Accept List of the controller
        '''
        pkt = engine.send("LE_Add_Device_To_Filter_Accept_List", 
                          Address_Type = address_type,
                          Address = address)
    
        msg = "Device with address %s added to Filter Accept List" % address
    
        if pkt.response.get("status") > 0:
            msg = pkt.status_text
    
        return pkt.response.get("status") == 0, msg
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.clear_resolving_list:

ble.clear_resolving_list_
*************************


    Clear the Resolving List stored in the controller
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import clear_resolving_list

    clear_resolving_list(engine)


**CLI usage**

.. code-block:: bash

    No Help

.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="BLE.")
    def clear_resolving_list(engine):
        '''
        Clear the Resolving List stored in the controller
        '''
        pkt = engine.send("LE_Clear_Resolving_List")
    
        msg = "Sent Clear Resolving List"
    
        if pkt.response.get("status") > 0:
            msg = pkt.status_text
    
        return pkt.response.get("status") == 0, msg
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.read_resolving_list_size:

ble.read_resolving_list_size_
*****************************


    Read the Resolving List size
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import read_Resolving_list_size

    read_Resolving_list_size(engine)


**CLI usage**

.. code-block:: bash

    No Help

.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="BLE.")
    def read_Resolving_list_size(engine):
        '''
        Read the Resolving List size
        '''
        pkt = engine.send("LE_Read_Resolving_List_Size")
        size = pkt.response.get("Resolving_List_Size")
    
        msg = "Sent Read FResolving List Size. Size is %s " % size
    
        if pkt.response.get("status") > 0:
            msg = pkt.status_text
    
        return pkt.response.get("status") == 0, msg, size
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.add_device_resolving_list:

ble.add_device_resolving_list_
******************************


    Add one device to the resolving list used to generate and resolve RPAs in the controller
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import add_device_resolving_list

    add_device_resolving_list(engine, peer_identity_address, peer_irk, local_irk, peer_identity_address_type=0)


**CLI usage**

.. code-block:: bash

    blengine run BLE.add_device_resolving_list [-h]
                                          [--peer_identity_address_type PEER_IDENTITY_ADDRESS_TYPE]
                                          peer_identity_address peer_irk
                                          local_irk

*Positional arguments:*

:peer_identity_address:

    Public or Random (static) Identity Address of the peer
                        device to be added to the Resolving List

:peer_irk:

    IRK of the peer device

:local_irk:

    IRK of the local device


options:
  -h, --help            show this help message and exit
  --peer_identity_address_type PEER_IDENTITY_ADDRESS_TYPE
                        Bluetooth Address Type of the peer device to be added.
                        0x00 for Public Identity Address or 0x01 for Random
                        (static) Identity Address


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="BLE.", parser=add_device_resolving_list_parser)
    def add_device_resolving_list(engine, peer_identity_address, peer_irk, local_irk, peer_identity_address_type=0x00):
        '''
        Add one device to the resolving list used to generate and resolve RPAs in the controller
        '''
        pkt = engine.send("LE_Add_Device_To_Resolving_List", 
                        Peer_Identity_Address_Type=peer_identity_address_type,
                        Peer_Identity_Address=peer_identity_address,
                        Peer_IRK=peer_irk,
                        Local_IRK=local_irk)
    
        msg = "Device with identity address %s added to Resolving List" % peer_identity_address
    
        if pkt.response.get("status") > 0:
            msg = pkt.status_text
    
        return pkt.response.get("status") == 0, msg
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.set_advertising_parameters:

ble.set_advertising_parameters_
*******************************


    Sets the advertising parameters in the device_infos engine dictionary.

    Extended and Legacy advertisings are covered by this method
    
    :param      Interval_Min:                      The interval minimum
    :param      Interval_Max:                      The interval maximum
    :param      Type:                              The type
    :param      Own_Address_Type:                  The own address type
    :param      Peer_Address_Type:                 The peer address type
    :param      Peer_Address:                      The peer address
    :param      Channel_Map:                       The channel map
    :param      Filter_Policy:                     The filter policy
    :param      Handle:                            The handle
    :param      Event_Properties:                  The event properties
    :param      TX_Power:                          The tx power
    :param      Primary_PHY:                       The primary phy
    :param      Secondary_Max_Skip:                The secondary maximum skip
    :param      Secondary_PHY:                     The secondary phy
    :param      SID:                               The new value
    :param      Scan_Request_Notification_Enable:  The scan request notification enable
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import set_advertising_parameters

    set_advertising_parameters(engine, handle=0, legacy=None, apply=False, v2=False, dico=None, **args)


**CLI usage**

.. code-block:: bash

    blengine run BLE.set_advertising_parameters [-h] [--Interval_Min INTERVAL_MIN]
                                           [--Interval_Max INTERVAL_MAX]
                                           [--Properties PROPERTIES]
                                           [--Type TYPE]
                                           [--Own_Address_Type OWN_ADDRESS_TYPE]
                                           [--Peer_Address_Type PEER_ADDRESS_TYPE]
                                           [--Peer_Address PEER_ADDRESS]
                                           [--Channel_Map CHANNEL_MAP]
                                           [--Filter_Policy FILTER_POLICY]
                                           [--TX_Power TX_POWER]
                                           [--Primary_PHY PRIMARY_PHY]
                                           [--Secondary_Max_Skip SECONDARY_MAX_SKIP]
                                           [--Secondary_PHY SECONDARY_PHY]
                                           [--SID SID]
                                           [--Scan_Request_Notification_Enable SCAN_REQUEST_NOTIFICATION_ENABLE]
                                           [--legacy] [--apply] [--v2]
                                           handle

*Positional arguments:*

:handle:

    Connection Handle


options:
  -h, --help            show this help message and exit
  --Interval_Min INTERVAL_MIN
                        Primary Adv Interval Min
  --Interval_Max INTERVAL_MAX
                        Primary Adv Interval Max
  --Properties PROPERTIES
                        Advertising Event Properties
  --Type TYPE           Legacy Advertising Type
  --Own_Address_Type OWN_ADDRESS_TYPE
                        Own Address Type
  --Peer_Address_Type PEER_ADDRESS_TYPE
                        Peer Address type
  --Peer_Address PEER_ADDRESS
                        Peer MAC Address
  --Channel_Map CHANNEL_MAP
                        Primary Channel Map
  --Filter_Policy FILTER_POLICY
                        Advertising Filter Policy
  --TX_Power TX_POWER   TX Power
  --Primary_PHY PRIMARY_PHY
                        Primary Advertising PHY
  --Secondary_Max_Skip SECONDARY_MAX_SKIP
                        Secondary Advertising Max Skip
  --Secondary_PHY SECONDARY_PHY
                        Secondary Advertising PHY
  --SID SID             Advertising SID
  --Scan_Request_Notification_Enable SCAN_REQUEST_NOTIFICATION_ENABLE
                        Scan requets Notif enable
  --legacy              Force legacy (non extended) advertising
  --apply               Apply advertising parameters (default True)
  --v2                  Use V2 packet


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="BLE.", parser=set_adv_params_parser)
    def set_advertising_parameters(engine,
            handle=0x00,
            legacy=None,
            apply=False,
            v2=False,
            dico = None,
            **args
        ):
        """
        Sets the advertising parameters in the device_infos engine dictionary.
    
        Extended and Legacy advertisings are covered by this method
        
        :param      Interval_Min:                      The interval minimum
        :param      Interval_Max:                      The interval maximum
        :param      Type:                              The type
        :param      Own_Address_Type:                  The own address type
        :param      Peer_Address_Type:                 The peer address type
        :param      Peer_Address:                      The peer address
        :param      Channel_Map:                       The channel map
        :param      Filter_Policy:                     The filter policy
        :param      Handle:                            The handle
        :param      Event_Properties:                  The event properties
        :param      TX_Power:                          The tx power
        :param      Primary_PHY:                       The primary phy
        :param      Secondary_Max_Skip:                The secondary maximum skip
        :param      Secondary_PHY:                     The secondary phy
        :param      SID:                               The new value
        :param      Scan_Request_Notification_Enable:  The scan request notification enable
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        """
    
        if "Advertising_Parameters" not in engine.device_infos:
            engine.device_infos.update( { "Advertising_Parameters": {} } )
    
        if handle not in engine.device_infos["Advertising_Parameters"]:
            engine.device_infos["Advertising_Parameters"].update( { handle: {} } )
    
        engine.device_infos["Advertising_Parameters"][handle].update(args)
    
        if dico is not None:
            engine.device_infos["Advertising_Parameters"][handle].update(dico)
    
        if apply:
            return apply_advertising_parameters(engine, handle, legacy, v2)
        else:
            return True, "Advertising Parameters Applied"
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-ble.set_periodic_advertising_parameters:

ble.set_periodic_advertising_parameters_
****************************************


    Sets the periodic advertising parameters in the device_infos engine dictionary.
    
    :param      Handle:                             The Advertising Handle
    :param      Interval_Min:                      The periodic interval minimum
    :param      Interval_Max:                      The periodic interval maximum
    :param      Properties:                        The periodic advertising properties

    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.ble import set_periodic_advertising_parameters

    set_periodic_advertising_parameters(engine, Handle=0, Legacy=False, apply=False, **args)


**CLI usage**

.. code-block:: bash

    blengine run BLE.set_periodic_advertising_parameters [-h]
                                                    [--Interval_Min INTERVAL_MIN]
                                                    [--Interval_Max INTERVAL_MAX]
                                                    [--Properties PROPERTIES]
                                                    Handle

*Positional arguments:*

:Handle:

    Advertising Handle


options:
  -h, --help            show this help message and exit
  --Interval_Min INTERVAL_MIN
                        Primary Periodic Adv Interval Min
  --Interval_Max INTERVAL_MAX
                        Primary Periodic Adv Interval Max
  --Properties PROPERTIES
                        Periodic Advertising Event Properties


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="BLE.", parser=set_per_adv_params_parser)
    def set_periodic_advertising_parameters(engine,
            Handle=0x00,
            Legacy=False,
            apply=False,
            **args
        ):
        """
        Sets the periodic advertising parameters in the device_infos engine dictionary.
        
        :param      Handle:                             The Advertising Handle
        :param      Interval_Min:                      The periodic interval minimum
        :param      Interval_Max:                      The periodic interval maximum
        :param      Properties:                        The periodic advertising properties
    
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        """
    
    
        if "Periodic_Advertising_Parameters" not in engine.device_infos:
            engine.device_infos.update( { "Periodic_Advertising_Parameters": {} } )
    
        if Handle not in engine.device_infos["Periodic_Advertising_Parameters"]:
            engine.device_infos["Periodic_Advertising_Parameters"].update( { Handle: {} } )
    
        engine.device_infos["Periodic_Advertising_Parameters"][Handle].update(args)
    
        if apply:
            return apply_per_advertising_parameters(engine, Handle, Legacy)
        else:
            return True, "Periodic Advertising Parameters Applied"
    


.. raw:: html
    
    </details>
    <hr>

this page is auto generated by BLEngine/docs/procedures.py