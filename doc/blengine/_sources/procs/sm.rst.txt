
.. this file is auto generated by BLEngine/docs/procedures.py

=============================
sm Procedures
=============================

.. raw:: html
    
    
    <input class="search input" type="text" placeholder="Live Search" style="width: 100%; padding: 10px;">
    <div>&nbsp</div>
    <div id="search-loader" style="display:none;">please wait...</div>
    
.. _proc-sm.initiate_pairing:

sm.initiate_pairing_
********************


    Initiate pairing (sending Pairing Request) to a peer device
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.sm import initiate_pairing

    initiate_pairing(engine, conn_handle=0, iocap=3, oob=0, bonding=0, mitm=None, sc=0, keypress=0, ini_key_dist_enc=False, ini_key_dist_id=False, ini_key_dist_sign=False, rsp_key_dist_enc=False, rsp_key_dist_id=False, rsp_key_dist_sign=False, oob_data=None)


**CLI usage**

.. code-block:: bash

    blengine run SM.initiate_pairing [-h] [--io_cap IO_CAP] [--oob OOB]
                                [--bonding BONDING] [--mitm MITM] [--sc SC]
                                [--keypress KEYPRESS] [--oob_data OOB_DATA]
                                conn_handle

*Positional arguments:*

:conn_handle:

    Connection Handle


options:
  -h, --help           show this help message and exit
  --io_cap IO_CAP      IO Capability
  --oob OOB            OOB data flag
  --bonding BONDING    Bonding Flags
  --mitm MITM          MITM protection
  --sc SC              LE Secure Connections pairing
  --keypress KEYPRESS  Keypress
  --oob_data OOB_DATA  Peer OOB data


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="SM.", parser=initiate_pairing_parser)
    def initiate_pairing(engine, 
                        conn_handle=0, 
                        iocap=0x03,
                        oob=0x00,
                        bonding=0x00,
                        mitm=None,
                        sc=0x00,
                        keypress=0x00,
                        ini_key_dist_enc=False,
                        ini_key_dist_id=False,
                        ini_key_dist_sign=False,
                        rsp_key_dist_enc=False,
                        rsp_key_dist_id=False,
                        rsp_key_dist_sign=False,
                        oob_data=None,
                        ):
        '''
        Initiate pairing (sending Pairing Request) to a peer device
        '''
        if engine.bluetooth_host_stack == "EMB":
    
            minKeyLen=7
            maxKeyLen=16
    
            # First, let's calculate the value of auth parameter
            if bonding == 0x01:
                SM_AUTH_BOND_FLAG = 0x01
                ini_key_dist_enc = True
                ini_key_dist_id = True
                rsp_key_dist_enc = True
                rsp_key_dist_id = True
                engine.send("EMSHI_DM_SecSetLocalCsrk", Csrk=0x11223344556677881122334455667788)
    
            else:
                SM_AUTH_BOND_FLAG = 0x00
    
            if mitm == 0x01:
                SM_AUTH_MITM_FLAG = 0x04
            else:
                SM_AUTH_MITM_FLAG = 0x00
    
            if sc == 0x01:
                SM_AUTH_SC_FLAG = 0x08
                minKeyLen=16
                engine.send("EMSHI_DM_SecGenerateEccKeyReq")
            else:
                SM_AUTH_SC_FLAG = 0x00
            
            if keypress == 0x01:
                SM_AUTH_KP_FLAG = 0x10
            else:
                SM_AUTH_KP_FLAG = 0x00
    
            auth = SM_AUTH_BOND_FLAG + SM_AUTH_MITM_FLAG + SM_AUTH_SC_FLAG + SM_AUTH_KP_FLAG
    
            # Calculate value of initiator and responder key distribution parameters
    
            if ini_key_dist_enc:
                ini_key_dist_enc = 0x01
            else:
                ini_key_dist_enc = 0x00 
    
            if ini_key_dist_id:
                ini_key_dist_id = 0x02
            else:
                ini_key_dist_id = 0x00
                
            if ini_key_dist_sign:
                ini_key_dist_sign = 0x04
            else:
                ini_key_dist_sign = 0x00
    
            if rsp_key_dist_enc:
                rsp_key_dist_enc = 0x01
            else:
                rsp_key_dist_enc = 0x00 
    
            if rsp_key_dist_id:
                rsp_key_dist_id = 0x02
            else:
                rsp_key_dist_id = 0x00
                
            if rsp_key_dist_sign:
                rsp_key_dist_sign = 0x04
            else:
                rsp_key_dist_sign = 0x00
    
            iKeyDist = ini_key_dist_enc + ini_key_dist_id + ini_key_dist_sign
            rKeyDist = rsp_key_dist_enc + rsp_key_dist_id + rsp_key_dist_sign
    
            def on_OOB_request(pkt):
                engine.send("EMSHI_DM_SecSetOob", connId=conn_handle, Config=oob_data)
                engine.send("EMSHI_DM_SecAuthRsp",
                        connId=conn_handle,
                        authDataLen=16,
                        AuthData=oob_data)
    
            if oob == 0x01:
                engine.bind("on_DM_SEC_AUTH_REQ_IND", on_OOB_request)
    
            # Set Security configuration
            engine.send("EMSHI_DM_PrjSecConfig", auth=auth, iKeyDist=iKeyDist, rKeyDist=rKeyDist, oob=oob, initiateSec=0)  
    
            # Set IO Capabilities
            engine.send("EMSHI_DM_PrjSmpConfig", 
                        attemptTimeout=500,
                        ioCap=iocap,
                        minKeyLen=minKeyLen,
                        maxKeyLen=maxKeyLen,
                        maxAttempts=1,
                        auth=auth,
                        maxAttemptTimeout=64000,
                        attemptDecTimeout=64000,
                        attemptExp=2
                        )
            
            pkt = engine.send("EMSHI_DM_SecPairReq", connId=conn_handle, oob=oob, auth=auth, iKeyDist=iKeyDist, rKeyDist=rKeyDist)    
            status = pkt.response.get("status")
            return status == 0
        else:
            # Alpwise stack
            if oob == 0x01:
                engine.send("EMSHI_SM_SetOobData", OobData=oob_data)
            if mitm is not None:
                engine.send("EMSHI_SM_ForceLocalMITMReq", localMITMUsed=mitm)
            if sc == 0x01:
                # Force LE SC pairing
                engine.send("EMSHI_SM_ForcePairingMode", localPairingMode=2)
    
            engine.send("EMSHI_SM_SetIOCapability", IoCapability=iocap)
    
            pkt = engine.send("EMSHI_SM_InitiatePairing", ConnHandle=conn_handle, Bond=bonding)
            return pkt.response.get("status") == 0
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-sm.accept_pairing:

sm.accept_pairing_
******************


    Set the engine to accept pairing request sent from the remote
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.sm import accept_pairing

    accept_pairing(engine, conn_handle=0, iocap=3, oob=0, bonding=0, mitm=None, sc=0, keypress=0, ini_key_dist_enc=True, ini_key_dist_id=True, ini_key_dist_sign=True, rsp_key_dist_enc=True, rsp_key_dist_id=True, rsp_key_dist_sign=True, oob_data=None)


**CLI usage**

.. code-block:: bash

    blengine run SM.accept_pairing [-h] [--io_cap IO_CAP] [--oob OOB]
                              [--bonding BONDING] [--mitm MITM] [--sc SC]
                              [--conn_handle CONN_HANDLE]


options:
  -h, --help            show this help message and exit
  --io_cap IO_CAP       IO Capability
  --oob OOB             OOB data flag
  --bonding BONDING     Bonding Flags
  --mitm MITM           MITM protection
  --sc SC               LE Secure Connections pairing
  --conn_handle CONN_HANDLE
                        Connection Handle


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="SM.", parser=accept_pairing_parser)
    def accept_pairing(engine,                   
                       conn_handle=0,                 
                       iocap=0x03,
                       oob=0x00,
                       bonding=0x00,
                       mitm=None,
                       sc=0x00,
                       keypress=0x00,
                       ini_key_dist_enc=True,
                       ini_key_dist_id=True,
                       ini_key_dist_sign=True,
                       rsp_key_dist_enc=True,
                       rsp_key_dist_id=True,
                       rsp_key_dist_sign=True,
                       oob_data=None,
                       ):
        '''
        Set the engine to accept pairing request sent from the remote
        '''
        if engine.bluetooth_host_stack == "EMB":
    
            minKeyLen=7
            maxKeyLen=16
    
            # First, let's calculate the value of auth parameter
            if bonding == 0x01:
                SM_AUTH_BOND_FLAG = 0x01
                engine.send("EMSHI_DM_SecSetLocalCsrk", Csrk=0x11223344556677881122334455667788)
            else:
                SM_AUTH_BOND_FLAG = 0x00
    
            if mitm == 0x01:
                SM_AUTH_MITM_FLAG = 0x04
            else:
                SM_AUTH_MITM_FLAG = 0x00
    
            if sc == 0x01:
                SM_AUTH_SC_FLAG = 0x08
                minKeyLen=16
                engine.send("EMSHI_DM_SecGenerateEccKeyReq")
            else:
                SM_AUTH_SC_FLAG = 0x00
            
            if keypress == 0x01:
                SM_AUTH_KP_FLAG = 0x10
            else:
                SM_AUTH_KP_FLAG = 0x00
    
            auth = SM_AUTH_BOND_FLAG + SM_AUTH_MITM_FLAG + SM_AUTH_SC_FLAG + SM_AUTH_KP_FLAG
    
            # Calculate value of initiator and responder key distribution parameters
    
            if ini_key_dist_enc:
                ini_key_dist_enc = 0x01
            else:
                ini_key_dist_enc = 0x00 
    
            if ini_key_dist_id:
                ini_key_dist_id = 0x02
            else:
                ini_key_dist_id = 0x00
                
            if ini_key_dist_sign:
                ini_key_dist_sign = 0x04
            else:
                ini_key_dist_sign = 0x00
    
            if rsp_key_dist_enc:
                rsp_key_dist_enc = 0x01
            else:
                rsp_key_dist_enc = 0x00 
    
            if rsp_key_dist_id:
                rsp_key_dist_id = 0x02
            else:
                rsp_key_dist_id = 0x00
                
            if rsp_key_dist_sign:
                rsp_key_dist_sign = 0x04
            else:
                rsp_key_dist_sign = 0x00
    
            iKeyDist = ini_key_dist_enc + ini_key_dist_id + ini_key_dist_sign
            rKeyDist = rsp_key_dist_enc + rsp_key_dist_id + rsp_key_dist_sign
            
            if oob == 0x01:
                engine.send("EMSHI_DM_SecSetOob", connId=conn_handle, Config=oob_data) ## How to provide oob_data?
           
            # Set Security configuration
            engine.send("EMSHI_DM_PrjSecConfig", auth=auth, iKeyDist=iKeyDist, rKeyDist=rKeyDist, oob=oob, initiateSec=1)  
            
            # Set IO Capabilities
            pkt = engine.send("EMSHI_DM_PrjSmpConfig", 
                        attemptTimeout=500,
                        ioCap=iocap,
                        minKeyLen=minKeyLen,
                        maxKeyLen=maxKeyLen,
                        maxAttempts=2,
                        auth=auth,
                        maxAttemptTimeout=64000,
                        attemptDecTimeout=64000,
                        attemptExp=4
                        )
                
            # pkt = engine.send("EMSHI_DM_SecPairRsp", connId=conn_handle, oob=oob, auth=auth, iKeyDist=iKeyDist, rKeyDist=rKeyDist)
    
            return pkt.response.get("status") == 0
        else:
            if oob == 0x01:
                engine.send("EMSHI_SM_SetOobData", OobData=oob_data)
            if mitm == 0x01:
                engine.send("EMSHI_SM_ForceLocalMITMReq", localMITMUsed=1)
            if sc == 0x01:
                # Force LE SC pairing
                engine.send("EMSHI_SM_ForcePairingMode", localPairingMode=2)
            pkt = engine.send("EMSHI_SM_SetIOCapability", IoCapability=iocap)
            return pkt.response.get("status") == 0
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-sm.set_passkey:

sm.set_passkey_
***************


    Set the passkey required during pairing process
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.sm import set_passkey

    set_passkey(engine, conn_handle, passkey)


**CLI usage**

.. code-block:: bash

    blengine run SM.set_passkey [-h] conn_handle passkey

*Positional arguments:*

:conn_handle:

    Connection Handle

:passkey:

    6-digit passkey to be used in Passkey or Numeric Comparison
               Pairing methods


options:
  -h, --help   show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="SM.", parser=set_passkey_parser)
    def set_passkey(engine, conn_handle, passkey):
        '''
        Set the passkey required during pairing process
        '''
        if engine.bluetooth_host_stack == "EMB":
            Passkey = int(passkey).to_bytes(3,"little")
            pkt = engine.send("EMSHI_DM_SecAuthRsp",
                        connId=conn_handle,
                        authDataLen=3,
                        AuthData=Passkey)
            status = pkt.response.get("status")
            return status == 0
        else:
            pkt = engine.send("EMSHI_SM_ConfirmPasskey",
                                    ConnHandle=conn_handle,
                                    Passkey=passkey)
            return pkt.response.get("status") == 0
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-sm.remove_bonding:

sm.remove_bonding_
******************


    Remove existing bonding (stored keys) with a given address
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.sm import remove_bonding

    remove_bonding(engine, address)


**CLI usage**

.. code-block:: bash

    blengine run SM.remove_bonding [-h] address

*Positional arguments:*

:address:

    Address of the device to be unbonded


options:
  -h, --help  show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="SM.", parser=remove_bonding_parser)
    def remove_bonding(engine, address):
        '''
        Remove existing bonding (stored keys) with a given address
        '''
        if engine.bluetooth_host_stack == "EMB":
            pkt = engine.send("EMSHI_DM_RemoveBonding", address=address)
            return pkt.response.get("status") == 0
        else:
            pkt = engine.send("EMSHI_SM_UnBond", Addr=address)
            return pkt.response.get("status") == 0
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-sm.is_device_bonded:

sm.is_device_bonded_
********************


    Retrieve bonding status of a remote device
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.sm import is_device_bonded

    is_device_bonded(engine, address, role)


**CLI usage**

.. code-block:: bash

    blengine run SM.is_device_bonded [-h] address address

*Positional arguments:*

:address:

    Address of the device to be unbonded

:address:

    Local device role


options:
  -h, --help  show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="SM.", parser=is_device_bonded_parser)
    def is_device_bonded(engine, address, role):
        '''
        Retrieve bonding status of a remote device
        '''
        if engine.bluetooth_host_stack == "EMB":       
            pkt = engine.send("EMSHI_DM_IsBonded", address=address)
            return pkt.response.get("status") == 0
        else:
            pkt = engine.send("EMSHI_SM_IsDeviceBonded", Addr=address, role=role)
            return pkt.response.get("status") == 0
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-sm.initiate_encryption:

sm.initiate_encryption_
***********************


    Send Security Encryption Request
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.sm import initiate_encryption

    initiate_encryption(engine, conn_handle=0, secLevel=3, key_ltk=None)


**CLI usage**

.. code-block:: bash

    blengine run SM.initiate_encryption [-h] [--conn_handle CONN_HANDLE]
                                   [--secLevel SECLEVEL] [--key_ltk KEY_LTK]


options:
  -h, --help            show this help message and exit
  --conn_handle CONN_HANDLE
                        Connection Handle
  --secLevel SECLEVEL   Security Level
  --key_ltk KEY_LTK     Remote LTK


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="SM.", parser=initiate_encryption_parser)
    def initiate_encryption(engine, conn_handle=0, secLevel=3, key_ltk=None):
        '''
        Send Security Encryption Request
        '''
        if engine.bluetooth_host_stack == "EMB":
            pkt = engine.send("EMSHI_DM_SecEncryptReq", connId=conn_handle, secLevel=secLevel, Ltk=key_ltk)
            return pkt.response.get("status") == 0
        else:
            status = initiate_pairing(engine, conn_handle=conn_handle, iocap=0x03, bonding=0x01)
            return status
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-sm.set_oob:

sm.set_oob_
***********


    Set OOB Confirm and OOB Random value for SC OOB Pairing
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.sm import set_oob

    set_oob(engine, conn_handle, oob_confirm, oob_random)


**CLI usage**

.. code-block:: bash

    blengine run SM.set_oob [-h] conn_handle oob_confirm oob_random

*Positional arguments:*

:conn_handle:

    Connection Handle

:oob_confirm:

    Peer's OOB Confirm value (16 bytes)

:oob_random:

    Peer's OOB Random value (16 bytes)


options:
  -h, --help   show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="SM.", parser=set_oob_parser)
    def set_oob(engine, conn_handle, oob_confirm, oob_random):
        '''
        Set OOB Confirm and OOB Random value for SC OOB Pairing
        '''
        if engine.bluetooth_host_stack == "EMB":
            pkt = engine.send("EMSHI_DM_SecSetOob", connId=conn_handle, localRandom=oob_random, localConfirm=oob_confirm, peerRandom=oob_random, peerConfirm=oob_confirm)
            return pkt.response.get("status") == 0
        else:
            pass
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-sm.send_security_request:

sm.send_security_request_
*************************


    Peripheral initiated Security Request
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.sm import send_security_request

    send_security_request(engine, conn_handle=0, iocap=3, oob=0, bonding=0, mitm=None, sc=0, keypress=0, ini_key_dist_enc=True, ini_key_dist_id=True, ini_key_dist_sign=True, rsp_key_dist_enc=True, rsp_key_dist_id=True, rsp_key_dist_sign=True, oob_data=None)


**CLI usage**

.. code-block:: bash

    blengine run SM.send_security_request [-h] [--io_cap IO_CAP] [--oob OOB]
                                     [--bonding BONDING] [--mitm MITM]
                                     [--sc SC] [--keypress KEYPRESS]
                                     [--oob_data OOB_DATA]
                                     conn_handle

*Positional arguments:*

:conn_handle:

    Connection Handle


options:
  -h, --help           show this help message and exit
  --io_cap IO_CAP      IO Capability
  --oob OOB            OOB data flag
  --bonding BONDING    Bonding Flags
  --mitm MITM          MITM protection
  --sc SC              LE Secure Connections pairing
  --keypress KEYPRESS  Keypress
  --oob_data OOB_DATA  Peer OOB data


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="SM.", parser=send_security_request_parser)
    def send_security_request(engine,
                              conn_handle=0, 
                              iocap=0x03,
                              oob=0x00,
                              bonding=0x00,
                              mitm=None,
                              sc=0x00,
                              keypress=0x00,
                              ini_key_dist_enc=True,
                              ini_key_dist_id=True,
                              ini_key_dist_sign=True,
                              rsp_key_dist_enc=True,
                              rsp_key_dist_id=True,
                              rsp_key_dist_sign=True,
                              oob_data=None,
                              ):
        '''
        Peripheral initiated Security Request
        '''
        if engine.bluetooth_host_stack == "EMB":
            # First, let's calculate the value of auth parameter
            if bonding == 0x01:
                SM_AUTH_BOND_FLAG = 0x01
                ini_key_dist_enc = True
                ini_key_dist_id = True
                rsp_key_dist_enc = True
                rsp_key_dist_id = True
                engine.send("EMSHI_DM_SecSetLocalCsrk", Csrk=0x11223344556677881122334455667788)
    
            else:
                SM_AUTH_BOND_FLAG = 0x00
    
            if mitm == 0x01:
                SM_AUTH_MITM_FLAG = 0x04
            else:
                SM_AUTH_MITM_FLAG = 0x00
    
            if sc == 0x01:
                SM_AUTH_SC_FLAG = 0x08
                engine.send("EMSHI_DM_SecGenerateEccKeyReq")
            else:
                SM_AUTH_SC_FLAG = 0x00
            
            if keypress == 0x01:
                SM_AUTH_KP_FLAG = 0x10
            else:
                SM_AUTH_KP_FLAG = 0x00
    
            auth = SM_AUTH_BOND_FLAG + SM_AUTH_MITM_FLAG + SM_AUTH_SC_FLAG + SM_AUTH_KP_FLAG
    
            # Calculate value of initiator and responder key distribution parameters
    
            if ini_key_dist_enc:
                ini_key_dist_enc = 0x01
            else:
                ini_key_dist_enc = 0x00 
    
            if ini_key_dist_id:
                ini_key_dist_id = 0x02
            else:
                ini_key_dist_id = 0x00
                
            if ini_key_dist_sign:
                ini_key_dist_sign = 0x04
            else:
                ini_key_dist_sign = 0x00
    
            if rsp_key_dist_enc:
                rsp_key_dist_enc = 0x01
            else:
                rsp_key_dist_enc = 0x00 
    
            if rsp_key_dist_id:
                rsp_key_dist_id = 0x02
            else:
                rsp_key_dist_id = 0x00
                
            if rsp_key_dist_sign:
                rsp_key_dist_sign = 0x04
            else:
                rsp_key_dist_sign = 0x00
    
            iKeyDist = ini_key_dist_enc + ini_key_dist_id + ini_key_dist_sign
            rKeyDist = rsp_key_dist_enc + rsp_key_dist_id + rsp_key_dist_sign
    
            def on_OOB_request(pkt):
                engine.send("EMSHI_DM_SecSetOob", connId=conn_handle, Config=oob_data)
                engine.send("EMSHI_DM_SecAuthRsp",
                        connId=conn_handle,
                        authDataLen=16,
                        AuthData=oob_data)
    
            if oob == 0x01:
                engine.bind("on_DM_SEC_AUTH_REQ_IND", on_OOB_request)
    
            # Set Security configuration
            engine.send("EMSHI_DM_PrjSecConfig", auth=auth, iKeyDist=iKeyDist, rKeyDist=rKeyDist, oob=oob, initiateSec=0)  
    
            # Set IO Capabilities
            engine.send("EMSHI_DM_PrjSmpConfig", 
                        attemptTimeout=500,
                        ioCap=iocap,
                        minKeyLen=7,
                        maxKeyLen=16,
                        maxAttempts=1,
                        auth=auth,
                        maxAttemptTimeout=64000,
                        attemptDecTimeout=64000,
                        attemptExp=2
                        )
            pkt = engine.send("EMSHI_DM_SecSlaveReq", connId=conn_handle, auth=auth)
            return pkt.response.get("status") == 0
    
        else:
            status = initiate_pairing(engine, conn_handle=conn_handle, iocap=iocap, mitm=mitm, bonding=bonding, oob=oob, sc=sc)
            return status
    


.. raw:: html
    
    </details>
    <hr>

this page is auto generated by BLEngine/docs/procedures.py