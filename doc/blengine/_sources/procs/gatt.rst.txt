
.. this file is auto generated by BLEngine/docs/procedures.py

=============================
gatt Procedures
=============================

.. raw:: html
    
    
    <input class="search input" type="text" placeholder="Live Search" style="width: 100%; padding: 10px;">
    <div>&nbsp</div>
    <div id="search-loader" style="display:none;">please wait...</div>
    
.. _proc-gatt.register_server:

gatt.register_server_
*********************


    Register the Local Device as a Server. (EMSHI)
    
    :param      engine:  The engine
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gatt import register_server

    register_server(engine)


**CLI usage**

.. code-block:: bash

    No Help

.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GATT.")
    def register_server(engine):
        '''
        Register the Local Device as a Server. (EMSHI)
        
        :param      engine:  The engine
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        '''
        if engine.bluetooth_host_stack == "EMB":
            pkt = engine.send("EMSHI_ATTS_Init")
            pkt = engine.send("EMSHI_ATTS_IndInit")
            pkt = engine.send("EMSHI_ATTS_SignInit")
            pkt = engine.send("EMSHI_ATT_Register")
            pkt = engine.send("EMSHI_ATTS_DynInit")
            pkt = engine.send("EMSHI_ATT_ConnRegister")
            if pkt.response.get("status") == 0:
                return True, "Registered as server"
        else: 
            pass       
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gatt.register_client:

gatt.register_client_
*********************


    Register the Local Device as a Client. (EMSHI)
    
    :param      engine:  The engine
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gatt import register_client

    register_client(engine)


**CLI usage**

.. code-block:: bash

    No Help

.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GATT.")
    def register_client(engine):
        '''
        Register the Local Device as a Client. (EMSHI)
        
        :param      engine:  The engine
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        '''
        if engine.bluetooth_host_stack == "EMB":
            pkt = engine.send("EMSHI_ATTC_Init")
            pkt = engine.send("EMSHI_ATT_Register")
            if pkt.response.get("status") == 0:
                return True, "Registered as client"
                    
        else:
            pkt = engine.send("EMSHI_GATT_RegisterClient")
            if pkt.response.get("status") != 0:
                return 0, "Unregistered client failure"
            pkt = engine.send("EMSHI_GATT_IsRegisterClient")
            ok = pkt.response.get("status") == 0
            return ok, "Registered as client"
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gatt.deregister_client:

gatt.deregister_client_
***********************


    Register the Local Device as a Client. (EMSHI)
    
    :param      engine:          The engine
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    
    :raises     AssertionError:  { exception_description }
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gatt import deregister_client

    deregister_client(engine)


**CLI usage**

.. code-block:: bash

    No Help

.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GATT.")
    def deregister_client(engine):
        '''
        Register the Local Device as a Client. (EMSHI)
        
        :param      engine:          The engine
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        
        :raises     AssertionError:  { exception_description }
        '''
        pkt = engine.send("EMSHI_GATT_DeRegisterClient")
        assert pkt.response.get("status") == 0
        pkt = engine.send("EMSHI_GATT_IsRegisterClient")
        ok = pkt.response.get("status") == 1
        return ok, "no more registered as client"
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gatt.read_value:

gatt.read_value_
****************


    Read a Characteristic Value. (EMSHI)
    
    :param      engine:        The engine
    :param      conn_handle:   The connection handle
    :param      value_handle:  The value handle
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gatt import read_value

    read_value(engine, conn_handle, value_handle)


**CLI usage**

.. code-block:: bash

    blengine run GATT.read_value [-h] conn_handle value_handle

*Positional arguments:*

:conn_handle:

    Connection Handle

:value_handle:

    Value Handle


options:
  -h, --help    show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GATT.", parser=read_char_parser)
    def read_value(engine, conn_handle, value_handle):
        '''
        Read a Characteristic Value. (EMSHI)
        
        :param      engine:        The engine
        :param      conn_handle:   The connection handle
        :param      value_handle:  The value handle
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        '''
        if engine.bluetooth_host_stack == "EMB":
            pkt = engine.send("EMSHI_ATTC_ReadReq", connId=conn_handle, handle=value_handle)
            ok = pkt.response.get("status") == 0
            return ok, pkt.response.get("Value")        
        else:
            pkt = engine.send("EMSHI_GATT_ReadCharacteristicValueByHandle", ConnHandle=conn_handle, ValueHandle=value_handle)
            ok = pkt.response.get("status") == 0
            return ok, pkt.response.get("Value")
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gatt.write_value:

gatt.write_value_
*****************


    write a characteristic values

    TODO: the firmware send 3 to 5 differents events for each write, what ???
    
    TODO: manage errors (permissions, etc...)
    
    :param      engine:        The engine
    :param      conn_handle:   The connection handle
    :param      value_handle:  The value handle
    :param      value:         The value
    :param      length:        The length
    :param      timeout:       The timeout
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gatt import write_value

    write_value(engine, conn_handle, value_handle, value, length=None, timeout=1)


**CLI usage**

.. code-block:: bash

    blengine run GATT.write_value [-h] [--timeout TIMEOUT]
                             conn_handle value_handle value

*Positional arguments:*

:conn_handle:

    Connection Handle

:value_handle:

    Value Handle

:value:

    Value Handle


options:
  -h, --help         show this help message and exit
  --timeout TIMEOUT  timeout


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GATT.", parser=write_char_parser)
    def write_value(engine, conn_handle, value_handle, value, length=None, timeout=1):
        """
        write a characteristic values
    
        TODO: the firmware send 3 to 5 differents events for each write, what ???
        
        TODO: manage errors (permissions, etc...)
        
        :param      engine:        The engine
        :param      conn_handle:   The connection handle
        :param      value_handle:  The value handle
        :param      value:         The value
        :param      length:        The length
        :param      timeout:       The timeout
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        """
    
        is_write_complete = threading.Event()
        
        def write_complete(pkt):
            """
            Writes a complete.
            
            :param      pkt:  The packet
            """
            if pkt.get("status") == 0:
                is_write_complete.set()
        
        if engine.bluetooth_host_stack == "EMB":
    
            engine.bind("on_ATTC_WRITE_RSP", write_complete)
            
            pkt = engine.send("EMSHI_ATTC_WriteReq",
                    connId=conn_handle,
                    handle=value_handle,
                    valueLen=length or len(value), 
                    pValue=value)
            
            done = is_write_complete.wait(timeout=timeout)
            
            engine.unbind("on_ATTC_WRITE_RSP", write_complete)
    
            return done, pkt
                    
        else:
            engine.bind("BLEGATTEVENT_CHARACTERISTICVALUEWRITECOMPLETE", write_complete)
    
            value = to_bytes(value)
            
            pkt = engine.send("EMSHI_GATT_WriteCharacteristicValue",
                    ConnHandle=conn_handle,
                    ValueHandle=value_handle,
                    ValueLen=length or len(value), 
                    Value=value)
    
            if pkt.response.name == "BLEGATTEVENT_CHARACTERISTICVALUEWRITECOMPLETE" \
                and not None and pkt.response.get('ErrorCode') == 0:
                is_write_complete.set()
    
            done = is_write_complete.wait(timeout=timeout)
    
            engine.unbind("BLEGATTEVENT_CHARACTERISTICVALUEWRITECOMPLETE", write_complete)
    
            return done, pkt
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gatt.write_without_response:

gatt.write_without_response_
****************************


    write a characteristic values without response (Write Command)

    TODO: the firmware send 3 to 5 differents events for each write, what ???
    
    TODO: manage errors (permissions, etc...)
    
    :param      engine:        The engine
    :param      conn_handle:   The connection handle
    :param      value_handle:  The value handle
    :param      value:         The value
    :param      length:        The length
    :param      timeout:       The timeout
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gatt import write_without_response

    write_without_response(engine, conn_handle, value_handle, value, length=None, timeout=1)


**CLI usage**

.. code-block:: bash

    blengine run GATT.write_without_response [-h] [--timeout TIMEOUT]
                                        conn_handle value_handle value

*Positional arguments:*

:conn_handle:

    Connection Handle

:value_handle:

    Value Handle

:value:

    Value Handle


options:
  -h, --help         show this help message and exit
  --timeout TIMEOUT  timeout


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GATT.", parser=write_without_rsp_parser)
    def write_without_response(engine, conn_handle, value_handle, value, length=None, timeout=1):
        """
        write a characteristic values without response (Write Command)
    
        TODO: the firmware send 3 to 5 differents events for each write, what ???
        
        TODO: manage errors (permissions, etc...)
        
        :param      engine:        The engine
        :param      conn_handle:   The connection handle
        :param      value_handle:  The value handle
        :param      value:         The value
        :param      length:        The length
        :param      timeout:       The timeout
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        """
    
        is_write_sent = threading.Event()
    
        def write_sent(pkt):
            """
            Write is complete.
    
            :param      pkt:  The packet
            """
            if pkt.get("status") == 0:
                is_write_sent.set()
    
        if engine.bluetooth_host_stack == "EMB":  
            
            engine.bind("ATTC_WRITE_CMD_RSP", write_sent)
    
            pkt=engine.send("EMSHI_ATTC_WriteCmd",
                          connId=conn_handle,
                          handle=value_handle,
                          valueLen=length or len(value),
                          pValue=value)
            
            done = is_write_sent.wait(timeout=timeout)
    
            engine.unbind("ATTC_WRITE_CMD_RSP", write_sent)
    
            return done, pkt
            
        else:
    
            engine.bind("BLEGATTEVENT_WRITEWITHOUTRESPONSESENT", write_sent)
    
            value = to_bytes(value)
    
            pkt = engine.send("EMSHI_GATT_WriteCharacteristicValueWithoutResponse",
                          ConnHandle=conn_handle,
                          ValueHandle=value_handle,
                          ValueLen=length or len(value),
                          Value=value)
            
            if pkt.response.name == "BLEGATTEVENT_WRITEWITHOUTRESPONSESENT" \
                and not None and pkt.response.get('status') == 0:
                is_write_sent.set()
    
            done = is_write_sent.wait(timeout=timeout)
    
            engine.unbind("BLEGATTEVENT_CHARACTERISTICVALUEWRITECOMPLETE", write_sent)
    
            return done, pkt
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gatt.write_long_value:

gatt.write_long_value_
**********************


    write a characteristic values

    TODO: the firmware send 3 to 5 differents events for each write, what ???
    
    TODO: manage errors (permissions, etc...)
    
    :param      engine:        The engine
    :param      conn_handle:   The connection handle
    :param      value_handle:  The value handle
    :param      offset:        The offset to start to write the characteristic Value.
    :param      value:         The value
    :param      length:        The length
    :param      timeout:       The timeout
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gatt import write_long_value

    write_long_value(engine, conn_handle, value_handle, value, length=None, timeout=1, offset=0, writeAll=True, continuing=True)


**CLI usage**

.. code-block:: bash

    blengine run GATT.write_long_value [-h] [--timeout TIMEOUT] [--offset OFFSET]
                                  [--writeAll WRITEALL]
                                  [--continuing CONTINUING]
                                  conn_handle value_handle value

*Positional arguments:*

:conn_handle:

    Connection Handle

:value_handle:

    Value Handle

:value:

    Value Handle


options:
  -h, --help            show this help message and exit
  --timeout TIMEOUT     timeout
  --offset OFFSET       Offset
  --writeAll WRITEALL   TRUE to write all queued writes, FALSE to cancel all
                        queued writes.
  --continuing CONTINUING
                        TRUE if ATTC continues sending requests until
                        complete.


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GATT.", parser=write_long_value_parser)
    def write_long_value(engine, conn_handle, value_handle, value, length=None, timeout=1, offset=0, writeAll=True,continuing=True):
        """
        write a characteristic values
    
        TODO: the firmware send 3 to 5 differents events for each write, what ???
        
        TODO: manage errors (permissions, etc...)
        
        :param      engine:        The engine
        :param      conn_handle:   The connection handle
        :param      value_handle:  The value handle
        :param      offset:        The offset to start to write the characteristic Value.
        :param      value:         The value
        :param      length:        The length
        :param      timeout:       The timeout
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        """
        is_write_complete = threading.Event()
        
        def write_complete(pkt):
            """
            Writes a complete.
            
            :param      pkt:  The packet
            """
            if pkt.get("status") == 0:
                is_write_complete.set()
        
        if engine.bluetooth_host_stack == "EMB":
    
            engine.bind("on_ATTC_EXECUTE_WRITE_RSP", write_complete)
    
            pkt = engine.send("EMSHI_ATTC_PrepareWriteReq",
                          connId=conn_handle,
                          handle=value_handle,
                          offset=offset,
                          valueLen=length or len(value),
                          valueByRef=False,
                          continuing=continuing,
                          pValue=value)
            
            time.sleep(0.5)
    
            pkt = engine.send("EMSHI_ATTC_ExecuteWriteReq",
                          connId=conn_handle,
                          writeAll=writeAll)
            
            done = is_write_complete.wait(timeout=timeout)
    
            engine.unbind("on_ATTC_EXECUTE_WRITE_RSP", write_complete)
            
    
            return done, pkt
        
        else:
    
            engine.bind("BLEGATTEVENT_LONGCHARACTERISTICVALUEWRITECOMPLETE", write_complete)
    
            value = to_bytes(value)
    
            pkt = engine.send("EMSHI_GATT_WriteLongCharacteristicValueEx",
                          ConnHandle=conn_handle,
                          ValueHandle=value_handle,
                          Offset=offset,
                          ValueLen=length or len(value),
                          Value=value)
            
            if pkt.response.name == "BLEGATTEVENT_LONGCHARACTERISTICVALUEWRITECOMPLETE" \
                and not None and pkt.response.get('ErrorCode') == 0:
                is_write_complete.set()
    
            done = is_write_complete.wait(timeout=timeout)
    
            engine.unbind("BLEGATTEVENT_LONGCHARACTERISTICVALUEWRITECOMPLETE", write_complete)
    
            return done, pkt
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gatt.read_multiple:

gatt.read_multiple_
*******************


    Read multiple values
    
    :param      engine:        The engine
    :param      conn_handle:   The connection handle
    :param      num_handles:   The number of handles to read
    :param      handles:       Array of handles to be read
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gatt import read_multiple

    read_multiple(engine, conn_handle, num_handles, handles)


**CLI usage**

.. code-block:: bash

    blengine run GATT.read_multiple [-h] conn_handle num_handles handles

*Positional arguments:*

:conn_handle:

    Connection Handle

:num_handles:

    Number of handles to read

:handles:

    Value Handles


options:
  -h, --help   show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GATT.", parser=read_multiple_parser)
    def read_multiple(engine, conn_handle, num_handles, handles):
        """
        Read multiple values
        
        :param      engine:        The engine
        :param      conn_handle:   The connection handle
        :param      num_handles:   The number of handles to read
        :param      handles:       Array of handles to be read
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        """
        if engine.bluetooth_host_stack == "EMB":
            
            #Converting elements of str type in the tuple to int
            int_tuple = tuple(int(handle, 16) for handle in handles)
            
            #Populating format string based on the size of the tuple
            format_string= "H" * len(int_tuple)
            
            #packing the tuple into bytes to be sent to prj_emshi
            handles_packed = struct.pack(format_string, *int_tuple)
            
            pkt = engine.send("EMSHI_ATTC_ReadMultipleReq", 
                                    connId=conn_handle,
                                    numHandles=num_handles,
                                    pHandles=handles_packed)
            
            ok = pkt.response.get("status") == 0
            Value=pkt.response.get("Value")
                    
            return ok, Value 
                    
        else:
            pkt = engine.send("EMSHI_GATT_ReadMultipleValues", 
                                    ConnHandle=conn_handle,
                                    NumHandle=num_handles,
                                    Handles=handles)
            ok = pkt.response.get("status") == 0
            return ok, pkt.response.get("Value")
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gatt.read_long_value:

gatt.read_long_value_
*********************


    Read a Long Characteristic Value. (EMSHI)
    
    :param      engine:        The engine
    :param      conn_handle:   The connection handle
    :param      value_handle:  The value handle
    :param      offset:        The offset to start to read the characteristic Value.
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gatt import read_long_value

    read_long_value(engine, conn_handle, value_handle, offset=0)


**CLI usage**

.. code-block:: bash

    blengine run GATT.read_long_value [-h] [--offset OFFSET]
                                 conn_handle value_handle

*Positional arguments:*

:conn_handle:

    Connection Handle

:value_handle:

    Value Handle


options:
  -h, --help       show this help message and exit
  --offset OFFSET  Offset


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GATT.", parser=read_long_value_parser)
    def read_long_value(engine, conn_handle, value_handle, offset=0):
        '''
        Read a Long Characteristic Value. (EMSHI)
        
        :param      engine:        The engine
        :param      conn_handle:   The connection handle
        :param      value_handle:  The value handle
        :param      offset:        The offset to start to read the characteristic Value.
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        '''
    
        if engine.bluetooth_host_stack == "EMB":
            time.sleep(1)         # Without this, the test does not run the command multiple times
            pkt = engine.send("EMSHI_ATTC_ReadLongReq", 
                                    connId=conn_handle,
                                    handle=value_handle,
                                    offset=offset,
                                    continuing=True)
            
            ok = pkt.response.get("status") == 0
            return ok, pkt.response.get("Value")
        
        else:
            pkt = engine.send("EMSHI_GATT_ReadLongCharacteristicValueByHandleEx", 
                                    ConnHandle=conn_handle,
                                    ValueHandle=value_handle,
                                    Offset=offset)
            ok = pkt.response.get("status") == 0
            return ok, pkt.response.get("Value")
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gatt.read_value_by_type:

gatt.read_value_by_type_
************************


    Read a Characteristic Value by Type (Characteristic UUID). (EMSHI)
    
    :param      engine:        The engine
    :param      conn_handle:   The connection handle
    :param      start_handle:  The service starting handle
    :param      end_handle:    The service ending handle
    :param      uuid:          The UUID of the Characteristic from which the value is to be read
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gatt import read_value_by_type

    read_value_by_type(engine, conn_handle, start_handle, end_handle, uuid)


**CLI usage**

.. code-block:: bash

    blengine run GATT.read_value_by_type [-h]
                                    conn_handle start_handle end_handle uuid

*Positional arguments:*

:conn_handle:

    Connection Handle

:start_handle:

    Service Starting Handle

:end_handle:

    Service Ending Handle

:uuid:

    Characteristic UUID to be read


options:
  -h, --help    show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GATT.", parser=read_value_by_type_parser)
    def read_value_by_type(engine, conn_handle, start_handle, end_handle, uuid):
        '''
        Read a Characteristic Value by Type (Characteristic UUID). (EMSHI)
        
        :param      engine:        The engine
        :param      conn_handle:   The connection handle
        :param      start_handle:  The service starting handle
        :param      end_handle:    The service ending handle
        :param      uuid:          The UUID of the Characteristic from which the value is to be read
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        '''
    
        if engine.bluetooth_host_stack == "EMB":
            
            pkt = engine.send("EMSHI_ATTC_ReadByTypeReq", 
                                    connId=conn_handle,
                                    startHandle=start_handle,
                                    endHandle=end_handle,
                                    uuidLen=len(uuid),
                                    pUuid=uuid,
                                    continuing=True) 
            
            ok = pkt.response.get("status") == 0
            
            time.sleep(0.2)
            
            return ok, pkt.response.get("Value")
        
        else:
            UUIDType = 0 if len(uuid) == 2 else 1
            pkt = engine.send("EMSHI_GATT_ReadCharacteristicValueByType", 
                                    ConnHandle=conn_handle,
                                    ServiceStartingHandle=start_handle,
                                    ServiceEndingHandle=end_handle,
                                    UUIDType=UUIDType,
                                    uuid=uuid)
            ok = pkt.response.get("status") == 0
            return ok, pkt.response.get("Value")
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gatt.exchange_mtu:

gatt.exchange_mtu_
******************


    Send a Exchange MTU Request 
    
    :param      engine:        The engine
    :param      conn_handle:   The connection handle
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gatt import exchange_mtu

    exchange_mtu(engine, conn_handle, mtu=150)


**CLI usage**

.. code-block:: bash

    blengine run GATT.exchange_mtu [-h] [--mtu MTU] conn_handle

*Positional arguments:*

:conn_handle:

    Connection Handle


options:
  -h, --help   show this help message and exit
  --mtu MTU    Connection Handle


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GATT.", parser=exchange_mtu_parser)
    def exchange_mtu(engine, conn_handle,mtu=150):
        '''
        Send a Exchange MTU Request 
        
        :param      engine:        The engine
        :param      conn_handle:   The connection handle
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        '''
        if engine.bluetooth_host_stack == "EMB": 
            pkt = engine.send("EMSHI_ATTC_MtuReq", connId=conn_handle,mtu=mtu)
            ok = pkt.response.get("status") == 0
            mtu = pkt.response.get("negociatedMTUValue")
            return ok, mtu
            
        else:
            pkt = engine.send("EMSHI_GATT_ExchangeMTU", ConnHandle=conn_handle)
            ok = pkt.response.get("status") == 0
            mtu = pkt.response.get("negociatedMTUValue")
            return ok, mtu
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gatt.discover_all_services:

gatt.discover_all_services_
***************************


    Client discover all the services supported by the remote ATTRIBUTE SERVER

    :param      engine:        The engine
    :param      conn_handle:   The connection handle
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gatt import discover_all_services

    discover_all_services(engine, conn_handle)


**CLI usage**

.. code-block:: bash

    blengine run GATT.discover_all_services [-h] conn_handle

*Positional arguments:*

:conn_handle:

    Connection Handle


options:
  -h, --help   show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GATT.", parser=discover_all_services_parser)
    def discover_all_services(engine, conn_handle):
        '''
        Client discover all the services supported by the remote ATTRIBUTE SERVER
    
        :param      engine:        The engine
        :param      conn_handle:   The connection handle
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        '''
        if engine.bluetooth_host_stack == "EMB":
               
            pkt=engine.send("EMSHI_ATTC_ReadByGroupTypeReq", 
                            connId=conn_handle,
                            startHandle=1, #Start this from 0x0001
                            endHandle=65535,# End this at 0xFFFF
                            uuidLen =2,
                            pUuid = 10240, # 0x2800 Primary Service UUID
                            continuing=False)
            
            return pkt        
        else:
            pkt = engine.send("EMSHI_GATT_DiscoverAllPrimaryServices", ConnHandle=conn_handle)
            ok = pkt.response.get("status") == 0
            if ok:
                ConnHandle=pkt.response.get("ConnHandle")
                ServiceStartingHandle=pkt.response.get("ServiceStartingHandle")
                ServiceEndingHandle=pkt.response.get("ServiceEndingHandle")
                NumServices=pkt.response.get("NumServices")
            
            return ok, ConnHandle, ServiceStartingHandle, ServiceEndingHandle, NumServices
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gatt.discover_service_by_type:

gatt.discover_service_by_type_
******************************


    Client discover if a specified service UUID is supported by the remote SERVER

    :param      engine:        The engine
    :param      conn_handle:   The connection handle
    :param      uuid:          Service UUID to be discovered
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gatt import discover_service_by_type

    discover_service_by_type(engine, conn_handle, uuid)


**CLI usage**

.. code-block:: bash

    blengine run GATT.discover_service_by_type [-h] conn_handle uuid

*Positional arguments:*

:conn_handle:

    Connection Handle

:uuid:

    Service UUID


options:
  -h, --help   show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GATT.", parser=discover_service_by_type_parser)
    def discover_service_by_type(engine, conn_handle, uuid):
        '''
        Client discover if a specified service UUID is supported by the remote SERVER
    
        :param      engine:        The engine
        :param      conn_handle:   The connection handle
        :param      uuid:          Service UUID to be discovered
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        '''
        if engine.bluetooth_host_stack == "EMB":
            
            pkt=engine.send("EMSHI_ATTC_FindByTypeValueReq", connId=conn_handle,
                            startHandle=1,
                            endHandle=65535,
                            uuid16=10240,
                            valueLen=len(uuid),
                            pValue=uuid,
                            continuing=True)
            return pkt  
        else:
            UUIDType = 0 if len(uuid) == 2 else 1
            pkt = engine.send("EMSHI_GATT_DiscoverPrimaryServiceByType", 
                              ConnHandle=conn_handle,
                              UUIDType=UUIDType,
                              UUID=uuid)
            ok = pkt.response.get("status") == 0
            if ok:
                ConnHandle=pkt.response.get("ConnHandle")
                ServiceStartingHandle=pkt.response.get("ServiceStartingHandle")
                ServiceEndingHandle=pkt.response.get("ServiceEndingHandle")
                NumServices=pkt.response.get("NumServices")
            
            return ok, ConnHandle, ServiceStartingHandle, ServiceEndingHandle, NumServices
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gatt.discover_all_characteristic:

gatt.discover_all_characteristic_
*********************************


    Client discover all the Characteristic supported by a service

    :param      engine:        The engine
    :param      conn_handle:   The connection handle
    :param      start_handle:  The service starting handle
    :param      end_handle:    The service ending handle
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gatt import discover_all_characteristic

    discover_all_characteristic(engine, conn_handle, start_handle, end_handle)


**CLI usage**

.. code-block:: bash

    blengine run GATT.discover_all_characteristic [-h]
                                             conn_handle start_handle
                                             end_handle

*Positional arguments:*

:conn_handle:

    Connection Handle

:start_handle:

    Service Starting Handle

:end_handle:

    Service Ending Handle


options:
  -h, --help    show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GATT.", parser=discover_all_characteristic_parser)
    def discover_all_characteristic(engine, conn_handle, start_handle, end_handle):
        '''
        Client discover all the Characteristic supported by a service
    
        :param      engine:        The engine
        :param      conn_handle:   The connection handle
        :param      start_handle:  The service starting handle
        :param      end_handle:    The service ending handle
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        '''
        if engine.bluetooth_host_stack == "EMB":
          
            pkt=engine.send("EMSHI_ATTC_ReadByTypeReq", 
                            connId=conn_handle,
                            startHandle=start_handle, 
                            endHandle=end_handle,
                            pUuid=10243, #Char UUID 0x2803
                            uuidLen=2,
                            continuing=True)
            ok = pkt.response.get("status") == 0
                    
            return ok, pkt.response.get("Value")
        else:
            pkt = engine.send("EMSHI_GATT_DiscoverAllCharacteristic", 
                              ConnHandle=conn_handle,
                              ServiceStartingHandle=start_handle,
                              ServiceEndingHandle=end_handle)
            ok = pkt.response.get("status") == 0
            if ok:
                ConnHandle=pkt.response.get("ConnHandle")
                NumCharacteristics=pkt.response.get("NumCharacteristics")
            
            return ok, ConnHandle, NumCharacteristics
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gatt.find_included_service:

gatt.find_included_service_
***************************


    Client discover all the included services of the specified service

    :param      engine:        The engine
    :param      conn_handle:   The connection handle
    :param      start_handle:  The service starting handle
    :param      end_handle:    The service ending handle
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gatt import find_included_service

    find_included_service(engine, conn_handle, start_handle, end_handle)


**CLI usage**

.. code-block:: bash

    blengine run GATT.find_included_service [-h]
                                       conn_handle start_handle end_handle

*Positional arguments:*

:conn_handle:

    Connection Handle

:start_handle:

    Service Starting Handle

:end_handle:

    Service Ending Handle


options:
  -h, --help    show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GATT.", parser=find_included_service_parser)
    def find_included_service(engine, conn_handle, start_handle, end_handle):
        '''
        Client discover all the included services of the specified service
    
        :param      engine:        The engine
        :param      conn_handle:   The connection handle
        :param      start_handle:  The service starting handle
        :param      end_handle:    The service ending handle
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        '''
        if engine.bluetooth_host_stack == "EMB":
            
            pkt=engine.send("EMSHI_ATTC_ReadByTypeReq", 
                            connId=conn_handle,
                            startHandle=start_handle, #Start this from 0x2A00
                            endHandle=end_handle,# End this at 0x2BF5
                            pUuid=10242,
                            uuidLen=2,
                            continuing=True)
            
            ok = pkt.response.get("status") == 0
            return ok, pkt.response.get("Value")
        else:
            pkt = engine.send("EMSHI_GATT_FindIncludedService", 
                              ConnHandle=conn_handle,
                              ServiceStartingHandle=start_handle,
                              ServiceEndingHandle=end_handle)
            ok = pkt.response.get("status") == 0
            return ok
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-gatt.discover_all_char_descriptors:

gatt.discover_all_char_descriptors_
***********************************


    Client discover all the characteristic descriptors supported by a characteristic

    :param      engine:        The engine
    :param      conn_handle:   The connection handle
    :param      start_handle:  The characteristic starting handle
    :param      end_handle:    The characteristic ending handle
    
    :returns:   { description_of_the_return_value }
    :rtype:     { return_type_description }
    

**API usage**

.. code-block:: python

    from blengine.host.procedures.gatt import discover_all_char_descriptors

    discover_all_char_descriptors(engine, conn_handle, start_handle, end_handle)


**CLI usage**

.. code-block:: bash

    blengine run GATT.discover_all_char_descriptors [-h]
                                               conn_handle start_handle
                                               end_handle

*Positional arguments:*

:conn_handle:

    Connection Handle

:start_handle:

    Characteristic Starting Handle

:end_handle:

    Characteristic Ending Handle


options:
  -h, --help    show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @procedure(prefix="GATT.", parser=discover_all_char_descriptors_parser)
    def discover_all_char_descriptors(engine, conn_handle, start_handle, end_handle):
        '''
        Client discover all the characteristic descriptors supported by a characteristic
    
        :param      engine:        The engine
        :param      conn_handle:   The connection handle
        :param      start_handle:  The characteristic starting handle
        :param      end_handle:    The characteristic ending handle
        
        :returns:   { description_of_the_return_value }
        :rtype:     { return_type_description }
        '''
        if engine.bluetooth_host_stack == "EMB":
                    
            pkt = engine.send("EMSHI_ATTC_FindInfoReq",
                              connId=conn_handle,
                              startHandle=start_handle,
                              endHandle=end_handle,
                              continuing=True)
            
            ok = pkt.response.get("status") == 0
            return ok
        else:
            pkt = engine.send("EMSHI_GATT_GetCharacteristicDescriptorList",
                              ConnHandle=conn_handle,
                              characStartingHandle=start_handle,
                              characEndingHandle=end_handle)
            ok = pkt.response.get("status") == 0
            if ok:
                ConnHandle=pkt.response.get("ConnHandle")
                ServerDataHandle=pkt.response.get("ServerDataHandle"), 
                CharactStartingHandle=pkt.response.get("CharacStartingHandle")
                CharacEndingHandle=pkt.response.get("CharacEndingHandle")
                UUIDType=pkt.response.get("UuidType")
                uuid=pkt.response.get("UUID")
            return ok, ConnHandle, ServerDataHandle, CharactStartingHandle, CharacEndingHandle, UUIDType, uuid
    


.. raw:: html
    
    </details>
    <hr>

this page is auto generated by BLEngine/docs/procedures.py