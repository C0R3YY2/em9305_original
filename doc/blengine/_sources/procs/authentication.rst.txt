
.. this file is auto generated by BLEngine/docs/procedures.py

=============================
authentication Procedures
=============================

.. raw:: html
    
    
    <input class="search input" type="text" placeholder="Live Search" style="width: 100%; padding: 10px;">
    <div>&nbsp</div>
    <div id="search-loader" style="display:none;">please wait...</div>
    
.. _proc-write_configuration_data_nvm:

write_configuration_data_nvm_
*****************************


    Write the Configuration Data in NVM
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.authentication import write_configuration_data_nvm

    write_configuration_data_nvm(engine, em=False, private_key=None)


**CLI usage**

.. code-block:: bash

    blengine run write_configuration_data_nvm [-h] [--em]
                                         [--private_key PRIVATE_KEY]


options:
  -h, --help            show this help message and exit
  --em                  EM level
  --private_key PRIVATE_KEY
                        Private Key, optional, will look in the config file:
                        [USER_AUTH] secrete_key=0xXXXXX


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def write_configuration_data_nvm(engine, em=False, private_key=None):
        '''
        Write the Configuration Data in NVM
        '''
    
        if em is True:
            authconf = config.config["AUTH_EM"]
            configuration_data_info_page = 3
            public_keys_block_addr   = 0x407D80
            hw_lock_bits_block_addr  = 0x407D00
            flags = { "EmAuthRequired":   ( 0x407F08, 0x6A53B14D ),
                      "NvmP3Programmed":  ( 0x407F00, 0x4EA6D18B ) }
            trimming_data_block_addr = 0x407C80
            device_id_block_addr     = 0x407C40
            mac_address_block_addr   = 0x407C00
        else:
            authconf = config.config["AUTH_USER"]
            configuration_data_info_page = 2
            public_keys_block_addr   = 0x405D80
            hw_lock_bits_block_addr  = 0x405D00
            flags = { "UserAuthRequired": ( 0x405F08, 0x6A53B14D ),
                      "NvmReadLock":      ( 0x405F00, 0x4EA6D18B ) }
            trimming_data_block_addr = 0x405C80
    
        # Erase the previous configuration data.
        pkt = engine.send('EMSMM_NVM_Erase_Page', Area=1, Page=configuration_data_info_page)
        if pkt.response.get("status") != 0x00:
            return "Failed to erase the previous configuration data!"
    
        if(em is False):
            # Erase the previous private key.
            pkt = engine.send('EMSMM_NVM_Erase_Page', Area=1, Page=0)
            if pkt.response.get("status") != 0x00:
                return "Failed to erase the previous private key!"
    
            # Get the private key.
            private_key = private_key or authconf["AuthenticationPrivateKey"]
            if private_key is None:
                return "Please provide a private Key!"
            private_key = int(private_key, 0)
    
            # Write the private key.
            private_key = private_key.to_bytes(16, 'little')
            pkt = engine.send('EMSS_USER_Write_Private_Key', Private_Key=private_key)
            if pkt.response.get("status") != 0x00:
                return "Failed to write the private key!"
    
        # Write the public keys block.
        public_keys_block = bytearray()
        public_keys_block.extend(int(authconf["PatchSignaturePublicKey"][0], 0).to_bytes(32, 'little'))
        public_keys_block.extend(int(authconf["PatchSignaturePublicKey"][1], 0).to_bytes(32, 'little'))
        if(em is True):
            public_keys_block.extend(int(authconf["AuthenticationPublicKey"][0], 0).to_bytes(32, 'little'))
            public_keys_block.extend(int(authconf["AuthenticationPublicKey"][1], 0).to_bytes(32, 'little'))
        public_keys_block_length = int(len(public_keys_block) / 4)
        public_keys_block = binascii.crc32(public_keys_block).to_bytes(4, 'little') + public_keys_block
        public_keys_block = public_keys_block_length.to_bytes(4, 'little') + public_keys_block
        pkt = engine.send('EMSMM_Write_At_Address', Start_Address=public_keys_block_addr, Data=public_keys_block)
        if pkt.response.get("status") != 0x00:
            return "Failed to write the public keys block!"
    
        # Write the lock bits block.
        hw_lock_bits = [
            ( RegNvmLockMain0_ADDR,  int(authconf["RegNvmLockMain0" ], 0) ),
            ( RegNvmLockMain1_ADDR,  int(authconf["RegNvmLockMain1" ], 0) ),
            ( RegNvmLockInfo_ADDR,   int(authconf["RegNvmLockInfo"  ], 0) ),
            ( RegNvmLockMaster_ADDR, int(authconf["RegNvmLockMaster"], 0) ),
            ( RegNvmKcLockKey_ADDR,  int(authconf["RegNvmKcLockKey" ], 0) ),
            ( RegPmlLockBits_ADDR,   int(authconf["RegPmlLockBits"  ], 0) ),
        ]
        hw_lock_bits_block = bytearray()
        for hw_lock_bits_item in hw_lock_bits:
            hw_lock_bits_block.extend(hw_lock_bits_item[0].to_bytes(4, 'little'))
            hw_lock_bits_block.extend(hw_lock_bits_item[1].to_bytes(4, 'little'))
        hw_lock_bits_block_length = int(len(hw_lock_bits_block) / 4)
        hw_lock_bits_block = binascii.crc32(hw_lock_bits_block).to_bytes(4, 'little') + hw_lock_bits_block
        hw_lock_bits_block = hw_lock_bits_block_length.to_bytes(4, 'little') + hw_lock_bits_block
        pkt = engine.send('EMSMM_Write_At_Address', Start_Address=hw_lock_bits_block_addr, Data=hw_lock_bits_block)
        if pkt.response.get("status") != 0x00:
            return "Failed to write the lock bits block!"
    
        # Write the trimming data block.
        if(em is True):
            trimming_data = [
                ( RegPmlTrim_ADDR,          int(authconf["RegPmlTrim"         ], 0) ),
                ( RegNvmRedunCfg_ADDR,      int(authconf["RegNvmRedunCfg"     ], 0) ),
                ( RegNvmTime_ADDR,          int(authconf["RegNvmTime"         ], 0) ),
                ( REG_RF_XO_SEQ_DIG_ADDR,   int(authconf["REG_RF_XO_SEQ_DIG"  ], 0) ),
                ( REG_RF_XO_DEBUG_DIG_ADDR, int(authconf["REG_RF_XO_DEBUG_DIG"], 0) ),
            ]
        else:
            trimming_data = [
                ( REG_RF_XO_SEQ_DIG_ADDR,   int(authconf["REG_RF_XO_SEQ_DIG"  ], 0) ),
                ( REG_RF_XO_DEBUG_DIG_ADDR, int(authconf["REG_RF_XO_DEBUG_DIG"], 0) ),
            ]
        trimming_data_block = bytearray()
        for trimming_data_item in trimming_data:
            trimming_data_block.extend(trimming_data_item[0].to_bytes(4, 'little'))
            trimming_data_block.extend(trimming_data_item[1].to_bytes(4, 'little'))
        trimming_data_block_length = int(len(trimming_data_block) / 4)
        trimming_data_block = binascii.crc32(trimming_data_block).to_bytes(4, 'little') + trimming_data_block
        trimming_data_block = trimming_data_block_length.to_bytes(4, 'little') + trimming_data_block
        pkt = engine.send('EMSMM_Write_At_Address', Start_Address=trimming_data_block_addr, Data=trimming_data_block)
        if pkt.response.get("status") != 0x00:
            return "Failed to write the trimming data block!"
    
        if(em is True):
            # Write the Device ID block.
            device_id_block = bytearray()
            device_id_block.extend(bytes(authconf["DeviceID"], 'utf-8'))
            if (0 != len(device_id_block) % 4) or (len(device_id_block) > 56):
                return "The Device ID length shall not be greater than 56B and shall be a multiple of 4B!"
            device_id_block_length = int(len(device_id_block) / 4)
            device_id_block = binascii.crc32(device_id_block).to_bytes(4, 'little') + device_id_block
            device_id_block = device_id_block_length.to_bytes(4, 'little') + device_id_block
            pkt = engine.send('EMSMM_Write_At_Address', Start_Address=device_id_block_addr, Data=device_id_block)
            if pkt.response.get("status") != 0x00:
                return "Failed to write the Device ID block!"
    
            # Write the MAC address block.
            mac_address_block = bytearray()
            mac_address_block.extend(bytes([int(val, 16) for val in reversed(authconf["MacAddress"].split(':'))]))
            if len(mac_address_block) != 6:
                return "Invalid MAC address!"
            mac_address_block.extend(b'\x00\x00')
            mac_address_block_length = int(len(mac_address_block) / 4)
            mac_address_block = binascii.crc32(mac_address_block).to_bytes(4, 'little') + mac_address_block
            mac_address_block = mac_address_block_length.to_bytes(4, 'little') + mac_address_block
            pkt = engine.send('EMSMM_Write_At_Address', Start_Address=mac_address_block_addr, Data=mac_address_block)
            if pkt.response.get("status") != 0x00:
                return "Failed to write the MAC address block!"
    
        # Write the flags.
        for flag_name, flag in flags.items():
            if authconf[flag_name].lower() in ["true", "yes", "sure"]:
                flag_data = bytearray()
                flag_data.extend(flag[1].to_bytes(4, 'little'))
                flag_data.extend((0xFFFFFFFF - flag[1]).to_bytes(4, 'little'))
                pkt = engine.send('EMSMM_Write_At_Address', Start_Address=flag[0], Data=flag_data)
                if pkt.response.get("status") != 0x00:
                    return "Failed to write the flags!"
    
        # Success!
        return "Configuration data written successfully!"
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-authenticate:

authenticate_
*************

EMS Authentication

**API usage**

.. code-block:: python

    from blengine.hci.procedures.authentication import authenticate

    authenticate(engine, em=False, private_key=None, server_url=None)


**CLI usage**

.. code-block:: bash

    blengine run authenticate [-h] [--em] [--private_key PRIVATE_KEY]
                         [--server_url SERVER_URL]


options:
  -h, --help            show this help message and exit
  --em                  EM level
  --private_key PRIVATE_KEY
                        Private Key (0xfffffffffffffffffffffffffffffffffffffff
                        fffffffffffffffffffffffff format)
  --server_url SERVER_URL
                        URL of the Authentication Server


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def authenticate(engine, em=False, private_key=None, server_url=None):
        '''EMS Authentication'''
        log = logger.get("Authentication Procedure")
        # EM - Use Schnorr authentication.
        if(em is True):
            if config.config.get("AUTH_EM") is None:
                return False, "AUTH_EM entry not found in current config"
    
            authconf = config.config["AUTH_EM"]
            
            # Check if private key is provided as a parameter, or if authentication 
            # is performed via an Authentication Server.
    
            # if private_key is None and (("AUTH_SERVER" not in config.config or config.config["AUTH_SERVER"].get("local_test_private_key") is None)) and server_url is None and ("AUTH_SERVER" not in config.config or config.config["AUTH_SERVER"].get("auth_server_url") is not None):
            #     return "Please provide a private Key or an Authentication Server URL either via configuration file or via procedure parameters"
    
            # Generate a prover challenge and compute the commitement.
            prover_challenge = SchnorrAuthentication.generate_prover_challenge()
            commitment = SchnorrAuthentication.generate_commitment(prover_challenge)
    
            # Send the commitment and get a verifier challenge.
            commitment_x = commitment.x.to_bytes(32, 'little')
            commitment_y = commitment.y.to_bytes(32, 'little')
            pkt = engine.send('EMSS_EM_Get_Challenge', Commitment_X=commitment_x, Commitment_Y=commitment_y)
            if pkt.response.get("status") != 0x00:
                return False, "Authentication failed! canot get challenge, status %s" % pkt.status_text
            verifier_challenge = pkt.response.get("Verifier_Challenge")
            verifier_challenge = int.from_bytes(verifier_challenge, 'little')
    
            # Compute the signature.
            if private_key is None and "EM_AUTH" in config.config:
                private_key = config.config["EM_AUTH"].get("private_key")
    
            if private_key is not None:
                private_key = int(private_key, 16)
                signature = SchnorrAuthentication.generate_signature(private_key, verifier_challenge, prover_challenge)
            else:
                # Use Server
                
                if server_url is None:
                    if "EM_AUTH" in config.config:
                        server_url = config.config["EM_AUTH"].get("auth_server_url")
    
                if server_url is None:
                    return False, "URL not found, provide auth_server_url entry under EM_AUTH section in config file or with --server_url"
    
                pkt = engine.send('EMSS_EM_Read_Public_Key')
                if pkt.response.get("status") != 0x00:
                    # Must try to read key in ROM V1 via EMSMM NVM Read At Address command.
                    pkt = engine.send("EMSMM_Read_At_Address", Start_Address=0x00407D80+8+64, Data_Length=32)
                    em_akx =  pkt.response.get("Data")
                    pkt = engine.send("EMSMM_Read_At_Address", Start_Address=0x00407D80+8+96, Data_Length=32)
                    em_aky =  pkt.response.get("Data")
                    xi = int.from_bytes(em_akx, 'little')
                    yi = int.from_bytes(em_aky, 'little')
                else:
                    xi = int.from_bytes(pkt.response.get("Public_Key_X"),'little')
                    yi = int.from_bytes(pkt.response.get("Public_Key_Y"),'little')
    
                xs = '{0:064d}'.format(xi).encode('ASCII')
                ys = '{0:064d}'.format(yi).encode('ASCII')
    
                xys= xs+ys
                hxys = hashlib.sha256(xys).hexdigest()
                
                context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
                connection = http.client.HTTPSConnection(server_url, context=context)
    
                headers = {'Content-type': 'application/json'}
                auth_request16 = {
                    "schnorr":{
                        "base":"16",
                        "public_hash":hxys,
                        "verifier":hex(verifier_challenge),
                        "prover":hex(prover_challenge)
                        }
                    }
                log.info("Connecting to Key Management Service")
                json_auth_request = json.dumps(auth_request16)
                connection.request('GET', '/schnorr', json_auth_request, headers)
                response = connection.getresponse().read().decode()
                # print(response)
                rsp =json.loads(response)
                if ("schnorr" in rsp):
                    status = int(rsp["schnorr"]["status"],16)
                    if status == 0x00: # Success
                        base = int(rsp["schnorr"]["base"])
                        signature = int(rsp["schnorr"]["signature"], base)
                        product_version = rsp["schnorr"]["product_version"]
                        log.info("Signature Received from Key Management Service (Version: {0})".format(product_version))
                    else:
                        log.info("Error Received from Key Management Service ({0})".format(hex(status)))
                        return False, "Auth failed: %s(%s)" %(auth_status_def[status],hex(status))
    
            # Send the signature.
            signature = signature.to_bytes(32, 'little')
            pkt = engine.send("EMSS_EM_Authenticate", Signature=signature)
            if pkt.response.get("status") != 0x00:
                return False, "Authentication failed! status %s" % pkt.status_text
    
        # USER - Use AES authentication.
        else:
            # authconf = config.config["USER_AUTH"]
            
            # Get the private key.
            if private_key is None and "USER_AUTH" in config.config:
                private_key = config.config["USER_AUTH"].get("secrete_key")
            if private_key is None:
                return False, """Private key not found ! add --help to get help."""
    
            private_key = int(private_key, 0)
        
            # Get a verifier challenge.
            pkt = engine.send('EMSS_USER_Get_Challenge')
            if pkt.response.get("status") != 0x00:
                return False, "Authentication failed! status %s" % pkt.status_text
            verifier_challenge = pkt.response.get("Verifier_Challenge")
            verifier_challenge = int.from_bytes(verifier_challenge, 'little')
    
            # Compute the signature.
            signature = AESAuthentication.generate_signature(private_key, verifier_challenge)
    
            # Send the signature.
            signature = signature.to_bytes(16, 'little')
            pkt = engine.send("EMSS_USER_Authenticate", Signature=signature)
            if pkt.response.get("status") != 0x00:
                return False, "Authentication failed! status %s" % pkt.status_text
    
        # Success!
        return True, "Authentication succeeded!"
    


.. raw:: html
    
    </details>
    <hr>

this page is auto generated by BLEngine/docs/procedures.py