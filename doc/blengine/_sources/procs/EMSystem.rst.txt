
.. this file is auto generated by BLEngine/docs/procedures.py

=============================
EMSystem Procedures
=============================

.. raw:: html
    
    
    <input class="search input" type="text" placeholder="Live Search" style="width: 100%; padding: 10px;">
    <div>&nbsp</div>
    <div id="search-loader" style="display:none;">please wait...</div>
    
.. _proc-select_transport_dvk_device:

select_transport_dvk_device_
****************************


    Select transport DVK device

    SPI    = 0x01
    SERIAL = 0x02
    I2C    = 0x03

    DEFAULT  = 0x00
    STANDARD = 0x01
    FAST     = 0x02
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.EMSystem import select_transport_dvk_device

    select_transport_dvk_device(engine, enable=False, bus=None, mode=None)


**CLI usage**

.. code-block:: bash

    blengine run select_transport_dvk_device [-h] enable bus mode

*Positional arguments:*

:enable:

    Enable or not the transport

:bus:

    Transport Bus SPI = 0x01 SERIAL = 0x02 I2C = 0x03

:mode:

    Transport Mode DEFAULT = 0x00 STANDARD = 0x01 FAST = 0x02


options:
  -h, --help  show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def select_transport_dvk_device(engine, enable=False, bus=None, mode=None):
        '''
        Select transport DVK device
    
        SPI    = 0x01
        SERIAL = 0x02
        I2C    = 0x03
    
        DEFAULT  = 0x00
        STANDARD = 0x01
        FAST     = 0x02
        '''
    
        message = "enable:%s bus:%s mode:%s" % (enable, bus, mode)
    
        #backward compatibility
        if hasattr(engine, "device_bus"):
            bus = bus or engine.device_bus 
        if hasattr(engine, "transport_mode"):
            mode = mode or engine.transport_mode
        if isinstance(bus, str):
            bus = TRANSPORT_BUS[bus]
        if isinstance(mode, str):
            mode = TRANSPORT_MODE[mode]
        #default values 
        if bus == None:
            bus = TRANSPORT_BUS.get("SPI")
        if mode == None: 
            mode = TRANSPORT_MODE.get("DEFAULT")
    
        pkt = engine.send("DVK_Select_Transport",bus=bus , mode=mode)
        if pkt.response.get("status") == 0x01:
            if enable:
                pkt = engine.send("DVK_Set_SPI_Bus_Enable", enable=False)
            pkt = engine.send("DVK_Set_SPI_Bus_Enable", enable=enable)
    
        if pkt.response.get("status") == 0x00:
            return True, "DVK transport to the device selected " + message
        else:
            return False, "DVK transport to the device failed, error:{} response:{}".format(
                pkt.response.get("status"), pkt.status_text)
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-enter_conf_mode:

enter_conf_mode_
****************


    Enter Configuration Mode
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.EMSystem import enter_conf_mode

    enter_conf_mode(engine)


**CLI usage**

.. code-block:: bash

    No Help

.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def enter_conf_mode(engine):
        '''
        Enter Configuration Mode
        '''
        log = logger.get("Enter Configuration Mode")
        reset_ok = threading.Event()
    
        def on_startup_event(packet):
            reset_ok.set()
            log.info("STARTUP: %s" % packet.name)
    
        engine.bind("on_ENTER_EMCORE_MODE",             on_startup_event)
        engine.bind("on_ENTER_BOOTLOADER_MODE",         on_startup_event)
        engine.bind("on_ENTER_ACTIVE_MODE",           on_startup_event)
        engine.bind("on_ENTER_CONFIGURATION_MODE",    on_startup_event)
        engine.bind("on_ENTER_PRODUCTION_TESTS_MODE", on_startup_event)
    
        def run():
            reset_ok.clear()
            select_transport_dvk_device(engine, True)
    
            pkt = engine.send("DVK_Target_Hard_Reset", mode=1)
            if pkt.response.get("status") == 0x00:
                log.info("Target Hard Reset successfull")
            else:
                return False
            return reset_ok.wait(1.0)
    
        status = run()
    
        engine.unbind("on_ENTER_EMCORE_MODE",             on_startup_event)
        engine.unbind("on_ENTER_BOOTLOADER_MODE",         on_startup_event)
        engine.unbind("on_ENTER_ACTIVE_MODE", on_startup_event)
        engine.unbind("on_ENTER_CONFIGURATION_MODE", on_startup_event)
        engine.unbind("on_ENTER_PRODUCTION_TESTS_MODE", on_startup_event)
    
        message = "Active Mode: Successfull" if status else "Active Mode: Failure" 
    
        return status, message
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-write_hex:

write_hex_
**********

Write hex file to NVM

**API usage**

.. code-block:: python

    from blengine.hci.procedures.EMSystem import write_hex

    write_hex(engine, file, address=None, progress=False, fast=False, force_empty=False, without_response=False, timeout=20, retry=0)


**CLI usage**

.. code-block:: bash

    blengine run write_hex [-h] [--address ADDRESS] [--fast] [--progress]
                      [--force_empty] [--without_response]
                      file

*Positional arguments:*

:file:

    hex file


options:
  -h, --help          show this help message and exit
  --address ADDRESS   Start address
  --fast              write really fast, can induce issues
  --progress          Show Progress
  --force_empty       Force empty lines to be written
  --without_response  Use the command Write At Address Without Response


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def write_hex(engine, file, address=None, progress=False, fast=False,
                  force_empty=False, without_response=False, timeout=write_hex_timeout, retry=0):
        '''Write hex file to NVM'''
    
        log = logger.get("WriteHEX")
    
        write_cmd = "EMSMM_Write_At_Address_Without_Response" if without_response \
            else "EMSMM_Write_At_Address"
    
        nvm_conf, address, swap_size, empty_char = nvm_check_configuration(
            engine, address)
        
    
        if file is None:
            return False, "Error: No file provided, quit."
    
        log.info("Writing file %s at 0x%08x " % (file.name, address))
    
        # Open hex file
        hexFile = file
    
        lines = []
        total_size = 0
    
        packet_size = nvm_conf["packet_size"]
        file_line_size = nvm_conf["file_line_size"]
    
        for line in hexFile:
            end_of_segment = False
            data = line.replace(' ', '')
            data = data.replace('\n', '')
            if '//' not in data and '@' not in data and data != '':
                lines.append(data)
                if empty_char*(file_line_size*2) not in data:
                    total_size += file_line_size
    
        buff = bytearray()
    
        total_sent = 0
        start = time.perf_counter()
        next_address = address
        for line in lines:
            end_of_segment = False
            data = line.replace(' ', '')
            data = data.replace('\n', '')
            if '//' not in data and '@' not in data and data != '':
                # Do not write empty lines (except if explicitly required).
                if empty_char*(file_line_size*2) not in data or force_empty:
                    data = SwapeUtils.swap(swap_size, data, file_line_size)
                    if data == None:
                        return "Error: swape incorrect."
                    buff.extend(data)
                else:
                    end_of_segment = True
    
                if len(buff) >= packet_size or end_of_segment is True:
                    size_to_send = min(packet_size, len(buff))
                    if (size_to_send > 0):
                        engine.send(write_cmd,
                                    wait_ack=not fast and not without_response,
                                    retry=retry,
                                    Start_Address=next_address,
                                    Data=buff[:size_to_send])
    
                        total_sent = total_sent + size_to_send
                        next_address = next_address + size_to_send
                        buff = buff[size_to_send:]
                        if callable(progress):
                            progress(total_sent, total_size)
                        elif progress is True:
                            print("sending %d %%" % ((total_sent / total_size ) * 100), end="\r")
    
                    if end_of_segment is True:
                        next_address = next_address + file_line_size
    
        if len(buff) > 0:
            engine.send(write_cmd,
                        wait_ack=not fast and not without_response,
                        retry=retry,
                        Start_Address=next_address,
                        Data=buff)
            total_sent = total_sent + len(buff)
            if callable(progress):
                progress(total_sent, total_size)
            elif progress is True:
                print("sended %s %% ( %s/%s Bytes)" % (total_sent / total_size ) * 100, end="\r" )
        
        # erase
        print("Sended %s/%s Bytes" % (total_sent, total_size))
        
        end = time.perf_counter()
        hexFile.close()
    
        # Be sure all the Command Complete have been received when using fast mode.
        if fast or without_response:
            if progress and not without_response:
                print("please wait...")
            pkt = engine.send("EMSMM_Read_At_Address",
                              wait_ack=True, timeout=timeout,
                              Start_Address=address, Data_Length=4)
            if pkt.response.get("status") != 0x00:
                return False, "Timeout waiting for all commands to timeout"
            else:
                print("Success    ")
        return True, "Upload successful Sent {:d} bytes (of {:d}) in {:3.4f} seconds".format(total_sent, total_size, (end-start))
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-write_and_check_ihex:

write_and_check_ihex_
*********************

Write intel hex file to NVM and check CRC

**API usage**

.. code-block:: python

    from blengine.hci.procedures.EMSystem import write_and_check_ihex

    write_and_check_ihex(engine, file, progress=False, fast=False, without_response=False, check=False)


**CLI usage**

.. code-block:: bash

    blengine run write_and_check_ihex [-h] [--fast] [--progress]
                                 [--without_response]
                                 file

*Positional arguments:*

:file:

    ihex file


options:
  -h, --help          show this help message and exit
  --fast              Do not wait the Command Complete Events.
  --progress          Show Progress
  --without_response  Use the command Write At Address Without Response


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def write_and_check_ihex(engine, file, progress=False, fast=False, without_response=False, check=False):
        '''Write intel hex file to NVM and check CRC'''
    
        log = logger.get("write_and_check_ihex")
        log.info(f"Intel hex file to program: '{file.name}'")
    
        write_cmd = "EMSMM_Write_At_Address_Without_Response" if without_response else "EMSMM_Write_At_Address"
    
        start = time.perf_counter()
    
        nvm_config = get_nvm_configuration(engine)
    
        log.info("Parsing file...")
    
        # Parse the ihex file.
        try:
            ihex = parse_ihex_file(file)
            
            file.close()
        except Exception as e:
            file.close()
            log.error(e)
            return False, e
    
        log.info("Checking CRC32...")
        already_programmed = True
        for addr, data in ihex:
            end = addr + len(data)
            pkt = engine.send("EMSG_Calculate_CRC32",
                              Start_Address=addr, End_Address=end)
            if pkt.response.get("status") == 0x00:
                actual_crc = pkt.response.get("CRC32")
                expected_crc = binascii.crc32(data)
                if actual_crc != expected_crc:
                    already_programmed = False
            else:
                log.info("CRC Calculation error : %s" % pkt)
                already_programmed = False
        
        if already_programmed:
            msg = "File Already Programmed"
            log.info(msg)
            return True, msg
    
        # Check if the ihex is already programmed on the device.
        if check:
            log.info("Checking emcore compliance...")
            file_header_ok, file_headers = get_fw_headers(engine, ihex=ihex, output=False)
            device_header_ok, device_headers = get_fw_headers(engine, output=False)
    
            compliant = False
            if file_header_ok and device_header_ok:
                fh = file_headers[0]
                if fh.get("section_code") == 0x03 and fh.get("fw_flavor") > 0 and fh.get("fw_stack") > 0:
                    for dh in device_headers:
                        if dh.get("section_code") == 0x01:
                            if dh.get("fw_flavor") != fh.get("fw_flavor"):
                                return False, "Wrong EMCore flavor, ihex ask for %s, device have %s" % (fh.get("fw_flavor"), dh.get("fw_flavor"))
                            if dh.get("fw_stack") != fh.get("fw_stack"):
                                return False, "Wrong EMCore Stack, ihex ask for %s, device have %s" % (fh.get("fw_stack"), dh.get("fw_stack"))
                            compliant = True
                    if compliant is False:
                        print(device_headers)
                        return False, "IHEX need EmCore flavor %s stack %s" % (dh.get("fw_flavor"), dh.get("fw_stack"))
    
        else:
            log.info("Skipping emcore compliance check.")
    
        log.info("Erasing pages...")
        # erase pages and compute total size
        for addr, data in ihex:
            status, mem_infos = get_memory_infos_from_address(nvm_config, addr)
            if status is True and mem_infos["area"] is not None:
                # Check which NVM pages have to be erased.
                start_page = (addr - mem_infos["base_addr"]) // 0x2000
                end_page = ((addr - mem_infos["base_addr"]) + len(data) - 1) // 0x2000
                for page in range(start_page, end_page + 1):
                    pkt = engine.send("EMSMM_NVM_Erase_Page", Area=mem_infos["area"], Page=page)
                    if pkt.response.get("status") != 0x00:
                        msg = "Error while erasing page %s (0x%x): %s" % (page, addr, pkt)
                        log.error(msg)
                        return False, msg
    
            log.debug("0x{:08x}: {:d} bytes".format(addr, len(data)))
    
    
        total_size = 0
    
        log.info("Correcting data length for device memory compliance...")
        for addr, data in ihex:
            status, mem_infos = get_memory_infos_from_address(nvm_config, addr)
            if status is True:
                if len(data) % mem_infos["swap_size"] != 0:
                    size = mem_infos["swap_size"] - (len(data) % mem_infos["swap_size"])
                    data.extend([0xFF] * size)
    
                total_size += len(data)
    
                log.debug(f'data size for area {mem_infos["name"]} is {mem_infos["swap_size"]} bytes')
    
        # Write data.
        log.info("Writing data...")
        packet_size = nvm_config["packet_size"]
        total_sent = 0
        for addr, data in ihex:
            while len(data) > 0:
                size_to_send = min(packet_size, len(data))
    
                pkt = engine.send(write_cmd,
                                  wait_ack=not fast and not without_response,
                                  Start_Address=addr,
                                  Data=data[:size_to_send])
    
                if not fast and not without_response and pkt.response.get("status") != 0x00:
                    msg = "Communication error."
                    log.error(msg)
                    return False, msg
    
                addr += size_to_send
                data = data[size_to_send:]
                total_sent += size_to_send
    
                if callable(progress):
                    progress(total_sent, total_size)
                elif progress is True:
                    print("Sending %d %%" % ((total_sent / total_size ) * 100), end="\r")
    
        # Be sure all the Command Complete have been received when using fast mode.
        if fast or without_response:
            if progress and not without_response:
                print("Waiting all Command Complete...", end="\r")
            pkt = engine.send("EMSMM_Read_At_Address",
                              wait_ack=True, timeout=10,
                              Start_Address=ihex[0][0], Data_Length=4)
            if pkt.response.get("status") != 0x00:
                msg = "Communication error."
                log.error(msg)
                return False, msg
    
        # Check data.
        log.info("Checking data...")
        for addr, data in ihex:
            pkt = engine.send("EMSG_Calculate_CRC32",
                              Start_Address=addr, End_Address=addr + len(data))
            if pkt is None or pkt.response.get("status") != 0x00:
                msg = "Failed to calculate CRC32"
                log.error(msg)
                return False, msg
            actual_crc = pkt.response.get("CRC32")
            expected_crc = binascii.crc32(data)
            if actual_crc != expected_crc:
                msg = "Invalid CRC32 from 0x{:08x} to 0x{:08x} (0x{:08x} instead of 0x{:08x})".format(
                    addr, addr + len(data), actual_crc, expected_crc)
                log.error(msg)
                return False, msg
    
        end = time.perf_counter()
    
        msg = "Successfully written {:d} bytes (of {:d}) in {:.3f} seconds".format(
            total_sent, total_size, end - start)
        log.info(msg)
        return True, msg
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-emsystem_write_hex:

emsystem_write_hex_
*******************

emsystem Write hex file to NVM

**API usage**

.. code-block:: python

    from blengine.hci.procedures.EMSystem import emsystem_write_hex

    emsystem_write_hex(engine, files=None, directory=None, address=None, spi_disable=False, return_address=False, progress=False, timeout=20, fast=True, without_response=True, retry=0, check=False)


**CLI usage**

.. code-block:: bash

    blengine run emsystem_write_hex [-h] [--files FILES [FILES ...]]
                               [--directory DIRECTORY] [--address ADDRESS]
                               [--spi_disable] [--return_address]


options:
  -h, --help            show this help message and exit
  --files FILES [FILES ...]
                        hex file(s)
  --directory DIRECTORY
                        The directory where the files are located
  --address ADDRESS     Memory Address 0xXX..
  --spi_disable         Disable SPI configure mode
  --return_address      Read the bluetooth address of the device before
                        programming. The value is stored in the engine
                        parameter local_address


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def emsystem_write_hex(engine, files=None, directory=None, address=None, spi_disable=False, 
                           return_address=False, progress=False, timeout=write_hex_timeout, 
                           fast=True, without_response=True, retry=0, check=False):
        '''emsystem Write hex file to NVM'''
    
        log = logger.get("emsystem_write_hex")
    
        reset_ok = threading.Event()
    
        files_ext = None
        for f in list(files):
            ext = os.path.splitext(f)[1][1:]
            if files_ext is None:
                files_ext = ext
            elif files_ext != ext:
                return False, "All files must have the same extension"
    
        log.info("Files type: %s" % files_ext)
    
    
        def run():
    
            engine.device_mode_event.clear()
    
            select_transport_dvk_device(engine, True)
    
            if return_address:
                pkt = engine.send("EMSG_Read_MAC_Address")
                if pkt.response.get("status") == 0x00:
                    log.info("Read BD ADDR successfull")
                    engine.local_address = pkt.response.get("MAC")
                elif pkt.response.get("status") == 0x03:
                    log.info("No BD ADDR")
                    engine.local_address = None
                else:
                    return False, "Failed to read the mac address, is infopage 3 populated ? response %s" % pkt.status_text
    
            pkt = engine.send("DVK_Target_Hard_Reset", mode=1)
            
            if not engine.device_mode_event.wait(1):
                return False, "Hard Reset timeout, startup packet missed ?"
    
            if pkt.response.get("status") == 0x00:
                log.info("Target Hard Reset successfull")
            else:
                return False, "Cannot hard reset the device %s" % pkt.status_text
            if files_ext != "ihex":
                pkt = engine.send("EMSMM_NVM_Erase_Main")
                if pkt.response.get("status") == 0x00:
                    log.info("NVM Erase Main successfull")
                else:
                    return False, "Cannot erase Main NVM Area"
    
            status = False
            status_message = "Programming firmware started"
            for f in list(files):
                if directory:
                    f = Path(directory) / f
                with open(f) as fo:
                    log.info("Programming firmware %s..." % f)
                    status = False
                    if files_ext != "ihex":
                        status, status_message = write_hex(engine, fo, 
                                                        address=address, 
                                                        progress=progress, 
                                                        fast=fast, 
                                                        without_response=without_response, 
                                                        timeout=timeout,
                                                        retry=retry)
    
                        check_status, check_msg = check_hex(engine, open(f))
    
                        if check_status is False:
                            return check_status, "check_hex error: %s" % check_msg 
                    else:
                        status, status_message = write_and_check_ihex(engine, fo, 
                                                    progress=progress, 
                                                    fast=fast, 
                                                    without_response=without_response,
                                                    check=check)
                    if status == False:
                        return False, "Write Failure: %s" % status_message
    
            engine.device_mode_event.clear()
            pkt = engine.send("DVK_Target_Hard_Reset", mode=0)
    
            if not engine.device_mode_event.wait(1):
                log.info('''Hard Reset Timeout, startup packet missed.
                            But It is possible that the application does not send the event.''')
    
            if pkt.response.get("status") == 0x00:
                log.info("Target Hard Reset successfull")
            else:
                return False, "Cannot hard reset the device %s" % pkt.status_text
            
            if engine.device_mode == "emshi":
                log.info("Device in EMSHI mode")
                engine.detect_fw_stack()
    
            if spi_disable:
                select_transport_dvk_device(engine, False)
    
            return status, status_message
    
        status, status_message = run()
    
        return status, status_message
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-emsystem_prog:

emsystem_prog_
**************

prog file(s) to the device

**API usage**

.. code-block:: python

    from blengine.hci.procedures.EMSystem import emsystem_prog

    emsystem_prog(engine, files=None, directory=None, address=None, version_check=None, spi_disable=False, return_address=False, progress=False, timeout=20, fast=True, without_response=None, retry=0, check=False)


**CLI usage**

.. code-block:: bash

    blengine run emsystem_prog [-h] [--directory DIRECTORY] [--address ADDRESS]
                          [--version_check VERSION_CHECK] [--spi_disable]
                          [--return_address] [--progress] [--slow]
                          [--check-emcore]
                          files [files ...]

*Positional arguments:*

:files:

    hex file(s)


options:
  -h, --help            show this help message and exit
  --directory DIRECTORY
                        The directory where the files are located
  --address ADDRESS     Memory Address 0xXX..
  --version_check VERSION_CHECK
                        9304 ONLY. Check that the indicated version is the
                        same as the current version of the device. If it is
                        the same version, it is not programmed again. If the
                        device does not have a version or the version is
                        different, the device is programmed with the version
                        indicated
  --spi_disable         Disable SPI configure mode
  --return_address      Read the bluetooth address of the device before
                        programming. The value is stored in the engine
                        parameter local_address
  --progress            Show Progress
  --slow                Slow but secure programming (ack every packets)
  --check-emcore        Enable EMCore compliance check. ihex only.


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def emsystem_prog(engine, files=None, directory=None, address=None, version_check=None, 
                      spi_disable=False, return_address=False, progress=False, timeout=write_hex_timeout,
                      fast=True, without_response=None, retry=0, check=False):
        '''prog file(s) to the device'''
        if engine.device_model == Ic_Id_t.EM9304.name:
            wp = EM9304_Write_Patch(engine,
                                    directory=directory,
                                    destination_memory=address,
                                    version=version_check,
                                    spi_disable=spi_disable,
                                    read_address=return_address
                                    )
            status_wp = wp.Start(files)
            status = (status_wp == 0)
            message_status = "Write Patch Success" if status else "Error in Write Patch: {}".format(
                status_wp)
            return status, message_status
    
        else:
            return emsystem_write_hex(engine,
                                      files=files,
                                      directory=directory,
                                      address=address,
                                      progress=progress,
                                      spi_disable=spi_disable,
                                      return_address=return_address,
                                      timeout=timeout,
                                      fast=fast,
                                      without_response=without_response,
                                      retry=retry,
                                      check=check
                                      )
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-check_hex:

check_hex_
**********

Check hex file to NVM/IRAM

**API usage**

.. code-block:: python

    from blengine.hci.procedures.EMSystem import check_hex

    check_hex(engine, file, address=None)


**CLI usage**

.. code-block:: bash

    No Help

.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def check_hex(engine, file, address=None):
        '''Check hex file to NVM/IRAM'''
    
        nvm_conf, address, swap_size, _ = nvm_check_configuration(engine, address)
    
        if file is None:
            return False, "Error: No file provided, quit."
    
        # Open hex file
        hexFile = file
    
        file_line_size = 32
    
        buff = bytearray()
    
        for line in hexFile:
            data = line.replace(' ', '')
            data = data.replace('\n', '')
            if '//' not in data and '@' not in data and data != '':
                data = SwapeUtils.swap(swap_size, data, file_line_size)
                if data == None:
                    return False, "Swap error for paremeters %s %s %s" % (swap_size, data, file_line_size)
                buff.extend(data)
    
        hexFile.close()
    
        pkt = engine.send("EMSG_Calculate_CRC32",
                          Start_Address=address, End_Address=address+len(buff))
        if pkt is None or pkt.response.get("status") != 0x00:
            return False, "Device Failed to calculate CRC32, response %s" % pkt.status_text
    
        if pkt.response.get("CRC32") != binascii.crc32(buff):
            return False, "CRC32 mismatch (0x%08x instead of 0x%08x), quit." % (pkt.response.get("CRC32"), binascii.crc32(buff))
    
        return True, "OK: CRC32 match (0x%08x)." % (pkt.response.get("CRC32"))
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-emsmm_read_register:

emsmm_read_register_
********************


    EMSystem Read Register Procedure
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.EMSystem import emsmm_read_register

    emsmm_read_register(engine, address, length=4)


**CLI usage**

.. code-block:: bash

    blengine run emsmm_read_register [-h] [--length LENGTH] address

*Positional arguments:*

:address:

    address (hex format: 0x12345678)


options:
  -h, --help       show this help message and exit
  --length LENGTH  length to read


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def emsmm_read_register(engine, address, length=4):
        '''
        EMSystem Read Register Procedure
        '''
        if isinstance(address, str):
            address = parse_str_input_value(address)
    
        pkt = engine.send("EMSMM_Read_At_Address",
                          Start_Address=address, Data_Length=length)
    
        if pkt.response.get("status") > 0:
            return False, "Failed to read register@%x: %s" % (address, pkt.status_text)
    
        return "0x" + format(pkt.response.hex("Data", "big"))
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-emsmm_write_register:

emsmm_write_register_
*********************


    EMSMM Write Register Procedure
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.EMSystem import emsmm_write_register

    emsmm_write_register(engine, address='0xF0000000', value='0x00000000')


**CLI usage**

.. code-block:: bash

    blengine run emsmm_write_register [-h] address value

*Positional arguments:*

:address:

    address (hex format: 0x12345678)

:value:

    value (hex format: 0x12345678)


options:
  -h, --help  show this help message and exit


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def emsmm_write_register(engine, address="0xF0000000", value="0x00000000"):
        '''
        EMSMM Write Register Procedure
        '''
    
        if isinstance(address, str):
            address = parse_str_input_value(address)
    
        if isinstance(value, str):
            value = parse_str_input_value(value)
    
        #print("Writing %s at %s" % (hex(value), hex(address)))
        pkt = engine.send("EMSMM_Write_At_Address",
                          Start_Address=address, Data=value.to_bytes(4, 'little'))
    
        if pkt.response.get("status") > 0:
            return False, "Failed to write register@%x: %s" % (address, pkt.status_text)
    
        return True, pkt.status_text
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-write_raw:

write_raw_
**********


    Write raw data from binary file to NVM/IRAM
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.EMSystem import write_raw

    write_raw(engine, file, address='0x320000', progress=False, fast=False)


**CLI usage**

.. code-block:: bash

    blengine run write_raw [-h] [--address ADDRESS] [--fast] [--progress] file

*Positional arguments:*

:file:

    raw file


options:
  -h, --help         show this help message and exit
  --address ADDRESS  Start address
  --fast             write really fast, can induce issues
  --progress         Show Progress


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def write_raw(engine, file, address='0x320000', progress=False, fast=False):
        '''
        Write raw data from binary file to NVM/IRAM
        '''
        log = logger.get("Write RAW")
    
        status, address, _, _ = nvm_check_configuration(engine, address)
        if status != 0:
            return False, "Error: Address out of range, quit."
    
        if file is None:
            return False, "Error: No file provided, quit."
    
        log.info("Writing file %s at %s " % (file.name, address))
    
        # Open hex file
        rawFile = file
    
        next_address = address
        total_sent = 0
        packet_size = 248
    
        start = time.perf_counter()
    
        buff = bytearray(rawFile.read())
    
        while len(buff) > 0:
            size_to_send = min(packet_size, len(buff))
            if (size_to_send > 0):
                pkt = engine.send("EMSMM_Write_At_Address",
                                  wait_ack=not fast,
                                  Start_Address=next_address,
                                  Data=buff[:size_to_send]
                                  )
    
                total_sent = total_sent + size_to_send
    
                buff = buff[size_to_send:]
                if progress:
                    print("sent: " + str(total_sent) + "B", end="\r")
    
                next_address = next_address + size_to_send
    
        end = time.perf_counter()
        rawFile.close()
    
        return True, "Successfully uploaded, Sent {:d} bytes in {:3.4f} seconds".format(total_sent, (end-start))
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-power_cycle:

power_cycle_
************


    This procedure requires a DVK as the DVK_Target_Hard_Reset is 
    processed by the main CPU of the DVK.
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.EMSystem import power_cycle

    power_cycle(engine, mode='', auth='')


**CLI usage**

.. code-block:: bash

    blengine run power_cycle [-h] [-m {default,config}]


options:
  -h, --help            show this help message and exit
  -m {default,config}, --mode {default,config}
                        Power cycle mode


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def power_cycle(engine, mode="", auth=""):
        '''
        This procedure requires a DVK as the DVK_Target_Hard_Reset is 
        processed by the main CPU of the DVK.
        '''
        if len(auth) > 0:
            response = authenticate(engine, em = auth == "em")
            if response[0] is False:
                return response
    
        engine.device_mode_event.clear()
    
        select_transport_dvk_device(engine, True)
    
        logger.get("Power Cycle").debug("Power cycling in %s mode..." % mode)
    
        engine.send("DVK_Target_Hard_Reset", mode=POWERCYCLE_MODES.get(mode.lower()))
    
        ok = engine.device_mode_event.wait(1)
    
        if ok:
            if mode != "default":
                if engine.device_mode == mode:
                    return True, "Successfully power cycle in %s mode" % engine.device_mode
                else:
                    return False, "Fail, power cycle in %s instead of %s mode!" % (engine.device_mode, mode)
            else:
                return True, "Restarted in %s mode" % engine.device_mode
        else:
            return False, "No startup event received"
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-restart:

restart_
********


    Restart the system in a given mode 
    Supported Modes: EMCore, Application, Bootloader or Configuration Mode.
    
    Authentication procedure is available as an option.
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.EMSystem import restart

    restart(engine, mode, auth='')


**CLI usage**

.. code-block:: bash

    blengine run restart [-h] [-m {default,emcore,bootloader,active,config}]
                    [-a AUTH]


options:
  -h, --help            show this help message and exit
  -m {default,emcore,bootloader,active,config}, --mode {default,emcore,bootloader,active,config}
                        Mode to execute
  -a AUTH, --auth AUTH  Authentication level: eigher "user" or "em"


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def restart(engine, mode, auth=""):
        '''
        Restart the system in a given mode 
        Supported Modes: EMCore, Application, Bootloader or Configuration Mode.
        
        Authentication procedure is available as an option.
        '''
    
        if len(auth) > 0:
            response = authenticate(engine, em = auth == "em")
            if response[0] is False:
                return response
    
        logger.get("restart").info(f"Restarting in {mode} mode...")
    
        mode_register_address = 0x00F00430
    
        mode_register_mask = 0xFF7CFFFF
    
        # should it test for current device_mode ?? 
    
        engine.device_mode_event.clear()
    
        if mode == "config":
            engine.send("EMSG_Enter_Configuration_Mode")
        elif mode == "default":
            packet = engine.send("EMSG_Leave_Configuration_Mode")
            if packet.response.get("status") != 0x00:
                # This means we were not in CM, so we have to clear 
                # PML register and restart.
                packet = engine.send("EMSG_Clear_Mode_Flags")
        else:
            # The EMSG_Set_Boot_Mode_Flags performs a CPU Reset
            # after PML Register configuration.
            # There is no need to issue the EMSG_CPU_Reset command.
            packet = engine.send("EMSG_Set_Boot_Mode_Flags", Boot_Mode=RESTART_MODES.get(mode))
    
            if packet.response.get("status") == 0x01: 
                # Unknown HCI Command -> We are running from a firmware that does not support this command.
                logger.get("restart").info("Running firmware does not support EMSG_Set_Boot_Mode_Flags, restart in Configuration Mode and update registers.")
    
                packet = engine.send("DVK_Target_Hard_Reset", mode=1)
    
                if packet.response.get("status") > 0:
                    return False, "Failed to execute DVK_Target_Hard_Reset: %s" % packet.status_text
    
                packet = engine.send("EMSMM_Read_At_Address",
                    Start_Address=mode_register_address, Data_Length=4)
    
                if packet.response.get("status") > 0:
                    # Insufficient Authentication
                    return False, "Read register error@%x: %s" % (mode_register_address, packet.status_text)
    
                register_value = int.from_bytes(packet.response.get("Data"), "little")
                # clear application mode flags and configuration mode flag
                register_value &= mode_register_mask
                
                register_value |= RESTART_MODES.get(mode) << 16
    
                logger.get("restart").info("Write %s @ %x"% ( hex(register_value), mode_register_address))
    
                packet = engine.send("EMSMM_Write_At_Address",
                    Start_Address=mode_register_address,
                    Data=register_value.to_bytes(4,"little"))
    
                if packet.response.get("status") > 0:
                    return False, "Failed to write register @%x: %s" % (mode_register_address, packet.status_text)
    
                engine.device_mode_event.clear()
                
                logger.get("restart").info("Sending CPU Reset")
    
                packet = engine.send("EMSG_CPU_Reset")
    
        # wait on a mode event for 1 sec
        if engine.device_mode_event.wait(1):
            # default mode is any device mode
            if mode != "default":
                if engine.device_mode == mode:
                    return True, "Successfully restarted in %s mode" % engine.device_mode
                else:
                    return False, "Fail, restarted in %s instead of %s mode!" % (engine.device_mode, mode)
            else:
                return True, "Restarted in %s mode" % engine.device_mode
        else:
            # no mode event timeout is accepted
            return True, "Mode changed, but no startup event received"
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-get_fw_headers:

get_fw_headers_
***************


    search and decode headers in page 3
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.EMSystem import get_fw_headers

    get_fw_headers(engine, ihex_file='', address=3145728, ihex=None, output=True)


**CLI usage**

.. code-block:: bash

    blengine run get_fw_headers [-h] [-f IHEX_FILE] [-a ADDRESS]


options:
  -h, --help            show this help message and exit
  -f IHEX_FILE, --ihex_file IHEX_FILE
                        File to analyze
  -a ADDRESS, --address ADDRESS
                        Start Address


.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def get_fw_headers(engine, ihex_file="", address=0x00300000, ihex=None, output=True):
        '''
        search and decode headers in page 3
        '''
        block_size = 0x1000
    
        addr_start = address
    
        addr_stop = address + 128 * block_size
    
        magic_bytes = bytearray([0x46, 0x48, 0x44, 0x52])
    
        headers = []
    
        current_page = 0
    
        if len(ihex_file) > 0:
            with open(ihex_file) as fo:
                ihex = parse_ihex_file(fo)
    
        if ihex is not None:
            ihex = { x: y for x, y in ihex }
            address = 0x0
            addr_stop = list(ihex.keys())[-1]
    
        while address < addr_stop:
            jump = block_size
            tmp_data = None
            current_page = int( ( address - addr_start ) / 0x2000 )
    
            if ihex is not None:
                tmp_data = ihex.get(address, None)
            else:
                pkt = engine.send("EMSMM_Read_At_Address", Start_Address=address, Data_Length=6)
                tmp_data = pkt.response.get("Data")
    
            if tmp_data is not None and len(tmp_data) >= 6:
                [ magic, version, length ] = struct.unpack_from("4sBB", tmp_data[:6])
    
                if magic == magic_bytes:
                    if ihex is not None:
                        header = tmp_data[:length]
                    else:
                        pkt = engine.send("EMSMM_Read_At_Address", Start_Address=address, Data_Length=length)
                        header = pkt.response.get("Data")
    
                    fw_header = fw_header_pkt.clone()
                    fw_header.decode(header)
    
                    fw_crc = False
    
                    if ihex is None:
                        pkt = engine.send("EMSG_Calculate_CRC32", 
                                    Start_Address=fw_header.get("fw_start_addr"), 
                                    End_Address=fw_header.get("fw_start_addr") + fw_header.get("fw_size")
                                )
                        fw_crc = pkt.response.get("CRC32")
                    else:
                        fw_crc = binascii.crc32(tmp_data[length:length+fw_header.get("fw_size")])
    
                    fw_header = decode_fw_header(header, fw_crc)
    
                    headers.append(fw_header)
    
                    if output:
                        section_code = SECTION_CODES.get(fw_header.get("section_code"), "unknown")
    
                        fw_version = "%s.%s" % (fw_header.get("fw_version")[1], 
                                                fw_header.get("fw_version")[0])
    
                        #print("fw_flavor: %s, fw_stack" % (fw_flavor, fw_stack))
    
                        print("╭─────────────────────────────")
                        print(" Header at 0x%x (Page %s)" % (address, current_page))
                        print(" Version %s" % version)
                        print(" CRC %s" % fw_header.get("header_crc_ctrl"))
                        print(" Length %s bytes" % length)
                        print(" End at 0x%x" % (address + length))
                        print(" ")
                        print(" --- Firmware Infos ---")
                        print(" Type %s (0x%x)" % (section_code, fw_header.get("section_code")))
                        print(" Version %s" % fw_version)
                        print(" Flavor %s (%s)" % (
                                EMCORE_FLAVORS.get(fw_header.get("fw_flavor")), 
                                fw_header.get("fw_flavor"))
                                )
                        print(" Stack %s (%s)" % (
                                HOST_STACK.get(fw_header.get("fw_stack")), 
                                fw_header.get("fw_stack"))
                                )
                        print(" Raw Options 0x%s" % fw_header.get("fw_options").hex())
                        print(" CRC %s" % fw_header.get("fw_crc_ctrl"))
                        print(" Start at 0x%x" % fw_header.get("fw_start_addr"))
                        print(" Size %s bytes" % fw_header.get("fw_size"))
                        print(" Exec addr 0x%x" % fw_header.get("fw_exec_addr"))
                        print(" EMCore CRC 0x%x" % fw_header.get("emcore_crc"))
                        print("")
                        print(" End at 0x%x" % fw_header.get("fw_end_addr"))
                        print("╰─────────────────────────────")
                        print("")
    
                    jump = length + fw_header.get("fw_size")
    
            address = address + jump - ( address % block_size )
        
        return len(headers) > 0, headers
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-get_rom_version:

get_rom_version_
****************


    Get the ROM version informations.

    This procedure will search in the nvm config files for a nvm_infos_addr and nvm_infos_crc32.
    If thoses are found, it can then deduce the model and the device iteration from the nvm config file.
    In any case it will parse the rom version as defined below :
        SET(FAB_VERSION         "revG") # revision (max 4 characters)
        SET(RELEASE_DATE        1323)   # date (i.e. W41 2022 = 4122)
        SET(ROM_VERSION_MAJOR   4)      # ROM SW version 4.0
        SET(ROM_VERSION_MINOR   0)      #
        SET(ROM_GIT_TAG         "rom/v4.0") # Git tag indicating this release (max 20 characters)

    This method return a dictionary.

    The implementation is in platform.py (backward compatibility).
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.EMSystem import _get_rom_version

    _get_rom_version(engine, raw=False)


**CLI usage**

.. code-block:: bash

    No Help

.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    def _get_rom_version(engine, raw=False):
        '''
        Get the ROM version informations.
    
        This procedure will search in the nvm config files for a nvm_infos_addr and nvm_infos_crc32.
        If thoses are found, it can then deduce the model and the device iteration from the nvm config file.
        In any case it will parse the rom version as defined below :
            SET(FAB_VERSION         "revG") # revision (max 4 characters)
            SET(RELEASE_DATE        1323)   # date (i.e. W41 2022 = 4122)
            SET(ROM_VERSION_MAJOR   4)      # ROM SW version 4.0
            SET(ROM_VERSION_MINOR   0)      #
            SET(ROM_GIT_TAG         "rom/v4.0") # Git tag indicating this release (max 20 characters)
    
        This method return a dictionary.
    
        The implementation is in platform.py (backward compatibility).
        '''
        restart(engine, "config")
    
        return get_rom_version(engine, raw)
    


.. raw:: html
    
    </details>
    <hr>

.. _proc-erase_main:

erase_main_
***********


    Erase NVM Main Area 
    

**API usage**

.. code-block:: python

    from blengine.hci.procedures.EMSystem import erase_main

    erase_main(engine)


**CLI usage**

.. code-block:: bash

    No Help

.. raw:: html

   <details>
   <summary><a>Show Procedure Source Code</a></summary>

.. code-block:: python

    @storage.procedure()
    def erase_main(engine):
        """
        Erase NVM Main Area 
        """
        restart(engine, "config")
        
        pkt = engine.send("EMSMM_NVM_Erase_Main")
    
        ok = (pkt.response.get("status") == 0x00)
    
        return ok, pkt.status_text
    


.. raw:: html
    
    </details>
    <hr>

this page is auto generated by BLEngine/docs/procedures.py