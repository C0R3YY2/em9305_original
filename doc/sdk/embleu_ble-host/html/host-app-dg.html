<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BLE Application Developer’s Guide &mdash; em|bleu ble-host 1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=665bc78d" />
      <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=eafc0fe6" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=e6d2ae3a" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=29a6c3e3"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: LightSlateGray" >

          
          
          <a href="index.html" class="icon icon-home">
            em|bleu ble-host
              <img src="_static/logo_h_small.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="host-api.html">BLE Host API</a></li>
<li class="toctree-l1"><a class="reference internal" href="host-dg.html">BLE Host Developer’s Guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: LightSlateGray" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">em|bleu ble-host</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">BLE Application Developer’s Guide</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/host-app-dg.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="ble-application-developer-s-guide">
<span id="host-app-dg"></span><h1>BLE Application Developer’s Guide<a class="headerlink" href="#ble-application-developer-s-guide" title="Link to this heading"></a></h1>
<p>em | bleu BLE Application Developer’s Guide</p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h2>
<p>This document is a guide for application development using em | bleu’s Embedded Bluetooth Low-Energy protocol stack. This document is intended for readers with general knowledge in the fields of Bluetooth Low-Energy and embedded C programming.</p>
</section>
<section id="acronyms">
<h2>Acronyms<a class="headerlink" href="#acronyms" title="Link to this heading"></a></h2>
<p>The following table contains a list of acronyms and their definitions.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>AES</p></th>
<th class="head"><p>Advanced Encryption Standard</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ATT</p></td>
<td><p>Attribute Protocol</p></td>
</tr>
<tr class="row-odd"><td><p>BLE</p></td>
<td><p>Bluetooth Low-Energy</p></td>
</tr>
<tr class="row-even"><td><p>CID</p></td>
<td><p>L2CAP Channel ID</p></td>
</tr>
<tr class="row-odd"><td><p>CIG</p></td>
<td><p>Connected Isochronous Group</p></td>
</tr>
<tr class="row-even"><td><p>CIS</p></td>
<td><p>Connected Isochronous Stream</p></td>
</tr>
<tr class="row-odd"><td><p>CMAC</p></td>
<td><p>Cipher-based Message Authentication Code</p></td>
</tr>
<tr class="row-even"><td><p>DM</p></td>
<td><p>Device Manager</p></td>
</tr>
<tr class="row-odd"><td><p>ECC</p></td>
<td><p>Elliptic Curve Cryptography</p></td>
</tr>
<tr class="row-even"><td><p>GATT</p></td>
<td><p>Generic Attribute Profile</p></td>
</tr>
<tr class="row-odd"><td><p>GAP</p></td>
<td><p>Generic Access Profile</p></td>
</tr>
<tr class="row-even"><td><p>HCI</p></td>
<td><p>Host Control Interface</p></td>
</tr>
<tr class="row-odd"><td><p>L2CAP</p></td>
<td><p>Logical Link Control and Adaptation Protocol</p></td>
</tr>
<tr class="row-even"><td><p>PAL</p></td>
<td><p>Platform Abstraction Layer</p></td>
</tr>
<tr class="row-odd"><td><p>PDU</p></td>
<td><p>Protocol Data Unit</p></td>
</tr>
<tr class="row-even"><td><p>PHY</p></td>
<td><p>Physical Channel</p></td>
</tr>
<tr class="row-odd"><td><p>SMP</p></td>
<td><p>Security Manager Protocol</p></td>
</tr>
<tr class="row-even"><td><p>WSF</p></td>
<td><p>Wireless Software Foundations</p></td>
</tr>
</tbody>
</table>
</section>
<section id="introduction-to-bluetooth-low-energy">
<h2>Introduction to Bluetooth Low-Energy<a class="headerlink" href="#introduction-to-bluetooth-low-energy" title="Link to this heading"></a></h2>
<p>This section contains an introduction to Bluetooth Low-Energy.  Application developers should familiarize themselves with the concepts covered in this section before starting BLE application development.</p>
<section id="ble-address">
<h3>BLE Address<a class="headerlink" href="#ble-address" title="Link to this heading"></a></h3>
<p>A BLE Address is a 48-bit number that identifies a device.  A BLE address can be Public or Private.  Public addresses are provided by the device manufacturer, are unique to every device, and do not change.  Private addresses are generated randomly by the application.  A private address can be resolvable or unresolvable.  Resolvable addresses are generated by hashing a random number with an identity-resolving key.  The identity-resolving key is exchanged during pairing.</p>
</section>
<section id="services-and-profiles">
<h3>Services and Profiles<a class="headerlink" href="#services-and-profiles" title="Link to this heading"></a></h3>
<p>BLE Services and BLE Profiles define data and procedures that enable BLE device interoperability for a particular device function.  A BLE Service is a container that encapsulates data. A BLE Profile defines device roles, security requirements, and procedures related to the data exposed in BLE Services.</p>
<p>An example of a BLE Service is the BLE Battery Service.  The Battery Service exposes data containing how much battery life remains in a device’s battery.  Any BLE device containing a BLE Battery Service is capable of sharing battery information with other BLE devices.</p>
<p>An example of a simple BLE Profile is the BLE Blood Pressure (BP) Profile.  The BP Profile defines two BP device roles, BP sensor and BP collector. The BP Profile lists the requirements for each role.  For example, the BP Sensor must expose a BP Service and a Device Information Service.  The BP Profile defines the discovery procedure the BP collector must follow to find attributes on the BP Sensor. The BP Profile describes blood pressure procedures such as taking BP measurements, intermediate cuff pressure, etc.  Finally, the BP Profile defines the security requirements for the BP Sensor and BP Collector.</p>
</section>
<section id="client-and-server">
<h3>Client and Server<a class="headerlink" href="#client-and-server" title="Link to this heading"></a></h3>
<p>BLE Servers are devices that contain Services.  BLE Clients are devices that discover and access Services on Servers.  Generally, server code is used in sensor devices that advertise and accept connections.  Client code is used on sensor-collecting devices that scan and initiate connections.</p>
<p>A BLE device may be both a Server and a Client. However, in cases where a device can be both a client and a server, the device will function in only one role in the context of a particular connection.</p>
</section>
<section id="attributes-and-characteristics">
<h3>Attributes and Characteristics<a class="headerlink" href="#attributes-and-characteristics" title="Link to this heading"></a></h3>
<p>As stated above, a BLE Service is a container that exposes data.  Service data is exposed as a plurality of attributes.  Attributes consist of a handle, an attribute type (UUID), a length, and a value.  Additionally, services define permissions and settings for each attribute. An attribute handle is 16-bit identifier for the attribute.  The attribute type identifies the purpose of the attribute and also indicates how the attribute value is encoded. The ATT protocol defines procedures whereby BLE devices can discover, read, write, notify, and indicate attribute data.</p>
<p>The first attribute in a service is used to identify the service.  The first attribute can have the primary service, secondary service, or included service attribute type.  The data in the service’s first attribute contains a UUID that identifies the service.</p>
<p>The remaining attributes are generally characteristic, characteristic data, or client characteristic configuration (CCC) attributes, but may provide a less common function like including a service. A characteristic attribute identifies the UUID, properties, and an attribute handle for a particular item of data exposed by a Service.  The attribute handle in the characteristic attribute references the characteristic data attribute which contains the actual data exposed by the Service.  The CCC attribute is optional and is used by the client to enable notification and/or indications of changes to characteristic data.</p>
<p>In the BLE Battery Service example.  The first attribute is a primary service attribute and contains the UUID for the battery-level service.  The next 3 attributes make up the battery level characteristic.  The first attribute in the characteristic is the characteristic attribute.  The characteristic attribute contains the properties of the battery-level characteristic, the handle of the battery-level data, and the battery-level UUID.  The second attribute is the data attribute.  It contains a value that represents the battery level.  The third attribute is the Client Characteristic Configuration attribute.  This attribute is used to enable/disable characteristic notifications and indications from the server to the client when the battery level changes.</p>
</section>
<section id="reading-writing-indicating-and-notifying-characteristics">
<h3>Reading, Writing, Indicating, and Notifying Characteristics<a class="headerlink" href="#reading-writing-indicating-and-notifying-characteristics" title="Link to this heading"></a></h3>
<p>The ATT layer can read, write, indicate, and notify characteristics.  Clients read and write characteristics.  Servers notify and indicate characteristics.  Notification is a process where the server sends characteristic data to the client without expecting acknowledgment from the client.  The indication is a similar process, but the server expects acknowledgments.</p>
</section>
<section id="gatt-and-gap">
<h3>GATT and GAP<a class="headerlink" href="#gatt-and-gap" title="Link to this heading"></a></h3>
<p>GATT, the Generic Attribute Protocol, is a framework that defines the usage of the ATT Protocol. GATT resides in GAP, the Generic Access Profile. Together these profiles define how servers are configured, the service discovery process, how characteristics are accessed, etc.</p>
<p>You may notice that GATT and GAP are absent from the architecture diagram for em | bleu’s BLE Host stack.  This is because the implementation of GATT and GAP functionality is spread out over the ATT and App Framework.  Service discovery, attribute hashing, etc. take place in the App Framework.  Reading, writing, indicating, and notifying characteristics takes place in the ATT Layer.</p>
</section>
<section id="advertising-and-scanning">
<h3>Advertising and Scanning<a class="headerlink" href="#advertising-and-scanning" title="Link to this heading"></a></h3>
<p>Advertising is a process whereby a device broadcasts information about itself for any device to see.  Scanning is a process where a device listens for advertisements.  The scan process permits the discovery of nearby devices and the function of nearby devices.</p>
<p>Advertisements may also be used as a method of broadcast communication.</p>
</section>
<section id="connecting-and-connection-update">
<h3>Connecting and Connection Update<a class="headerlink" href="#connecting-and-connection-update" title="Link to this heading"></a></h3>
<p>When two devices require unicast communication, they establish a connection with each other.  The connection is initiated by the master (central) device.  The connection is accepted by the slave (peripheral) device.  One step in the connection process is the connection update procedure.  The update procedure is used to reconfigure connection parameters.  One parameter is the connection interval which is the frequency a device turns its receiver on to listen for data from the peer.  Only one ATT message is communicated per connection interval.  Therefore, a long connection interval will result in battery savings, but communication will take a long time.  The converse is true for a short connection interval.</p>
</section>
<section id="acl-and-iso">
<h3>ACL and ISO<a class="headerlink" href="#acl-and-iso" title="Link to this heading"></a></h3>
<p>There are two types of connection-based communication channels: Asynchronous and isochronous. Asynchronous channels, also called Asynchronous Connection Logical (ACL) Transport channels, transport messages anytime an application has reason for communicating with a peer device. Examples of ACL data include sensor data (e.g. temperature, humidity, heart rate, etc.) or industrial control messages (e.g. light on/off, luminosity level, alarm messages, etc.)  It is important to note that, while ACL is considered asynchronous, the physical communication does take place in structured time slots. However, a device is expected to skip most of these time slots and only transmit when there is data of interest to share.</p>
<p>An ISO, Isochronous, channel, on the other hand, transports a stream of data with special care to meet a specific time interval between each packet of data.  Examples of ISO data are audio and video data streams.</p>
</section>
<section id="encryption-and-authentication">
<h3>Encryption and Authentication<a class="headerlink" href="#encryption-and-authentication" title="Link to this heading"></a></h3>
<p>Connections between two devices can be encrypted and authenticated.  Encryption involves encoding messages so third parties cannot view the content of a message.  Authentication is a process of ensuring the connection has been established to the intended device. Unicast communication is authenticated and encrypted using the SMP pairing process.  Broadcast communication is authenticated and encrypted using the Encrypted Advertising Data procedures.</p>
</section>
<section id="pairing-and-bonding">
<h3>Pairing and Bonding<a class="headerlink" href="#pairing-and-bonding" title="Link to this heading"></a></h3>
<p>Pairing is a process of authenticating and encrypting an ACL link. Pairing takes place using the Security Manager Protocol.  There are two pairing protocols.  Legacy Pairing was the first security protocol defined in the BLE specification.  BLE Secure Connections is a newer protocol that has better man-in-the-middle protection.  Each protocol has four authentication procedures: just works, passkey, numeric comparison, and out-of-band key exchange.  Just Works does not have a human verification step to authenticate a link.  Passkey and numeric comparison involve a human entering a PIN code to compare numbers shown in two places as an authentication step.  The out-of-band key exchange involves exchanging a key over a non-Bluetooth medium as a means of authentication.</p>
<p>After pairing, a link is encrypted.  However, subsequent connections will not be secure unless encryption information is stored for future use.  When two devices store security data for long-term use, the devices are said to be bonded.</p>
</section>
</section>
<section id="em-bleu-ble-architectural-overview">
<h2>em | bleu BLE Architectural Overview<a class="headerlink" href="#em-bleu-ble-architectural-overview" title="Link to this heading"></a></h2>
<p>The following figure illustrates em | bleu’s BLE protocol stack.</p>
<a class="reference internal image-reference" href="_images/ble_arch_overview.png"><img alt="_images/ble_arch_overview.png" src="_images/ble_arch_overview.png" style="width: 800px;" /></a>
<p>BLE applications interface with GATT Profiles, Application Framework, Device Manager, and the WSF and PAL.</p>
<section id="gatt-profiles">
<h3>GATT Profiles<a class="headerlink" href="#gatt-profiles" title="Link to this heading"></a></h3>
<p>GATT Profiles are a plurality of BLE profiles and services. Each profile and service defines communication procedures for a particular BLE function.  Example profiles include the battery level profile, heart rate profile, pulse oximeter profile,  etc.  For an introduction to profiles and services, see section Services and Profiles of the Introduction to Bluetooth Low Energy chapter.  For instructions on implementing profiles and services, see the chapter on Creating a New Profile and Service.</p>
</section>
<section id="application-framework">
<h3>Application Framework<a class="headerlink" href="#application-framework" title="Link to this heading"></a></h3>
<p>The Application Framework, or App Layer, contains implementations of common application-level GATT, GAP, ATT, and SMP processes. Use of the App Layer is optional, but the App Layer greatly simplifies adding common BLE procedures to applications.  The App Layer is configured from a plurality of configuration structures. The App Layer can be used to perform the following:</p>
<ul class="simple">
<li><p>Control advertising.</p></li>
<li><p>Control scanning.</p></li>
<li><p>Control connections and connection updates.</p></li>
<li><p>Initiate the SMP process after a connection, or if a bond already exists, initiate the encryption procedure.</p></li>
<li><p>Perform Service Discovery.</p></li>
<li><p>Perform Service Configuration.</p></li>
<li><p>Store and restore peer device Service, SMP, and GAP information in the <em>App Database</em>.</p></li>
<li><p>Simulate a user interface.</p></li>
<li><p>Simulate target hardware.</p></li>
</ul>
<p>The Application Framework consists of the following modules:</p>
<section id="master">
<h4>Master<a class="headerlink" href="#master" title="Link to this heading"></a></h4>
<p>The Application Framework Master implements scan, initiate connection, initiate security, initiate periodic advertisement synchronization, and other procedures that are common to devices in a central role.</p>
</section>
<section id="slave">
<h4>Slave<a class="headerlink" href="#slave" title="Link to this heading"></a></h4>
<p>The Application Framework Slave implements advertisement, accept connection, accept security, and other procedures that are common to devices in a peripheral role.</p>
</section>
<section id="discovery">
<h4>Discovery<a class="headerlink" href="#discovery" title="Link to this heading"></a></h4>
<p>The Application Framework Discovery module contains a state machine that performs ATT service discovery and service configuration for the application.</p>
</section>
<section id="database">
<h4>Database<a class="headerlink" href="#database" title="Link to this heading"></a></h4>
<p>The Application Framework Database contains bond-orientated information about devices that permits re-establishing a connection without performing security and discovery.  The Database also integrates with NVM, Non-Volatile Memory, to store database information when the device is powered down.</p>
</section>
<section id="hardware">
<h4>Hardware<a class="headerlink" href="#hardware" title="Link to this heading"></a></h4>
<p>The Application Framework Hardware module simulates hardware such as temperature, pressure, battery level, etc. on common BLE sensor devices.</p>
</section>
<section id="ui">
<h4>UI<a class="headerlink" href="#ui" title="Link to this heading"></a></h4>
<p>The Applications Framework UI module simulates button, LED, and LCD.</p>
</section>
<section id="terminal">
<h4>Terminal<a class="headerlink" href="#terminal" title="Link to this heading"></a></h4>
<p>The Application Framework Terminal module provides a terminal interface for an application. em | bleu’s BLE sample applications use the terminal to display information to the user and to receive commands from a user. The terminal is useful for debugging and diagnostic purposes.</p>
</section>
</section>
<section id="attribute-profile">
<h3>Attribute Profile<a class="headerlink" href="#attribute-profile" title="Link to this heading"></a></h3>
<p>The ATT Layer implements the BLE Attribute Protocol as it is defined in the Bluetooth Core Specification.  em | bleu’s ATT Layer provides support for the Extended Attribute protocol, EATT.</p>
</section>
<section id="security-manager">
<h3>Security Manager<a class="headerlink" href="#security-manager" title="Link to this heading"></a></h3>
<p>The Security Manager Protocol, SMP, consists of several state machines and action functions used for securing BLE connections as defined in the Bluetooth Core Specification.  em | bleu’s SMP supports both Legacy Pairing, which was the original LE security protocol, and the newer LE Secure Connections protocol.</p>
</section>
<section id="device-manager">
<h3>Device Manager<a class="headerlink" href="#device-manager" title="Link to this heading"></a></h3>
<p>The Device Manager, DM, implements several common network procedures as they are defined in the BLE Core Specification. Examples of these procedures are establishing connections, performing connection updates, advertising, scanning, enabling constant tones, enhancing connection updates, etc.</p>
</section>
<section id="logical-link-control-and-adaptation-protocol">
<h3>Logical Link Control and Adaptation Protocol<a class="headerlink" href="#logical-link-control-and-adaptation-protocol" title="Link to this heading"></a></h3>
<p>The Logical Link Control and Adaptation Layer, L2CAP, is an implementation of the BLE L2CAP as defined in the Bluetooth Core Specification.  em | bleu’s L2CAP supports credit-based flow control, connection-orientated channels, and the extended connection commands required by the Enhanced Attribute Protocol, EATT.</p>
</section>
<section id="host-control-interface">
<h3>Host Control Interface<a class="headerlink" href="#host-control-interface" title="Link to this heading"></a></h3>
<p>The Host Control Interface, HCI, is a standard interface for communication between a BLE Host and a BLE Controller.  HCI commands and events are defined in the Bluetooth Core Specification.  em | bleu’s BLE Host Stack includes two HCI implementations – Dual Chip and ExactLE.</p>
<p>The Dual Chip HCI is a serialized version of the HCI.  The Dual Chip HCI formats and parses serial messages between the controller and the host over a serial interface such as a UART, SPI, or I2C.</p>
<p>ExactLE HCI is the second implementation, and it is intended for System-on-Chip (SoC) applications where em | bleu’s BLE Host and em | bleu’s BLE Controller share the same memory space.  The ExactLE HCI is a thin layer of software that integrates the Host’s HCI functional interface with em | bleu’s BLE Controller API.</p>
</section>
<section id="wsf-and-pal">
<h3>WSF and PAL<a class="headerlink" href="#wsf-and-pal" title="Link to this heading"></a></h3>
<p>The WSF, Wireless Software Foundation, and PAL, Platform Abstraction Layer provide a layer of abstraction over the Operating System and Hardware Drivers respectively.  This layer of abstractions aids in the portability of the em | bleu BLE stack to multiple target hardware platforms and operating systems.</p>
<!--
## Tool Chain

The source code for em | bleu's embedded BLE Host Stack is written in ANSI C. The BLE Host Stack source code can be compiled and linked from a command terminal on Windows and Linux workstations using GNU’s embedded ARM EABI toolchain.

### Installing Tools

### GCC Arm

GCC projects in this package assume GCC Arm bare-metal cross tools (i.e. "arm-none-eabi-") are in your path. Building on both Windows, Linux, and Mac is supported.

Install arm-none-eabi-gcc (GNU Arm Embedded Toolchain 12.3.Rel1) 12.3.1 20230626

```
https://developer.arm.com/downloads/-/gnu-rm
```

### Python

Install 32-bit Python 3 for your platform.

```
https://www.python.org/downloads/
```

We recommend setting a path without spaces such as `C:\Python311-32`

Rename or copy the Python executable to `python3.exe`, which is required by the build tools.

```
$ cp python.exe python3.exe
```

### Segger J-Link

Segger J-Link tools are used for installing binaries on the embedded target. Debugging on Windows, Linux, and Mac is supported.

Install version 7.80c of the J-Link Software and Documentation Pack (not the latest)

```
https://www.segger.com/downloads/jlink/#J-LinkSoftwareAndDocumentationPack
```

### Debugging

The GNU ARM toolchain produces firmware in binary and ELF formats. The ELF output can be debugged with a GDB debugger and J-Link software.

### Building a Win32 DLL

The BLE Host stack can be built into a Windows 32-bit DLL. The Win32 DLL Host Stack exposes a Python SWIG interface to the Host Stack API. The Win32 DLL communicates via HCI to a BLE controller over a COM port. Python scripts can execute BLE Host Stack functionality utilizing this DLL. The Win32 DLL Host Stack may be useful for Quality Assurance and command and control of BLE devices.  em | bleu's BLE Host Tester runs on this Win32 DLL.

#### Building a Win32 DLL with Visual Studio
The Win32 DLL is built using a Visual Studio project located in the ble-host\build\ble-host-tester\msvs folder. Open the project and choose `Build -> Rebuild Solution` from the top menu.

#### Building a Win32 DLL with GCC
The Win32 DLL can also be built with MINGW GCC 12.3.0 and GMake 4.4.1. Note: As of release 24.06, support for this toolchain is experimental and test results are generally less stable than when built with Visual Studio.

The BLE Host Tester is built from the top-level of the `fw` repo using the following commands:
```
> make -C ble-host/build/ble-host-tester/build/gcc clean
> make -C ble-host/build/ble-host-tester/build/gcc uninstall
> make -C ble-host/build/ble-host-tester/build/gcc all DEBUG=1 TRACE=1 -j
> make -C ble-host/build/ble-host-tester/build/gcc install
```

`make all` compiles the host C code into a Python module and `make install` copies the compiled Python module into a location where it can be found and loaded by the host test harness, i.e., the `ble-host/tests` folder.

### Compiling an Application

Applications are compiled using Make.  An example build command for the DATC sample application for the Nordic NRF52 DK follows:

```
> cd ble-apps/build/datc/gcc
> make -j PLATFORM=nordic_nrf52
```

The output of the build with be in the ble-apps/build/datc/gcc/bin folder.  The datc.elf file can be used for GDB debugging.  The datc.hex file can be dragged and dropped onto the drive for the NRF52 DK board in the file explorer.  The datc.hex and datc.bin files can also be programmed to an NRF52 DK board using J-Link or the nrfproj.exe utility.  Please see the documentation from Nordic for more information about programming a Nordic development board.

#### Makefile Command Line Arguments

The following are common arguments for the Make command:

- DEBUG=<0, 1, 2>
- TRACE=<0, 1>
- USE_EXACTLE=<0, 1>
- BT_VER=<8…13>
- PLATFORM=<platform>
- OS=<linux, freertos, baremetal>
- USE_OFAST=<0, 1>

The DEBUG flag is used to enable the debug level.  DEBUG=0 is no debugging.  DEBUG=1 enables ASSERT and WSF buffer statistics but does not alter the compiler optimization.  DEBUG=2 disables compiler optimization.  Disabling optimization will alter execution time and code size, but step-by-step debugging will be easier to interpret without optimization.

 The TRACE flag is used to enable/disable data logging.  TRACE=1 will enable the datalog.  TRACE=0 will disable the datalog.

USE_EXACTLE switches between the dual chip and exactle HCI.  USE_EXACTLE=0 enables dual chip.  USE_EXACTLE=1 enables exactle system-on-a-chip.

BT_VER sets the Bluetooth version of the controller.  Older versions of the BLE specification had fewer controller features but compiled to a smaller size.  Select the lowest version that contains all the features your application requires.  For more information, see the BLE Core Specification. The following maps a BT_VER integer to a revision of the BLE Core Specification:

| **BT_VER** | **Bluetooth Core Version** |
| ---------- | -------------------------- |
| 8          | v4.2                       |
| 9          | v5.0                       |
| 10         | v5.1                       |
| 11         | v5.2                       |
| 12         | v5.3                       |
| 13         | v5.4                       |
| 14         | TBD - Atlanta              |

PLATFORM sets the platform target directory.  Use PLATFORM=nordic_nrf52 for the nrf52 DK board.  Use PLATFORM=nordic_nrf53_app for the app processor on the nr53 DK board.  PLATFORM=nordic_nrf53_net will use the network processor on the nr53 DK board.

OS sets the operating system.  OS=baremetal will use the baremetal implementation of the WSF.  Other options are Linux and FreeRTOS.

USE_OFAST selects the compiler optimization.  USE_OFAST=1 compiles the code to run faster, but the code size is larger.  USE_OFAST=0 compiles the code to be as small as possible.
-->
</section>
</section>
<section id="platform-and-operating-system">
<h2>Platform and Operating System<a class="headerlink" href="#platform-and-operating-system" title="Link to this heading"></a></h2>
<section id="platform-abstraction-layer">
<h3>Platform Abstraction Layer<a class="headerlink" href="#platform-abstraction-layer" title="Link to this heading"></a></h3>
<p>em | bleu’s BLE Host, Link Layer, and operating system interface with target hardware through a Platform Abstraction Layer, PAL.  PAL-related source code can be found in the *platform *folder. Much of the PAL functionality is only used by the baseband and radio layers of the BLE Controller.  However, some PAL features are useful in application development such as Peripheral I/O (UART, I2C, SPI, GPIO, Buttons, LEDs, USB, etc.).  See the em | bleu BLE Host and Controller API documentation for more information about the PAL layer.</p>
</section>
<section id="wireless-software-foundation-wsf">
<h3>Wireless Software Foundation (WSF)<a class="headerlink" href="#wireless-software-foundation-wsf" title="Link to this heading"></a></h3>
<p>The em | bleu BLE Host accesses the Operating System via the WSF, Wireless Software Foundation API.  The BLE Host requires the following functionality from the operating system:</p>
<ul class="simple">
<li><p>Non-preemptive task scheduler</p></li>
<li><p>Dynamic memory allocation</p></li>
<li><p>Timer management</p></li>
<li><p>Event and message management</p></li>
<li><p>Non-volatile memory</p></li>
<li><p>Diagnostics</p></li>
<li><p>Idle time and power management</p></li>
</ul>
<p>A *BareMetal *implementation of the WSF is provided with em | bleu’s BLE Host. Alternatively, the WSF API can abstract a third party’s real-time operating system.  Implementations of the WSF wrapping *FreeRTOS *and *Linux *are available.</p>
<section id="task-handlers">
<h4>Task Handlers<a class="headerlink" href="#task-handlers" title="Link to this heading"></a></h4>
<p>The WSF provides a non-preemptive task scheduler to the BLE Host, Link Layer, and Application for the purpose of processing events, messages, and timers for a plurality of task handlers.</p>
<p>The *WsfOsSetNextHandler *function is used to add a task handler to the OS’s task scheduler.  Once a task handler is added to the OS, the OS will call a task’s handler function in response to calls to <em>WsfSetEvent</em>, <em>WsfMsgSend</em>, <em>WsfTimerStartSec</em>, and <em>WsfTimerStartMs</em>.</p>
<p>Note: BLE Host task handler functions can not preempt one another. Furthermore, the task handler events in the Link Layer are time-sensitive. Therefore, care must be taken to ensure execution of application events do not block critical radio functionality in the link layer.  The max execution period for a task varies depending on the connection interval and supervision timeout connection parameters.</p>
</section>
<section id="dynamic-memory">
<h4>Dynamic Memory<a class="headerlink" href="#dynamic-memory" title="Link to this heading"></a></h4>
<p>The WSF provides *WsfBufAlloc *and *WsfBufFree *functions to the BLE Host.  WsfBufAlloc dynamically allocates a contiguous block of memory from RAM of a given size.  WsfBufFree releases the memory back to the operating system.</p>
<p>In the BareMetal implementation of the WSF, the buffers are allocated from pools of fixed-size buffers.  In the BareMetal implementation, the application must call the *WsfBufInit *function with a description of the buffer pools to initialize memory for dynamic allocation.</p>
</section>
<section id="timers">
<h4>Timers<a class="headerlink" href="#timers" title="Link to this heading"></a></h4>
<p>The WSF provides <em>WsfTimerStartSec</em>, <em>WsfTimerStartMs</em>, and *WsfTimerStop *functions to the BLE Host.  TheWsfTimerStartSec and  WsfTimerStartMs functions start a timer.  After the given time period passes, the operating system will send the given wsfTimer_t.msg message to the task handler associated with the given wsfTimer_t.handle task handle.  The WsfTimerStop function halts a timer.</p>
</section>
<section id="events-and-messages">
<h4>Events and Messages<a class="headerlink" href="#events-and-messages" title="Link to this heading"></a></h4>
<p>The WSF provides *WsfSetEvent *to notify task handlers of events.  The events are implemented as bits in a 16-bit mask.</p>
<p>The WSF provides <em>WsfMsgAlloc</em>, <em>WsfMsgFree</em>, and *WsfMsgSend *to send structured messages to task handlers.  WsfMsgAlloc allocates dynamic memory for the message.  WsfMsgSend sends the message to a handler.  WsfMsgFree frees dynamic memory allocated by WsfMsgAlloc.  Message buffers are automatically freed after being handled.  Therefore, WsfMsgFree is only necessary when the message is not sent.</p>
</section>
<section id="critical-sections">
<h4>Critical Sections<a class="headerlink" href="#critical-sections" title="Link to this heading"></a></h4>
<p>While WSF tasks are non-preemptive, interrupt service routines may preempt WSF tasks.  The WSF provides the *WsfTaskLock *and *WsfTaskUnlock *functions to protect resources shared by tasks and ISR.</p>
</section>
<section id="non-volatile-memory">
<h4>Non-Volatile Memory<a class="headerlink" href="#non-volatile-memory" title="Link to this heading"></a></h4>
<p>The WSF provides <em>WsfNvmReadData</em>, <em>WsfNvmWriteData</em>, and *WsfNvmEraseData *to read, write, and erase non-volatile memory in Flash.  The Baremetal implementation of the NVM is intended for storing BLE pairing data after two devices establish a bond.  When a BLE bond is broken, all pairing data is erased. Therefore, to conserve ROM, wsf_nvm.c in the bare-metal OS does not perform garbage collection on unused NVM items.</p>
<p>Note: If an application requires the use of NVM beyond storing pairing data, replacing the Baremetal NVM, wsf_nvm.c, with an embedded filesystem is recommended.</p>
</section>
<section id="diagnostics">
<h4>Diagnostics<a class="headerlink" href="#diagnostics" title="Link to this heading"></a></h4>
<p>The WSF provides ASSERT, Trace, Terminal, and Dynamic Buffer diagnostics.</p>
<p>The WSF_ASSERT macro halts execution if a condition resolves to false. This macro is only compiled into the code if DEBUG=1 (or greater) is set on the Make command line.</p>
<p>The APP_TRACE_INFO, APP_TRACE_ERR, and APP_TRACE_WARN macros can be called from an application to output diagnostic messages to a data log. These macros are compiled into the code when DEBUG=1 (or greater) and TRACE=1 are both set on the Make command line.</p>
<p>The WSF_BUF_FREE_CHECK_ASSERT, WSF_BUF_STATS, WSF_BUF_STATS_HIST, WSF_BUF_ALLOC_FAIL_ASSERT conditional compile macros can be used to tune and/or diagnose dynamic memory issues.</p>
<p>The WSF terminal interface makes diagnostic use of a UART to display log messages in real time and process commands from the user using a serial terminal program.</p>
</section>
</section>
</section>
<section id="application-development">
<h2>Application Development<a class="headerlink" href="#application-development" title="Link to this heading"></a></h2>
<p>The following figure illustrates a process for BLE application development using em | bleu’s BLE Host Stack:</p>
<a class="reference internal image-reference" href="_images/ble_app_development_workflow.png"><img alt="_images/ble_app_development_workflow.png" src="_images/ble_app_development_workflow.png" style="width: 800px;" /></a>
<p>In the Planning Phase, the app developer selects the services, profiles, and BLE features that will be used by the application.</p>
<p>In the Stack Initialization Phase, initialization functions associated with each BLE feature are identified and called from the application startup.</p>
<p>In the Stack Configuration Phase, any changes to default values of the dmCfg_t, l2cCfg_t, attCfg_t, eattCfg_t, and smpCfg_t are identified and updated.  Also in the stack configuration phase, constants in ble-host/sources/stack/cfg/cfg_stack.h are modified as required.</p>
<p>The Application Framework Configuration Phase involves configuring the app framework and setting up event processing for the app framework. Changes to the appAdvCfg_t, appExtAdvCfg_t, appSlaveCfg_t, appMasterCfg_t, appExtMasterCfg_t, appSecCfg_t, appUpdateCfg_t, appReqActCfg_t, appDiscCfg_t, appCfg_t, appDevInfo_t are identified and updates. App layer message process functions are added to the application task handler.</p>
<p>In the CCC Table Development Phase, an attsCccSet_t table is built from service characteristics with CCC attributes.  The table is then passed into AttsCccRegister.  This only takes place on server devices that contain a BLE service with CCC attributes.</p>
<p>In the Advertisement Phase, the contents of the advertisement are created for the application.  This only takes place on connection-based slave (peripheral) devices.</p>
<p>In the Client Discovery Table Phase, a table of service characteristics is constructed.  This table will be used by the Application Framework to perform service discovery.</p>
<p>In the Client Configuration Table Phase, a table of initial characteristic values is constructed.  This table will be used by the Application Framework to configure services after service discovery is completed.</p>
<p>The application-specific development phase will differ from application to application depending on the Core BLE features, services, and profiles required in the application.</p>
<p>Finally, there is a Tuning Phase where configuration parameters are tuned to their final values.</p>
<section id="planning-for-application-development">
<h3>Planning for Application Development<a class="headerlink" href="#planning-for-application-development" title="Link to this heading"></a></h3>
<p>There are many things to consider in the application planning stage.  For example, will the BLE application need to interoperate with third-party devices or will the application be proprietary?  Will the BLE application take a central or peripheral role?  Will communication use broadcast, unicast, or both forms of communication?</p>
<p>Decisions made in the planning phase impact the Stack Initialization, Stack Configuration, and App Framework Configuration phases.  For example, if the application will use Isochronous communication, then one or more DM ISO initialization functions such as DmIsoInit must be called in the Stack Initialization phase.</p>
<p>The following sections detail some of the considerations to make in the planning phase.</p>
<section id="interoperability">
<h4>Interoperability<a class="headerlink" href="#interoperability" title="Link to this heading"></a></h4>
<p>Some BLE devices can interoperate with third-party devices.  Other BLE devices only function in networks of proprietary devices.  Interoperable devices must strictly conform to documented BLE procedures.  Furthermore, interoperable devices must go through a Qualification process where the BLE device is to tested to ensure conformance with BLE profiles and services.</p>
<p>The tradeoff between interoperability and proprietary involves the extra engineering work and regulatory testing to bring an interoperable device to market vs. producing a device that can only interact in a closed ecosystem.</p>
</section>
<section id="device-role">
<h4>Device Role<a class="headerlink" href="#device-role" title="Link to this heading"></a></h4>
<p>A device can have a slave (peripheral) role or a master (central) role.  Slave devices advertise and wait for a master to initiate a connection to them.  Master devices scan and initiate connections.</p>
<p>When developing sensor devices, the sensors themselves are generally slave devices.  The sensors collect information and wait for the opportunity to provide the information to the master device.  A cell phone, smartwatch, personal computer, tablet, etc. are often the master devices collecting data from sensor devices.</p>
<p>In some situations, a device is both a slave and a master.  A smartwatch is an example.  A smartwatch may collect data from running or bicycling cadence sensors.  The smartwatch might be capable of collecting heart rate data - making the smartwatch a sensor too.  Another example of a dual master/slave role happens when there is a requirement to include the device informative service on a central device. The central device generally scans, initiates connections, and performs service discovery.  However, the central device can also advertise and accept a connection to expose the device information service.</p>
<p>In cases where a device is both a master and a slave, both master and slave configuration, stack initialization, event handlers, etc. must be added to the application.</p>
</section>
<section id="broadcast-vs-unicast">
<h4>Broadcast vs Unicast<a class="headerlink" href="#broadcast-vs-unicast" title="Link to this heading"></a></h4>
<p>Device communication can be broadcast, unicast, or both.</p>
<p>When broadcast communication is used, devices communicate with advertisements and do not establish a connection with one another.  This communication is different from slave advertisements.  Slave advertisements are static and contain basic information about the device’s capabilities.  Broadcast advertisements are periodic and the data changes with each advertisement.</p>
<p>Before unicast communication can be used, devices must form a connection. Generally, one device is responsible for scanning and initiating a connection.  The other device is responsible for advertising and accepting a connection.</p>
</section>
<section id="extended-vs-legacy-advertising-and-scanning">
<h4>Extended vs. Legacy Advertising and Scanning<a class="headerlink" href="#extended-vs-legacy-advertising-and-scanning" title="Link to this heading"></a></h4>
<p>Extended advertisements have a few benefits over legacy advertising.  A legacy advertisement is only 31 bytes long.  An extended advertisement can be 250 bytes.  Extended advertising has multiple advertising sets and can advertise more than one advertisement without restarting advertising. Extended advertisements can change periodically.  Extended advertisements support responses from devices that have synchronized to periodic advertisements.</p>
<p>The key tradeoff between legacy advertising and extended advertising involves complexity and RAM/ROM resources.  Also, consider that devices only capable of legacy scanning will not receive extended advertisement reports.  However, a device that supports extended advertisements and scanning can transmit or receive legacy advertisements and extended advertisements.</p>
</section>
<section id="mtu-length">
<h4>MTU Length<a class="headerlink" href="#mtu-length" title="Link to this heading"></a></h4>
<p>ATT message lengths are limited to the maximum transmission unit, MTU. The default MTU value is 23 bytes. Two devices can negotiate a different length MTU.  An app developer should analyze all messages sent and received by all the services and profiles used by the application.  Set the MTU to the longest message required by the services.  If a proprietary service is being developed, consider fragmenting long messages with continuation bits and/or frame counters.</p>
</section>
<section id="asynchronous-and-isochronous">
<h4>Asynchronous and Isochronous<a class="headerlink" href="#asynchronous-and-isochronous" title="Link to this heading"></a></h4>
<p>Both broadcast and unicast communication can be asynchronous or isochronous. Asynchronous, or ACL, communication is good for sensor data or command and control packets.  Isochronous communication is good for audio and/or video streaming.</p>
</section>
<section id="number-of-att-bearers">
<h4>Number of ATT Bearers<a class="headerlink" href="#number-of-att-bearers" title="Link to this heading"></a></h4>
<p>The legacy ATT only supports one ATT bearer.  A bearer is an L2CAP channel used for ATT communication.  Therefore, one ATT operation can take place at a time.  An application or profile must wait for each ATT operation to complete before starting another ATT operation.</p>
<p>The Extended ATT, EATT, is capable of supporting multiple ATT bearers that operate simultaneously.  The benefit of the EATT is each profile can independently control one or more ATT bearers without having to wait for, or even be aware of the existence of, other ATT bearers operated by other profiles.  The trade-off is complexity and system resources.</p>
</section>
<section id="address-privacy">
<h4>Address Privacy<a class="headerlink" href="#address-privacy" title="Link to this heading"></a></h4>
<p>A BLE address can be Public or Private.  When using private resolvable addressing, an application must call the DM privacy initialization functions and configure the SMP to exchange an Identity Resolving Key (IRK).</p>
</section>
<section id="security">
<h4>Security<a class="headerlink" href="#security" title="Link to this heading"></a></h4>
<p>An application can communicate with or without encryption.  When using encryption, a link can be authenticated or unauthenticated. Link keys can be stored for future connections, or devices must perform the security process on every connection.  BLE provides two security protocols: Legacy Pairing and Secure Connections Pairing.  The latter has better man-in-the-middle protection.  There are four security procedures: Just Works, Numeric Comparison, Passcode, and Out-of-Band pairing.  There are also multiple keys that can be exchanged during the security process.  The following sections cover the types of key exchange that can take place during pairing:</p>
<section id="long-term-key-ltk">
<h5>Long Term Key (LTK)<a class="headerlink" href="#long-term-key-ltk" title="Link to this heading"></a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">DM_KEY_DIST_LTK</span></code> flag indicates the LTK, Long Term Key, is requested during key exchange.  The long-term key is used to encrypt a link between two devices.  When an LTK is exchanged, then a bond can exist between devices. In future connections, bonded devices can skip pairing and encrypt the link with the LTK.</p>
</section>
<section id="identity-resolving-key-irk">
<h5>Identity Resolving Key (IRK)<a class="headerlink" href="#identity-resolving-key-irk" title="Link to this heading"></a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">DM_KEY_DIST_IRK</span></code> flag indicates the IRK, Identity Resolving Key, is requested during key exchange. The IRK is used to resolve and generate resolvable private addresses (RPA).</p>
</section>
<section id="connection-signature-resolving-key-csrk">
<h5>Connection Signature Resolving Key (CSRK)<a class="headerlink" href="#connection-signature-resolving-key-csrk" title="Link to this heading"></a></h5>
<p>The <code class="docutils literal notranslate"><span class="pre">DM_KEY_DIST_CSRK</span></code> flag indicates the CSRK, Connection Signature Resolving Key, is exchanged during key exchange.  The CSRK is used to authenticate ATT messages with a signature.  Note: Signed ATT reads and writes are generally considered to be depreciated.</p>
</section>
</section>
</section>
<section id="arbitration-rules-for-connection-event-collisions">
<h3>Arbitration Rules for Connection Event Collisions<a class="headerlink" href="#arbitration-rules-for-connection-event-collisions" title="Link to this heading"></a></h3>
<p>The em | bleu stack operates as a Slave for two simultaneous connections and is responsible for fulfilling connection events for both connections simultaneously. The scheduling is done using two different “Baseband Operation Descriptors (BOD).” When a new connection event is scheduled, it is inserted into the scheduler’s queue using the SchInsertAtDueTime function. This function checks if there is already an existing operation scheduled at that time and, if so, calls a preconfigured “conflict resolution callback” called <code class="docutils literal notranslate"><span class="pre">lctrConnResolveConflict</span></code>-</p>
<p>The <code class="docutils literal notranslate"><span class="pre">lctrConnResolveConflict</span></code> function handles the conflict resolution with the following priority:</p>
<ol class="arabic simple">
<li><p>If the existing operation is not a connection-related event, the new operation is prioritized.</p></li>
<li><p>If the new operation is still being initialized, the existing operation is prioritized.</p></li>
<li><p>If the existing operation’s supervisor timeout is imminent (within 1 second), the existing operation is prioritized.</p></li>
<li><p>If the new operation’s supervisor timeout is imminent (within 1 second), the new operation is prioritized.</p></li>
<li><p>If the existing operation has a pending active LLCP (Logical Link Control Protocol), the existing operation is prioritized.</p></li>
<li><p>If the new operation has a pending active LLCP, the new operation is prioritized.</p></li>
<li><p>If the existing operation has pending data, the existing operation is prioritized.</p></li>
<li><p>If the new operation has pending data, the new operation is prioritized.</p></li>
<li><p>If the existing operation’s connection interval is greater than 4 times the new operation’s connection interval, the existing operation is prioritized.</p></li>
<li><p>If the new operation’s connection interval is greater than 4 times the existing operation’s connection interval, the new operation is prioritized.</p></li>
<li><p>If none of the above prioritizations occur, the existing operation will run, and the new operation will be skipped.</p></li>
</ol>
</section>
<section id="stack-initialization">
<h3>Stack Initialization<a class="headerlink" href="#stack-initialization" title="Link to this heading"></a></h3>
<p>To conserve system resources, the subsystems of em | bleu’s BLE Host are configurable at compile-time. The process of configuring BLE Host subsystems involves starting WSF task handlers and calling stack initialization functions at application startup.</p>
<p>The following is a list of <em>task handlers</em> that may be started in the Stack Initialization procedure:</p>
<section id="terminalhandler">
<h4>TerminalHandler<a class="headerlink" href="#terminalhandler" title="Link to this heading"></a></h4>
<p>The TerminalHandler facilitates terminal I/O processing.  Terminal I/O aids in the debugging and development of applications by directing data logging to a serial UART for display in a dumb Terminal.  Additionally, the terminal I/O can process commands entered by the user into the terminal.</p>
<p>The TerminalInit, AppTerminalInit, and TerminalRegisterUartTxFunc must also be called at startup when including terminal I/O functionality.</p>
<p>The TerminalHandler is started with the following call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">TerminalInit</span><span class="p">(</span><span class="n">WsfOsSetNextHandler</span><span class="p">(</span><span class="n">TerminalHandler</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="hcihandler">
<h4>HciHandler<a class="headerlink" href="#hcihandler" title="Link to this heading"></a></h4>
<p>The HciHandler facilitates the processing of HCI events from the controller.  The HciHandler is required by all BLE Host applications. The HciHandler is started with the following call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">HciHandlerInit</span><span class="p">(</span><span class="n">WsfOsSetNextHandler</span><span class="p">(</span><span class="n">HciHandler</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="dmhandler">
<h4>DmHandler<a class="headerlink" href="#dmhandler" title="Link to this heading"></a></h4>
<p>The DmHandler is required by the Device Manager.  Most BLE Host applications require the DmHandler.  The exception is applications that are designed to only interface with the HCI layer.</p>
<p>The main function of the DmHandler is to provide a context switch from the application task to the DM task on calls to DM API functions. The DmHandler is started with the following call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">DmHandlerInit</span><span class="p">(</span><span class="n">WsfOsSetNextHandler</span><span class="p">(</span><span class="n">DmHandler</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="l2cslavehandler">
<h4>L2cSlaveHandler<a class="headerlink" href="#l2cslavehandler" title="Link to this heading"></a></h4>
<p>The L2cSlaveHandler is required by devices that accept L2CAP channels.  These are generally devices that advertise and accept ACL connections.  The L2cSlaveHandler is not required by devices that initiate the creation of L2CAP channels (referred to as master devices) unless the master device will operate in a dual slave/master role. The L2cSlaveHandler is started with the following call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">L2cSlaveHandlerInit</span><span class="p">(</span><span class="n">WsfOsSetNextHandler</span><span class="p">(</span><span class="n">L2cSlaveHandler</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="l2ccochandler">
<h4>L2cCocHandler<a class="headerlink" href="#l2ccochandler" title="Link to this heading"></a></h4>
<p>The L2cCocHandler is required by devices that utilize connection-oriented-channels.  These channels are generally only used by applications that make use of the EATT. The L2cCocHandler is started with the following call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">L2cCocHandlerInit</span><span class="p">(</span><span class="n">WsfOsSetNextHandler</span><span class="p">(</span><span class="n">L2cCocHandler</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="atthandler">
<h4>AttHandler<a class="headerlink" href="#atthandler" title="Link to this heading"></a></h4>
<p>The AttHandler is required by devices that use the GATT protocol.  Most applications will require the AttHandler.  There are two exceptions.  The first is applications that have their own communication protocol that sits over the L2CAP.  The second is a broadcast application that only communicates via advertisements.   AttHandler is started with the following call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">AttHandlerInit</span><span class="p">(</span><span class="n">WsfOsSetNextHandler</span><span class="p">(</span><span class="n">AttHandler</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="smphandler">
<h4>SmpHandler<a class="headerlink" href="#smphandler" title="Link to this heading"></a></h4>
<p>The SmpHandler is required by devices that use the BLE Security Manager Protocol for encryption and authentication.  Most applications will require the SmpHandler. SmpHandler is started with the following call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">SmpHandlerInit</span><span class="p">(</span><span class="n">WsfOsSetNextHandler</span><span class="p">(</span><span class="n">SmpHandler</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="apphandler">
<h4>AppHandler<a class="headerlink" href="#apphandler" title="Link to this heading"></a></h4>
<p>The AppHandler is required by all applications. The application executes in the context of the AppHandler. The AppHandler is started with the following call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">AppHandlerInit</span><span class="p">(</span><span class="n">WsfOsSetNextHandler</span><span class="p">(</span><span class="n">AppHandler</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="wdxshandler">
<h4>WdxsHandler<a class="headerlink" href="#wdxshandler" title="Link to this heading"></a></h4>
<p>The WdxsHandler is required by applications using the WDXS, Wireless Data Exchange, service. The WDX is a em | bleu proprietary service that is generally used to expose a simple filesystem over a BLE ACL link.</p>
<p>The WdxsHandler is started with the following call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">WdxsHandlerInit</span><span class="p">(</span><span class="n">WsfOsSetNextHandler</span><span class="p">(</span><span class="n">WdxsHandler</span><span class="p">));</span>
</pre></div>
</div>
<p>The following is a list of <em>initialization functions</em> that may be called in the Stack initialization procedure:</p>
</section>
<section id="appterminalinit">
<h4>AppTerminalInit<a class="headerlink" href="#appterminalinit" title="Link to this heading"></a></h4>
<p>AppTerminalInit is called to initialize the debug terminal.</p>
</section>
<section id="secinit">
<h4>SecInit<a class="headerlink" href="#secinit" title="Link to this heading"></a></h4>
<p>SecInit is called to initialize the security subsystem.  SecInit must be initialized for the BLE Host to encrypt and authenticate a connection.  There are three additional security initialization functions:</p>
<ul class="simple">
<li><p>SecAesInit</p></li>
<li><p>SecCmacInit</p></li>
<li><p>SecEccInit</p></li>
</ul>
<p>When using the older BLE Legacy Pairing security protocol, the BLE Host only requires SecInit and SecAesInit.</p>
<p>When using BLE Secure Connections, the BLE Host requires all four security initialization functions.</p>
</section>
<section id="hcicoreisoinit">
<h4>HciCoreIsoInit<a class="headerlink" href="#hcicoreisoinit" title="Link to this heading"></a></h4>
<p>HciCoreIsoInit initializes HCI ISO resources.  HciCoreIsoInit is required in applications that use Isochronous communication such as audio streams.</p>
</section>
<section id="dmdevprivinit">
<h4>DmDevPrivInit<a class="headerlink" href="#dmdevprivinit" title="Link to this heading"></a></h4>
<p>DmDevPrivInit initializes the DM to support device privacy mode.  In device privacy mode, a device is able to generate random resolvable addresses.</p>
</section>
<section id="dmadvinit-dmextadvinit-dmextperadvwithrspinit">
<h4>DmAdvInit, DmExtAdvInit, DmExtPerAdvWithRspInit<a class="headerlink" href="#dmadvinit-dmextadvinit-dmextperadvwithrspinit" title="Link to this heading"></a></h4>
<p>DmAdvInit initializes the DM to support legacy advertising.  DmExtAdvInit initializes the DM to support legacy, extended advertising, and periodic advertising.  DmExtPerAdvWithRspInit initializes the DM to support legacy advertising, extended advertising, and periodic advertising with a response.  No more than one of these functions should be called.</p>
</section>
<section id="dmscaninit-dmextscaninit-dmextpawrscaninit">
<h4>DmScanInit, DmExtScanInit, DmExtPawrScanInit<a class="headerlink" href="#dmscaninit-dmextscaninit-dmextpawrscaninit" title="Link to this heading"></a></h4>
<p>DmScanInit initializes the DM to support legacy scanning.  DmExtScanInit initializes the DM to support legacy and extended scanning and periodic advertising scanning.  DmExtPawrScanInit initializes the DM to support legacy and extended scanning and periodic advertising with response scanning.  No more than one of these functions should be called.</p>
</section>
<section id="dmconninit">
<h4>DmConnInit<a class="headerlink" href="#dmconninit" title="Link to this heading"></a></h4>
<p>DmConnInit initializes the connection manager.</p>
</section>
<section id="dmconnslaveinit-dmextconnslaveinit">
<h4>DmConnSlaveInit, DmExtConnSlaveInit<a class="headerlink" href="#dmconnslaveinit-dmextconnslaveinit" title="Link to this heading"></a></h4>
<p>DmConnSlaveInit initializes the DM to support accepting legacy connections.  DmExtConnSlaveInit initializes the DM to support accepting both legacy and extended connections.  No more than one of these functions should be called.</p>
</section>
<section id="dmconnmasterinit-dmextconnmasterinit-dmextpawrconnmasterinit">
<h4>DmConnMasterInit, DmExtConnMasterInit, DmExtPawrConnMasterInit<a class="headerlink" href="#dmconnmasterinit-dmextconnmasterinit-dmextpawrconnmasterinit" title="Link to this heading"></a></h4>
<p>DmConnMasterInit initializes the DM to support the initiation of legacy connections.  DmExtConnMasterInit initializes the DM to support the initiation of legacy and extended connections.  DmExtPawrConnMasterInit initializes the DM to support legacy and extended connections and opens an ACL connection to a device synchronized via periodic advertising with a response train.</p>
</section>
<section id="dmsecinit-dmseclescinit">
<h4>DmSecInit, DmSecLescInit<a class="headerlink" href="#dmsecinit-dmseclescinit" title="Link to this heading"></a></h4>
<p>DmSecInit initializes the DM to support legacy pairing.  DmSecLescInit initializes the DM to support legacy pairing and LE Secure Connections.</p>
</section>
<section id="dmprivinit">
<h4>DmPrivInit<a class="headerlink" href="#dmprivinit" title="Link to this heading"></a></h4>
<p>DmPrivInit initializes the DM to support the process of resolving private addresses and of adding private addresses to the resolving list.</p>
</section>
<section id="dmphyinit">
<h4>DmPhyInit<a class="headerlink" href="#dmphyinit" title="Link to this heading"></a></h4>
<p>DmPhyInit initializes the DM to support multiple PHY modes including 2Meg, Coded S2, and Coded S8 PHY modes.</p>
</section>
<section id="dmconncteinit">
<h4>DmConnCteInit<a class="headerlink" href="#dmconncteinit" title="Link to this heading"></a></h4>
<p>DmConnCteInit initializes the DM to support Constant Tone Extensions.</p>
</section>
<section id="dmpastinit">
<h4>DmPastInit<a class="headerlink" href="#dmpastinit" title="Link to this heading"></a></h4>
<p>DmPastInit initializes the DM to support Periodic Advertising Sync Transfer (PAST).</p>
</section>
<section id="dmcisinit">
<h4>DmCisInit<a class="headerlink" href="#dmcisinit" title="Link to this heading"></a></h4>
<p>DmCisInit initializes the DM to support Connected Isochronous Streams (CIS).</p>
</section>
<section id="dmcismasterinit">
<h4>DmCisMasterInit<a class="headerlink" href="#dmcismasterinit" title="Link to this heading"></a></h4>
<p>DmCisMasterInit initializes the DM to support initiating CIS connections.</p>
</section>
<section id="dmcisslaveinit">
<h4>DmCisSlaveInit<a class="headerlink" href="#dmcisslaveinit" title="Link to this heading"></a></h4>
<p>DmCisSlaveInit initializes the DM to support accepting CIS connections.</p>
</section>
<section id="dmbismasterinit">
<h4>DmBisMasterInit<a class="headerlink" href="#dmbismasterinit" title="Link to this heading"></a></h4>
<p>DmBisMasterInit initializes the DM to support initiating BIS connections.</p>
</section>
<section id="dmbisslaveinit">
<h4>DmBisSlaveInit<a class="headerlink" href="#dmbisslaveinit" title="Link to this heading"></a></h4>
<p>DmBisSlaveInit initializes the DM to support accepting BIS connections.</p>
</section>
<section id="dmisoinit">
<h4>DmIsoInit<a class="headerlink" href="#dmisoinit" title="Link to this heading"></a></h4>
<p>initializes the DM to support Isochronous Streams.</p>
</section>
<section id="dmecuinit">
<h4>DmEcuInit<a class="headerlink" href="#dmecuinit" title="Link to this heading"></a></h4>
<p>initializes the DM to support enhanced connection updates (ECU).</p>
</section>
<section id="dmpcinit">
<h4>DmPcInit<a class="headerlink" href="#dmpcinit" title="Link to this heading"></a></h4>
<p>initializes the DM to support Power Control (PC).</p>
</section>
<section id="l2cinit">
<h4>L2cInit<a class="headerlink" href="#l2cinit" title="Link to this heading"></a></h4>
<p>L2cInit initializes the L2CAP.  Generally, all applications require the L2CAP.  The exception is applications developed to only make use of HCI functions.</p>
</section>
<section id="l2cslaveinit">
<h4>L2cSlaveInit<a class="headerlink" href="#l2cslaveinit" title="Link to this heading"></a></h4>
<p>L2cSlaveInit initializes the L2CAP to support accepting L2CAP channels.</p>
</section>
<section id="l2cmasterinit">
<h4>L2cMasterInit<a class="headerlink" href="#l2cmasterinit" title="Link to this heading"></a></h4>
<p>L2cMasterInit initializes the L2CAP to support initiating L2CAP channels.</p>
</section>
<section id="l2ccocinit">
<h4>L2cCocInit<a class="headerlink" href="#l2ccocinit" title="Link to this heading"></a></h4>
<p>L2cCocInit initializes the L2CAP to support Connection Orientated Channels.  Generally, connection-oriented channels are only used in EATT.  A proprietary non-GATT protocol may also make use of COC.</p>
</section>
<section id="attsinit">
<h4>AttsInit<a class="headerlink" href="#attsinit" title="Link to this heading"></a></h4>
<p>AttsInit initializes the ATT to support ATT as a server.</p>
</section>
<section id="attsindinit">
<h4>AttsIndInit<a class="headerlink" href="#attsindinit" title="Link to this heading"></a></h4>
<p>AttsIndInit initializes the ATT to support sending ATT indications and notifications.</p>
</section>
<section id="attcinit">
<h4>AttcInit<a class="headerlink" href="#attcinit" title="Link to this heading"></a></h4>
<p>AttcInit initializes the ATT to support ATT as a client.</p>
</section>
<section id="attcsigninit">
<h4>AttcSignInit<a class="headerlink" href="#attcsigninit" title="Link to this heading"></a></h4>
<p>AttcSignInit initializes the ATT to support signed writes as a client.  This ATT feature is considered to be depreciated.</p>
</section>
<section id="attssigninit">
<h4>AttsSignInit<a class="headerlink" href="#attssigninit" title="Link to this heading"></a></h4>
<p>AttsSignInit initializes the ATT to support signed writes as a server.  This ATT feature is considered to be depreciated.</p>
</section>
<section id="attscsfinit">
<h4>AttsCsfInit<a class="headerlink" href="#attscsfinit" title="Link to this heading"></a></h4>
<p>AttsCsfInit initializes the ATT to support Client Supported Features.</p>
</section>
<section id="smpiscinit">
<h4>SmpiScInit<a class="headerlink" href="#smpiscinit" title="Link to this heading"></a></h4>
<p>SmpiScInit initializes the SMP to support initiating security for legacy pairing and LE Secure Connections.</p>
<p>Note: An app should only call SmpiInit or SmpiScInit, not both.</p>
</section>
<section id="smprscinit">
<h4>SmprScInit<a class="headerlink" href="#smprscinit" title="Link to this heading"></a></h4>
<p>SmprScInit initializes the SMP to support accepting security for legacy pairing and LE Secure Connections.</p>
<p>Note: An app should only call SmprInit or SmprScInit, not both.</p>
</section>
<section id="smpiinit">
<h4>SmpiInit<a class="headerlink" href="#smpiinit" title="Link to this heading"></a></h4>
<p>SmpiInit initializes the SMP to support initiating security for legacy pairing only.</p>
</section>
<section id="smprinit">
<h4>SmprInit<a class="headerlink" href="#smprinit" title="Link to this heading"></a></h4>
<p>SmprInit initializes the SMP to support accepting security for legacy pairing only.</p>
</section>
</section>
<section id="stack-configuration">
<h3>Stack Configuration<a class="headerlink" href="#stack-configuration" title="Link to this heading"></a></h3>
<p>This section details BLE Host Stack Configuration structures and constants.  The stack configuration data structures have default values in cfg_stack.c, but are referenced by a pointer in the stack and can be overridden in the application.</p>
<section id="dmcfg-t">
<h4>dmCfg_t<a class="headerlink" href="#dmcfg-t" title="Link to this heading"></a></h4>
<p>The pDmCfg is depreciated.</p>
</section>
<section id="l2ccfg-t">
<h4>l2cCfg_t<a class="headerlink" href="#l2ccfg-t" title="Link to this heading"></a></h4>
<p>The pL2cCfg is used to set the L2CAP request timeout in seconds.</p>
</section>
<section id="attcfg-t">
<h4>attCfg_t<a class="headerlink" href="#attcfg-t" title="Link to this heading"></a></h4>
<p>The pAttCfg is used to set configuration parameters in the ATT Layer.  The following can be configured in pAttCfg:</p>
<ul class="simple">
<li><p>Discovery idle timeout.</p></li>
<li><p>Default MTU length.</p></li>
<li><p>Transaction timeout in seconds.</p></li>
<li><p>Max number of queued prepared writes.</p></li>
</ul>
</section>
<section id="eattcfg-t">
<h4>eattCfg_t<a class="headerlink" href="#eattcfg-t" title="Link to this heading"></a></h4>
<p>The pEattCfg is used to set configuration parameters in the EATT Layer.  The following can be configured in pEattCfg:</p>
<ul class="simple">
<li><p>The EATT MTU</p></li>
<li><p>The EATT MPS</p></li>
<li><p>Boolean to open EATT channels automatically on connect</p></li>
<li><p>Boolean that is true to require authorization before opening EATT channels.</p></li>
<li><p>The minimum security level to use EATT channels</p></li>
<li><p>The number of EATT channels per connection.</p></li>
<li><p>The priority table for the EATT channels.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">pPriorityTbl</span></code>can be used in one of two ways.  Setting the priority table to an array of integers provides a priority level for each EATT channel.  The EATT will only allocate a channel if the priority passed into an EATT API function is less than or equal to the priority for the channel.  If the priority table is NULL, then the priority passed into the EATT API function corresponds to the channel ID.</p>
<p>For example, if there are 4 EATT channels and the <code class="docutils literal notranslate"><span class="pre">pPriorityTbl</span></code> is set to {1, 1, 2, 2}.  Then calling an EATT API function with priority 1 will result in the use of the first or second CID - provided one is available.  If <code class="docutils literal notranslate"><span class="pre">pPriorityTbl</span></code> is set to NULL, calling an EATT API with priority 1 will always use the second CID.  If the second CID is not available, then the API call will fail.</p>
</section>
<section id="smpcfg-t">
<h4>smpCfg_t<a class="headerlink" href="#smpcfg-t" title="Link to this heading"></a></h4>
<p>The pSmpCfg is used to set configuration parameters in the SMP. The following can be configured in pSmpCfg:</p>
<ul class="simple">
<li><p>/O Capabilities</p></li>
<li><p>Min key length</p></li>
<li><p>Max Key length</p></li>
<li><p>Repeated attempts configuration</p></li>
</ul>
<p>The min and max key length only apply to legacy pairing.  The key length in LE Secure Connections is always 16.</p>
<p>The repeated attempts algorithm calculates a time to delay future pairing attempts after a failed pairing. The BLE Core specification requires the SMP to implement this delay before reattempting pairing after a failed attempt. However, the BLE Core specification leaves the details of how this delay is calculated to the application. em | bleu’s SMP algorithm is configurable.  This algorithm exponentially increases the time before pairing can be reattempted with each paired attempt.  The algorithm exponentially decreases the time if no additional failure happens.</p>
<p>The SMP uses the I/O Capabilities to negotiate the type of security algorithm used in the SMP process.  For more information, see section 2.3 Pairing Methods of Vol 3, Part H: Security Manager Specification of the Core BLE specification.</p>
</section>
<section id="dm-conn-max">
<h4>DM_CONN_MAX<a class="headerlink" href="#dm-conn-max" title="Link to this heading"></a></h4>
<p>DM_CONN_MAX sets the maximum simultaneous connections that can be opened at one time on a device.</p>
</section>
<section id="dm-sync-max">
<h4>DM_SYNC_MAX<a class="headerlink" href="#dm-sync-max" title="Link to this heading"></a></h4>
<p>DM_SYNC_MAX sets the maximum number of periodic advertisements a device can synchronize at one time.</p>
</section>
<section id="dm-num-adv-sets">
<h4>DM_NUM_ADV_SETS<a class="headerlink" href="#dm-num-adv-sets" title="Link to this heading"></a></h4>
<p>DM_NUM_ADV_SETS sets the maximum number of extended advertisement sets that can be configured in the controller at one time.  This value is set to 1 when legacy advertising is being used.</p>
</section>
<section id="dm-num-phys">
<h4>DM_NUM_PHYS<a class="headerlink" href="#dm-num-phys" title="Link to this heading"></a></h4>
<p>DM_NUM_PHYS sets the maximum number of PHY configurations used by the device for establishing connections and for scanning for advertisements.  The PHYs can be configured as 1M, 2M, Coded 2S and Coded 8S.</p>
</section>
<section id="dm-cig-max">
<h4>DM_CIG_MAX<a class="headerlink" href="#dm-cig-max" title="Link to this heading"></a></h4>
<p>DM_CIG_MAX sets the max number of Connected Isochronous Groups, CIG.</p>
</section>
<section id="dm-cis-max">
<h4>DM_CIS_MAX<a class="headerlink" href="#dm-cis-max" title="Link to this heading"></a></h4>
<p>DM_CIS_MAX sets the max number of Connected Isochronous Streams, CIS.</p>
</section>
<section id="dm-big-max">
<h4>DM_BIG_MAX<a class="headerlink" href="#dm-big-max" title="Link to this heading"></a></h4>
<p>DM_BIG_MAX sets the max number of Broadcast Isochronous Groups, BIG.</p>
</section>
<section id="dm-bis-max">
<h4>DM_BIS_MAX<a class="headerlink" href="#dm-bis-max" title="Link to this heading"></a></h4>
<p>DM_BIS_MAX sets the max number of Broadcast Isochronous Streams, BIS.</p>
</section>
<section id="l2c-coc-chan-max">
<h4>L2C_COC_CHAN_MAX<a class="headerlink" href="#l2c-coc-chan-max" title="Link to this heading"></a></h4>
<p>L2C_COC_CHAN_MAX sets the maximum number of L2CAP connection-oriented channels shared by all device connections.</p>
</section>
<section id="l2c-coc-reg-max">
<h4>L2C_COC_REG_MAX<a class="headerlink" href="#l2c-coc-reg-max" title="Link to this heading"></a></h4>
<p>L2C_COC_REG_MAX sets the maximum number of connection-oriented channel registered clients.</p>
</section>
<section id="att-num-simul-write-cmd">
<h4>ATT_NUM_SIMUL_WRITE_CMD<a class="headerlink" href="#att-num-simul-write-cmd" title="Link to this heading"></a></h4>
<p>ATT_NUM_SIMUL_WRITE_CMD sets the maximum number of simultaneous ATT to write commands per bearer per device connection.</p>
</section>
<section id="att-num-simul-ntf">
<h4>ATT_NUM_SIMUL_NTF<a class="headerlink" href="#att-num-simul-ntf" title="Link to this heading"></a></h4>
<p>ATT_NUM_SIMUL_NTF sets the maximum number of simultaneous ATT notifications.</p>
</section>
<section id="eatt-conn-chan-max">
<h4>EATT_CONN_CHAN_MAX<a class="headerlink" href="#eatt-conn-chan-max" title="Link to this heading"></a></h4>
<p>EATT_CONN_CHAN_MAX sets the maximum number of EATT connections per device connection.</p>
</section>
<section id="smp-db-max-devices">
<h4>SMP_DB_MAX_DEVICES<a class="headerlink" href="#smp-db-max-devices" title="Link to this heading"></a></h4>
<p>SMP_DB_MAX_DEVICES sets the maximum number of devices in the SMP database.  The SMP database is used to track devices that have previously tried to pair but failed to complete pairing.</p>
</section>
<section id="hcisetmaxrxacllen">
<h4>HciSetMaxRxAclLen<a class="headerlink" href="#hcisetmaxrxacllen" title="Link to this heading"></a></h4>
<p>The HciSetMaxRxAclLen function is used to set the maximum length ACL packet that can be received by the HCI.</p>
</section>
</section>
<section id="application-framework-event-handling-and-configuration">
<h3>Application Framework Event Handling and Configuration<a class="headerlink" href="#application-framework-event-handling-and-configuration" title="Link to this heading"></a></h3>
<p>The application framework, also referred to as AF or app layer, implements several common BLE procedures.  Each procedure is configurable with a configuration structure in app_api.h.  Unlike the stack initialization, there are no default values for these configuration structures.  The application must define a configuration structure for every AF module used in the application.</p>
<section id="app-handler-configuration">
<h4>App Handler Configuration<a class="headerlink" href="#app-handler-configuration" title="Link to this heading"></a></h4>
<p>The application task is responsible for forwarding ATT and DM messages to the AF.  An example app handler function for a device in a Slave (Peripheral) Role taken from the DATS sample application follows.  You can also compare this function to the DatcHandler function and see the different AF message handling used in a device in both the Master (Central) and Slave (Peripheral) Roles.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">DatsHandler</span><span class="p">(</span><span class="n">wsfEventMask_t</span> <span class="n">event</span><span class="p">,</span> <span class="n">wsfMsgHdr_t</span> <span class="o">*</span><span class="n">pMsg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pMsg</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">APP_TRACE_INFO1</span><span class="p">(</span><span class="s2">&quot;Dats got evt </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">pMsg</span><span class="o">-&gt;</span><span class="n">event</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">process</span> <span class="n">ATT</span> <span class="n">messages</span> <span class="o">*/</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pMsg</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">&gt;=</span> <span class="n">ATT_CBACK_START</span> <span class="o">&amp;&amp;</span> <span class="n">pMsg</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">&lt;=</span> <span class="n">ATT_CBACK_END</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="o">/*</span> <span class="n">process</span> <span class="n">server</span><span class="o">-</span><span class="n">related</span> <span class="n">ATT</span> <span class="n">messages</span> <span class="o">*/</span>
      <span class="n">AppServerProcAttMsg</span><span class="p">(</span><span class="n">pMsg</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">/*</span> <span class="n">process</span> <span class="n">DM</span> <span class="n">messages</span> <span class="o">*/</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pMsg</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">&gt;=</span> <span class="n">DM_CBACK_START</span> <span class="o">&amp;&amp;</span> <span class="n">pMsg</span><span class="o">-&gt;</span><span class="n">event</span> <span class="o">&lt;=</span> <span class="n">DM_CBACK_END</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="o">/*</span> <span class="n">process</span> <span class="n">advertising</span> <span class="ow">and</span> <span class="n">connection</span><span class="o">-</span><span class="n">related</span> <span class="n">messages</span> <span class="o">*/</span>
      <span class="n">AppSlaveProcDmMsg</span><span class="p">((</span><span class="n">dmEvt_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pMsg</span><span class="p">);</span>

      <span class="o">/*</span> <span class="n">process</span> <span class="n">security</span><span class="o">-</span><span class="n">related</span> <span class="n">messages</span> <span class="o">*/</span>
      <span class="n">AppSlaveSecProcDmMsg</span><span class="p">((</span><span class="n">dmEvt_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pMsg</span><span class="p">);</span>

      <span class="o">/*</span> <span class="n">process</span> <span class="n">server</span><span class="o">-</span><span class="n">related</span> <span class="n">DM</span> <span class="n">messages</span> <span class="o">*/</span>
      <span class="n">AppServerProcDmMsg</span><span class="p">(</span><span class="n">pMsg</span><span class="p">,</span> <span class="n">DM_ROLE_SLAVE</span><span class="p">);</span>

<span class="c1">#if WDXS_INCLUDED == 1</span>
      <span class="o">/*</span> <span class="n">process</span> <span class="n">WDXS</span><span class="o">-</span><span class="n">related</span> <span class="n">messages</span> <span class="o">*/</span>
      <span class="n">WdxsProcDmMsg</span><span class="p">((</span><span class="n">dmEvt_t</span><span class="o">*</span><span class="p">)</span> <span class="n">pMsg</span><span class="p">);</span>
<span class="c1">#endif /* WDXS_INCLUDED */</span>
    <span class="p">}</span>

    <span class="o">/*</span> <span class="n">perform</span> <span class="n">profile</span> <span class="ow">and</span> <span class="n">user</span> <span class="n">interface</span><span class="o">-</span><span class="n">related</span> <span class="n">operations</span> <span class="o">*/</span>
    <span class="n">datsProcMsg</span><span class="p">((</span><span class="n">dmEvt_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pMsg</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The following sections detail functions that may be called to process system messages in the various modules in the AF. To conserve system resources, only include functions for AF modules required by the application.</p>
<section id="appdiscprocattmsg-and-appdiscprocdmmsg">
<h5>AppDiscProcAttMsg and AppDiscProcDmMsg<a class="headerlink" href="#appdiscprocattmsg-and-appdiscprocdmmsg" title="Link to this heading"></a></h5>
<p>The AppDiscProcAttMsg and AppDiscProcDmMsg handlers process ATT and DM messages respectively for the purpose of service discovery and service configuration.  These functions should be included in applications that are Clients of BLE Services and perform service discovery.</p>
</section>
<section id="appserverprocattmsg">
<h5>AppServerProcAttMsg<a class="headerlink" href="#appserverprocattmsg" title="Link to this heading"></a></h5>
<p>The AppServerProcAttMsg handler processes ATT messages for the purpose of calculating a service database hash and handling service-changed GATT messages.  This function should be included in applications that support database hash and service change.</p>
</section>
<section id="appserverprocdmmsg">
<h5>AppServerProcDmMsg<a class="headerlink" href="#appserverprocdmmsg" title="Link to this heading"></a></h5>
<p>The AppServerProcDmMsg handler stores the LTK in the app database on pair complete.  This function should be processed in all applications that perform pairing and store the LTK in the app database.</p>
</section>
<section id="appmasterprocdmmsg">
<h5>AppMasterProcDmMsg<a class="headerlink" href="#appmasterprocdmmsg" title="Link to this heading"></a></h5>
<p>The AppMasterProcDmMsg handler is used to control scanning, managing connections, and resolving private addresses.  This function should be used on devices that are Clients of BLE services and are in a central role.</p>
</section>
<section id="appmastersecprocdmmsg">
<h5>AppMasterSecProcDmMsg<a class="headerlink" href="#appmastersecprocdmmsg" title="Link to this heading"></a></h5>
<p>The AppMasterSecProcDmMsg handler manages the SMP process for devices in a central role.</p>
</section>
<section id="appslaveprocdmmsg">
<h5>AppSlaveProcDmMsg<a class="headerlink" href="#appslaveprocdmmsg" title="Link to this heading"></a></h5>
<p>The AppSlaveProcDmMsg is used to control accepting connection and connection updates in devices in the peripheral role.</p>
</section>
<section id="appslavesecprocdmmsg">
<h5>AppSlaveSecProcDmMsg<a class="headerlink" href="#appslavesecprocdmmsg" title="Link to this heading"></a></h5>
<p>The AppSlaveSecProcDmMsg handler manages the SMP process for devices in a peripheral role.</p>
</section>
</section>
<section id="application-framework-configuration">
<h4>Application Framework Configuration<a class="headerlink" href="#application-framework-configuration" title="Link to this heading"></a></h4>
<p>Each feature of the AF has a configuration structure.  Pointers to these configuration structures must be set in the application handler init functions.  The following example of setting up the AF configuration structure pointers is taken from the DATS sample application’s <code class="docutils literal notranslate"><span class="pre">DatsHandlerInit</span></code>function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">/*</span> <span class="n">Set</span> <span class="n">configuration</span> <span class="n">pointers</span> <span class="o">*/</span>
  <span class="n">pAppSlaveCfg</span> <span class="o">=</span> <span class="p">(</span><span class="n">appSlaveCfg_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">datsSlaveCfg</span><span class="p">;</span>
  <span class="n">pAppAdvCfg</span> <span class="o">=</span> <span class="p">(</span><span class="n">appAdvCfg_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">datsAdvCfg</span><span class="p">;</span>
  <span class="n">pAppSecCfg</span> <span class="o">=</span> <span class="p">(</span><span class="n">appSecCfg_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">datsSecCfg</span><span class="p">;</span>
  <span class="n">pAppUpdateCfg</span> <span class="o">=</span> <span class="p">(</span><span class="n">appUpdateCfg_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">datsUpdateCfg</span><span class="p">;</span>
  <span class="n">pSmpCfg</span> <span class="o">=</span> <span class="p">(</span><span class="n">smpCfg_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">datsSmpCfg</span><span class="p">;</span>
  <span class="n">pAttCfg</span> <span class="o">=</span> <span class="p">(</span><span class="n">attCfg_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">datsAttCfg</span><span class="p">;</span>
</pre></div>
</div>
<p>The following sections contain more information about the configuration structures for each AF module.</p>
<section id="appadvcfg-t">
<h5>appAdvCfg_t<a class="headerlink" href="#appadvcfg-t" title="Link to this heading"></a></h5>
<p>The pAppAdvCfg is used to set the advertising duration and interval for up to APP_ADV_NUM_CFG advertisements when using legacy advertising. The pAppAdvCfg is used in conjunction with the <em>AppAdvSetData, AppAdvSetAdValue, AppAdvStart, and AppAdvStop</em> functions.</p>
</section>
<section id="appextadvcfg-t">
<h5>appExtAdvCfg_t<a class="headerlink" href="#appextadvcfg-t" title="Link to this heading"></a></h5>
<p>The pAppExtAdvCfg is used to define extended advertising sets.  DM_NUM_ADV_SETS number of extended advertising sets are configured. The pAppExtAdvCfg is used in conjunction with the <em>AppExtAdvSetData, AppExtAdvStart, AppExtAdvStop, AppExtAdvSetAdValue, AppExtAdvAppendAdValue, and AppExtSetAdvType</em> functions.</p>
</section>
<section id="appslavecfg-t">
<h5>appSlaveCfg_t<a class="headerlink" href="#appslavecfg-t" title="Link to this heading"></a></h5>
<p>The pAppSlaveCfg is used to set the maximum number of connections on a slave (peripheral) device.</p>
</section>
<section id="appmastercfg-t">
<h5>appMasterCfg_t<a class="headerlink" href="#appmastercfg-t" title="Link to this heading"></a></h5>
<p>The pAppMasterCfg is used to set scan parameters for legacy scanning on devices in the central role.</p>
</section>
<section id="appextmastercfg-t">
<h5>appExtMasterCfg_t<a class="headerlink" href="#appextmastercfg-t" title="Link to this heading"></a></h5>
<p>The pAppExtMasterCfg is used to set extended scan parameters for scanning for extended advertisements on devices in the central role.</p>
</section>
<section id="appseccfg-t">
<h5>appSecCfg_t<a class="headerlink" href="#appseccfg-t" title="Link to this heading"></a></h5>
<p>The pAppSecCfg is used to set security parameters on devices in both the central and peripheral roles.  The following configuration values can be set:</p>
<ul class="simple">
<li><p>The authentication and bonding flags.  These flags indicate a bond is being requested, if man-in-the-middle (MITM) authenticated pairing is being requested, if secure connections (SC) are requested, and if key press notifications are requested (KP).</p></li>
<li><p>DM_AUTH_BOND_FLAG</p></li>
<li><p>DM_AUTH_MITM_FLAG</p></li>
<li><p>DM_AUTH_SC_FLAG</p></li>
<li><p>DM_AUTH_KP_FLAG</p></li>
<li><p>A mask of keys for the initiator to distribute.</p></li>
<li><p>DM_KEY_DIST_LTK</p></li>
<li><p>DM_KEY_DIST_IRK</p></li>
<li><p>DM_KEY_DIST_CSRK</p></li>
<li><p>A mask of keys for the responder to distribute.</p></li>
<li><p>A boolean that is true if Out-Of-Band pairing is enabled.</p></li>
<li><p>A boolean that is true if security should be automatically initiated on connection.</p></li>
</ul>
</section>
<section id="appupdatecfg-t">
<h5>appUpdateCfg_t<a class="headerlink" href="#appupdatecfg-t" title="Link to this heading"></a></h5>
<p>The pAppUpdateCfg defines the connection parameters that are desired by the device in the connection update procedure.</p>
<section id="connection-interval">
<h6>Connection Interval<a class="headerlink" href="#connection-interval" title="Link to this heading"></a></h6>
<p>The connection interval defines how frequently the controller wakes to communicate. The pAppUpdateCfg contains a min and max connection interval.  The app layer requests these values in the connection update procedure, but the peer is not required to acquiesce.</p>
</section>
<section id="connection-latency">
<h6>Connection Latency<a class="headerlink" href="#connection-latency" title="Link to this heading"></a></h6>
<p>The connection latency, also called the slave or peripheral latency, is the number of connection events to skip on the slave device.  This field gives the slave the option of sleeping for longer periods of time when the connection interval is short by skipping intervals.</p>
</section>
<section id="supervision-timeout">
<h6>Supervision Timeout<a class="headerlink" href="#supervision-timeout" title="Link to this heading"></a></h6>
<p>The supervision timeout is the maximum period of time to wait for communication from a peer.  After the supervision timeout is reached the peer is considered no longer connected.</p>
</section>
</section>
<section id="appreqactcfg-t">
<h5>appReqActCfg_t<a class="headerlink" href="#appreqactcfg-t" title="Link to this heading"></a></h5>
<p>The pAppReqActCfg contains an action to perform on a remote connection parameter request.  The actions can be APP_ACT_ACCEPT, APP_ACT_REJECT, or APP_ACT_NONE.</p>
</section>
<section id="appdisccfg-t">
<h5>appDiscCfg_t<a class="headerlink" href="#appdisccfg-t" title="Link to this heading"></a></h5>
<p>The pAppDiscCfg contains configuration for the discovery on master (central) devices.  The pAppDiscCfg has the following parameters:</p>
<ul class="simple">
<li><p>A boolean that waits for a secure connection before starting discovery if true.</p></li>
<li><p>A boolean that reads the att database hash to check for a change before performing discovery.</p></li>
</ul>
</section>
<section id="appcfg-t">
<h5>appCfg_t<a class="headerlink" href="#appcfg-t" title="Link to this heading"></a></h5>
<p>The pAppCfg contains miscellaneous configurations used in client applications.  The pAppCfg has the following parameters:</p>
<ul class="simple">
<li><p>A boolean that is true to abort discovery if any required service is not found.</p></li>
<li><p>A boolean to disconnect if an ATT transaction times out.</p></li>
</ul>
</section>
</section>
</section>
<section id="server-ccc-tables">
<h3>Server CCC Tables<a class="headerlink" href="#server-ccc-tables" title="Link to this heading"></a></h3>
<p>Server CCC tables are only used in applications that expose a service as a server. Generally, services are only exposed on on slave (peripheral) devices, but sometimes a master (central) device exposes a service too.  An example Server CCC Table from the fit application follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/*! enumeration of client characteristic configuration descriptors */
enum
{
  FIT_GATT_SC_CCC_IDX,                    /*! GATT service, service changed characteristic */
  FIT_HRS_HRM_CCC_IDX,                    /*! Heart rate service, heart rate monitor characteristic */
  FIT_BATT_LVL_CCC_IDX,                   /*! Battery service, battery level characteristic */
  FIT_RSCS_SM_CCC_IDX,                    /*! Runninc speed and cadence measurement characteristic */
  FIT_NUM_CCC_IDX
};

/*! client characteristic configuration descriptors settings, indexed by above enumeration */
static const attsCccSet_t fitCccSet[FIT_NUM_CCC_IDX] =
{
  /* cccd handle          value range               security level */
  {GATT_SC_CH_CCC_HDL,    ATT_CLIENT_CFG_INDICATE,  DM_SEC_LEVEL_NONE},   /* FIT_GATT_SC_CCC_IDX */
  {HRS_HRM_CH_CCC_HDL,    ATT_CLIENT_CFG_NOTIFY,    DM_SEC_LEVEL_NONE},   /* FIT_HRS_HRM_CCC_IDX */
  {BATT_LVL_CH_CCC_HDL,   ATT_CLIENT_CFG_NOTIFY,    DM_SEC_LEVEL_NONE},   /* FIT_BATT_LVL_CCC_IDX */
  {RSCS_RSM_CH_CCC_HDL,   ATT_CLIENT_CFG_NOTIFY,    DM_SEC_LEVEL_NONE}    /* FIT_RSCS_SM_CCC_IDX */
};
</pre></div>
</div>
<p>The ATT module that manages CCC values must store CCC values associated with 16-bit handles in an array.  Therefore, an indirection table must be made in the application that maps the 16-bit handle to a zero-based index.  Additionally, the indirection table also contains information about if the CCC is for ATT indicate, ATT notify or both, and also the required security level for writing the CCC value.  The CCC table is registered with the ATT using the AttsCccRegister function.</p>
</section>
<section id="server-advertisement">
<h3>Server Advertisement<a class="headerlink" href="#server-advertisement" title="Link to this heading"></a></h3>
<p>Advertisements are transmitted by slave (peripheral) devices. Advertisements are constructed from advertising data (AD) values.  Each value has a 1-byte length field followed by a 1-byte AD type field followed by data associated with the AD type.  An example from the fit sample application follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/*! advertising data, discoverable mode */
static const uint8_t fitAdvDataDisc[] =
{
  /*! flags */
  2,                                      /*! length */
  DM_ADV_TYPE_FLAGS,                      /*! AD type */
  DM_FLAG_LE_GENERAL_DISC |               /*! flags */
  DM_FLAG_LE_BREDR_NOT_SUP,

  /*! tx power */
  2,                                      /*! length */
  DM_ADV_TYPE_TX_POWER,                   /*! AD type */
  0,                                      /*! tx power */

  /*! service UUID list */
  9,                                      /*! length */
  DM_ADV_TYPE_16_UUID,                    /*! AD type */
  UINT16_TO_BYTES(ATT_UUID_HEART_RATE_SERVICE),
  UINT16_TO_BYTES(ATT_UUID_RUNNING_SPEED_SERVICE),
  UINT16_TO_BYTES(ATT_UUID_DEVICE_INFO_SERVICE),
  UINT16_TO_BYTES(ATT_UUID_BATTERY_SERVICE)
};
</pre></div>
</div>
<p>The first value in the advertising data is the advertisement flags.  In this case, the flags indicate that the device is in general discoverable mode and BR/EDR is not supported.  The next advertising value is the TX power.  The final value contains the UUID of the services supported by the fit application.  The advertisement is stored in the app layer by calling the *AppAdvSetData or AppExtAdvSetData *function depending on the use of legacy or extended advertising respectively.</p>
<p>An application can start advertising by calling the AppAdvStart or AppExtAdvStart function.  An application can stop advertising by calling the AppAdvStop or AppExtAdvStop function.  When advertising starts, the DM notifies the application that advertising has started using the DM_ADV_START_IND (legacy) or DM_ADV_SET_START_IND (extended) event. When advertising stops, the DM notifies the application that advertising has stopped using the DM_ADV_STOP_IND (legacy) or DM_ADV_SET_STOP_IND (extended) event.</p>
<p>For a list of advertisement types (AD types), see the dm_api.h header file.</p>
<p>Alternative to declaring const advertising data, an application can use the *AppAdvSetAdValue *API to add or modify the data associated with an advertising type.</p>
</section>
<section id="client-discovery-data">
<h3>Client Discovery Data<a class="headerlink" href="#client-discovery-data" title="Link to this heading"></a></h3>
<p>Client Discovery Data consists of tables that govern the Service Discovery process in the App Layer.  The following code is an example of client discovery data taken from the watch sample application in ble-apps/sources/watch/watch_main.c.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/*! Discovery states:  enumeration of services to be discovered */
enum
{
  WATCH_DISC_SLAVE_GATT_SVC,      /* GATT service */
  WATCH_DISC_SLAVE_CTS_SVC,       /* Current Time service */
  WATCH_DISC_SLAVE_ANS_SVC,       /* Alert Notification service */
  WATCH_DISC_SLAVE_PASS_SVC,      /* Phone Alert Status service */
  WATCH_DISC_SLAVE_SVC_MAX        /* Discovery complete */
};

/*! the Client handle list, watchCb.hdlList[], is set as follows:
 *
 *  ------------------------------- &lt;- WATCH_DISC_GATT_START
 *  | GATT handles                |
 *  |...                          |
 *  ------------------------------- &lt;- WATCH_DISC_CTS_START
 *  | CTS handles                 |
 *  | ...                         |
 *  ------------------------------- &lt;- WATCH_DISC_ANS_START
 *  | ANS handles                 |
 *  | ...                         |
 *  ------------------------------- &lt;- WATCH_DISC_PASS_START
 *  | PASS handles                |
 *  | ...                         |
 *  -------------------------------
 */

/*! Start of each service&#39;s handles in the the handle list */
#define WATCH_DISC_GATT_START           0
#define WATCH_DISC_CTS_START            (WATCH_DISC_GATT_START + GATT_HDL_LIST_LEN)
#define WATCH_DISC_ANS_START            (WATCH_DISC_CTS_START + TIPC_CTS_HDL_LIST_LEN)
#define WATCH_DISC_PASS_START           (WATCH_DISC_ANS_START + ANPC_ANS_HDL_LIST_LEN)
#define WATCH_DISC_SLAVE_HDL_LIST_LEN   (WATCH_DISC_PASS_START + PASPC_PASS_HDL_LIST_LEN)

/*! Pointers into handle list for each service&#39;s handles */
static uint16_t *pWatchSlvGattHdlList = &amp;watchCb.hdlSlaveList[WATCH_DISC_GATT_START];
static uint16_t *pWatchCtsHdlList =     &amp;watchCb.hdlSlaveList[WATCH_DISC_CTS_START];
static uint16_t *pWatchAnsHdlList =     &amp;watchCb.hdlSlaveList[WATCH_DISC_ANS_START];
static uint16_t *pWatchPassHdlList =    &amp;watchCb.hdlSlaveList[WATCH_DISC_PASS_START];
</pre></div>
</div>
<p>The first table is an enumeration of the services that will be discovered during the service discovery process. In the service discovery process, the App Layer will discover services and attributes on the peer and fill in a list of attribute handles.</p>
<p>The WATCH_DISC_GATT_START, WATCH_DISC_CTS_START, etc. define the starting location to store attribute handles in hdlSlaveList for each service.  The pWatchSlvGattHdlList, pWatchCtsHdlList, etc. are pointers to these starting locations.</p>
<p>The discovery process is implemented in the App Layer, but the app layer calls the watchDiscCback callback at each step in the discovery process.  When discovery of a particular service ends, the callback will be called with APP_DISC_CMPL or APP_DISC_FAILED. The application can choose to move on to the discovery configuration state, or the application can choose to perform discovery on another service. In the following code, the watch app begins TIP discovery after CTS discovery ends.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>        <span class="k">if</span> <span class="p">(</span><span class="n">watchCb</span><span class="o">.</span><span class="n">discState</span> <span class="o">==</span> <span class="n">WATCH_DISC_SLAVE_CTS_SVC</span><span class="p">)</span>
        <span class="p">{</span>
          <span class="o">/*</span> <span class="n">discover</span> <span class="n">current</span> <span class="n">time</span> <span class="n">service</span> <span class="o">*/</span>
          <span class="n">TipcCtsDiscover</span><span class="p">(</span><span class="n">connId</span><span class="p">,</span> <span class="n">pWatchCtsHdlList</span><span class="p">);</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>When restoring service handles from NVM, the handle list will not be filled by calls into the profile to perform service discovery, rather, the handles will be copied from the app database.  Some profiles store a pointer to the attribute handle list in a control block in the profile. These profiles expose an API to set the handle list without performing discovery.  This is more common in audio and mesh profiles than in sensor profiles.  In these cases, the handles should be set on APP_DISC_CFG_CONN_START.  See BapcAscSetHandles as an example.</p>
</section>
<section id="client-configuration-data">
<h3>Client Configuration Data<a class="headerlink" href="#client-configuration-data" title="Link to this heading"></a></h3>
<p>On client devices, after Service Discovery is complete, the app layer performs service configuration.  In the service configuration step attributes are read and/or written according to a table of attcDiscCfg_t.  An example table from the watch sample application follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">List</span> <span class="n">of</span> <span class="n">characteristics</span> <span class="n">to</span> <span class="n">configure</span> <span class="n">on</span> <span class="n">connection</span> <span class="n">setup</span> <span class="o">*/</span>
<span class="n">static</span> <span class="n">const</span> <span class="n">attcDiscCfg_t</span> <span class="n">watchDiscConnCfgList</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
  <span class="o">/*</span> <span class="n">Read</span><span class="p">:</span>  <span class="n">ANS</span> <span class="n">Supported</span> <span class="n">new</span> <span class="n">alert</span> <span class="n">category</span> <span class="o">*/</span>
  <span class="p">{</span><span class="n">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">ANPC_ANS_SNAC_HDL_IDX</span> <span class="o">+</span> <span class="n">WATCH_DISC_ANS_START</span><span class="p">)},</span>

  <span class="o">/*</span> <span class="n">Read</span><span class="p">:</span>  <span class="n">ANS</span> <span class="n">Supported</span> <span class="n">unread</span> <span class="n">alert</span> <span class="n">category</span> <span class="o">*/</span>
  <span class="p">{</span><span class="n">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">ANPC_ANS_SUAC_HDL_IDX</span> <span class="o">+</span> <span class="n">WATCH_DISC_ANS_START</span><span class="p">)},</span>

  <span class="o">/*</span> <span class="n">Read</span><span class="p">:</span>  <span class="n">PASS</span> <span class="n">Alert</span> <span class="n">status</span> <span class="o">*/</span>
  <span class="p">{</span><span class="n">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">PASPC_PASS_AS_HDL_IDX</span> <span class="o">+</span> <span class="n">WATCH_DISC_PASS_START</span><span class="p">)},</span>

  <span class="o">/*</span> <span class="n">Write</span><span class="p">:</span>  <span class="n">ANS</span> <span class="n">Control</span> <span class="n">point</span> <span class="s2">&quot;Enable New Alert Notification&quot;</span> <span class="o">*/</span>
  <span class="p">{</span><span class="n">watchAncpEnNewVal</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">watchAncpEnNewVal</span><span class="p">),</span> <span class="p">(</span><span class="n">ANPC_ANS_ANCP_HDL_IDX</span> <span class="o">+</span> <span class="n">WATCH_DISC_ANS_START</span><span class="p">)},</span>

  <span class="o">/*</span> <span class="n">Write</span><span class="p">:</span>  <span class="n">ANS</span> <span class="n">Control</span> <span class="n">point</span> <span class="s2">&quot;Notify New Alert Immediately&quot;</span> <span class="o">*/</span>
  <span class="p">{</span><span class="n">watchAncpNotNewVal</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">watchAncpNotNewVal</span><span class="p">),</span> <span class="p">(</span><span class="n">ANPC_ANS_ANCP_HDL_IDX</span> <span class="o">+</span> <span class="n">WATCH_DISC_ANS_START</span><span class="p">)},</span>

  <span class="o">/*</span> <span class="n">Write</span><span class="p">:</span>  <span class="n">ANS</span> <span class="n">Control</span> <span class="n">point</span> <span class="s2">&quot;Enable Unread Alert Status Notification&quot;</span> <span class="o">*/</span>
  <span class="p">{</span><span class="n">watchAncpEnUnrVal</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">watchAncpEnUnrVal</span><span class="p">),</span> <span class="p">(</span><span class="n">ANPC_ANS_ANCP_HDL_IDX</span> <span class="o">+</span> <span class="n">WATCH_DISC_ANS_START</span><span class="p">)},</span>

  <span class="o">/*</span> <span class="n">Write</span><span class="p">:</span>  <span class="n">ANS</span> <span class="n">Control</span> <span class="n">point</span> <span class="s2">&quot;Notify Unread Alert Status Immediately&quot;</span> <span class="o">*/</span>
  <span class="p">{</span><span class="n">watchAncpNotUnrVal</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">watchAncpNotUnrVal</span><span class="p">),</span> <span class="p">(</span><span class="n">ANPC_ANS_ANCP_HDL_IDX</span> <span class="o">+</span> <span class="n">WATCH_DISC_ANS_START</span><span class="p">)}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>When the pValue parameter of attcDiscCfg_t is NULL, the configuration operation is a read.  The value length is ignored on a read.  The handle index is the index of the attribute relative to the service’s attribute handles plus the starting point for the service’s handles in the global array of handles.</p>
<p>When the pValue parameter is not NULL, the configuration operation is written.  The value pointed to by pValue is written to the server’s service attribute with the given handle.</p>
</section>
<section id="ble-data-flow">
<h3>BLE Data Flow<a class="headerlink" href="#ble-data-flow" title="Link to this heading"></a></h3>
<p>Below is a diagram outlining how data flows between HW, BLE stack, AF, and user application. Note that all
incoming communications from the BLE stack first goes to the user application via event callback. Outgoing
communication from the user application is done via combination of AF, profile, and DM API calls. For
non-BLE related traffic, other data paths may exist.</p>
<a class="reference internal image-reference" href="_images/ble_data_flow_diagram.png"><img alt="_images/ble_data_flow_diagram.png" src="_images/ble_data_flow_diagram.png" style="width: 800px;" /></a>
<p><strong>Note</strong>: The user might talk to the HW directly only when using non-BLE related HW. For example, a transport
or a HW peripheral.</p>
</section>
<section id="application-framework-af-and-device-manager-dm-feature-comparison">
<h3>Application Framework (AF) and Device Manager (DM) Feature Comparison<a class="headerlink" href="#application-framework-af-and-device-manager-dm-feature-comparison" title="Link to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Feature (Y = supported, N = not supported)</p></th>
<th class="head"><p>AF</p></th>
<th class="head"><p>DM</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ATT Management</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
</tr>
<tr class="row-odd"><td><p>Advertising Management (legacy &amp; extended)</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>Connection Management</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>Connection PHY Preferences Y</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>Direction Finding</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>Filter Accept List</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>LE Isochronous Channels</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>LE Power Control</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>LE Privacy Management</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>Pairing Management</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>Periodic Advertising Sync Transfer</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>Periodic List</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>Persistant Bonding Info</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
</tr>
<tr class="row-odd"><td><p>Resolving List</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>Security Management</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>Service Discovery</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
</tr>
<tr class="row-even"><td><p>Syncronization Management</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>Vendor Specific Functionality</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
</tr>
</tbody>
</table>
<section id="adding-application-specific-ble-features-to-an-application">
<h4>Adding Application-Specific BLE Features to an Application<a class="headerlink" href="#adding-application-specific-ble-features-to-an-application" title="Link to this heading"></a></h4>
<p>Before delving into the process of adding specific features to an application, it is essential to first gain an understanding of the Application Framework (AF) and the Device Manager (DM), as well as when and how to utilize each of them. The AF serves as a comprehensive foundation for application development, while the DM plays a crucial role in managing device-related functionalities. This section aims to provide a detailed overview of both the AF and DM, including a comprehensive list of features offered by each layer and an architectural overview. By familiarizing ourselves with these key components, we can effectively proceed with incorporating application-specific BLE features into our application.</p>
</section>
<section id="af-capabilities">
<h4>AF Capabilities<a class="headerlink" href="#af-capabilities" title="Link to this heading"></a></h4>
<p>This section explores the various capabilities of the AF.</p>
<section id="bonding-information-management">
<h5>Bonding Information Management<a class="headerlink" href="#bonding-information-management" title="Link to this heading"></a></h5>
<p>The AF maintains a persistent RAM database comprising details of all bonded devices, including but not
limited to, BD Address, type, keys, ATTS, ATTC, and profile information. Consult the appDb_t section in
the profiles API documentation for further details. As of now, the AF does not support storage of bonding
information in Non-Volatile Memory (NVM).</p>
</section>
<section id="advertising-management">
<h5>Advertising Management<a class="headerlink" href="#advertising-management" title="Link to this heading"></a></h5>
<p>The AF automates advertising functionality for devices operating in the peripheral role using both legacy and
extended advertising. This encompasses advertising configurations such as intervals, durations, PDUs, extended
advertising events, and advertising data for different modes.</p>
<p>Additionally, the AF provides discoverable, connectable, and auto modes for advertising. When using the auto
mode, advertising is set to discoverable or connectable based on the bonding information.</p>
<p>The AF currently does not support:</p>
<ul class="simple">
<li><p>User-defined filter policies (must be configured via the DM)</p></li>
</ul>
</section>
<section id="synchronization-management">
<h5>Synchronization Management<a class="headerlink" href="#synchronization-management" title="Link to this heading"></a></h5>
<p>The AF can be configured to synchronize with periodic advertising from specified advertisers.</p>
</section>
<section id="scanning-management">
<h5>Scanning Management<a class="headerlink" href="#scanning-management" title="Link to this heading"></a></h5>
<p>For devices in the central role, the AF handles scanning-related functionalities, including scanning intervals,
windows, durations, GAP discovery modes, scan types, and scan periods.</p>
<p>The AF currently does not support:</p>
<ul class="simple">
<li><p>Configuring scanning to filter duplicates (it will always filter duplicates).</p></li>
<li><p>User defined filter policies (filter accept list filtering).</p></li>
</ul>
</section>
<section id="service-and-characteristic-discovery">
<h5>Service and Characteristic Discovery<a class="headerlink" href="#service-and-characteristic-discovery" title="Link to this heading"></a></h5>
<p>In the central role, the AF manages service discovery, which can either occur automatically or be initiated by
the user application. Secure connections can also be required before initiating service discovery. In addition
to comminicating with the DM, the AF interacts with ATT to perform discovery operations. The interactions
between ATT and the AF are somewhat complex making the AF an attractive option for central devices
requiring service discovery.</p>
</section>
<section id="connection-management">
<h5>Connection Management<a class="headerlink" href="#connection-management" title="Link to this heading"></a></h5>
<p>The AF takes charge of connection parameter updates, multi-connection management, and bonding preferences.
It also maintains connection-related data in its database.</p>
</section>
<section id="security-management">
<h5>Security Management<a class="headerlink" href="#security-management" title="Link to this heading"></a></h5>
<p>The AF can manage pairing, encryption, and other security procedures either automatically or upon instruction
from the user application.</p>
</section>
<section id="additional-rpa-resolution">
<h5>Additional RPA Resolution<a class="headerlink" href="#additional-rpa-resolution" title="Link to this heading"></a></h5>
<p>The AF can resolve addresses not handled by the controller, utilizing stored IRKs from its database.</p>
</section>
<section id="simplified-dm-interfaces">
<h5>Simplified DM Interfaces<a class="headerlink" href="#simplified-dm-interfaces" title="Link to this heading"></a></h5>
<p>The AF offers API calls that internally invoke corresponding DM APIs, simplifying the interface exposed to the
user application.</p>
</section>
<section id="af-events">
<h5>AF Events<a class="headerlink" href="#af-events" title="Link to this heading"></a></h5>
<p>The AF relies on the user application to forward the following received host events:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>DM Events</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>DM_RESET_CMPL_IND</p></td>
<td><p>Reset complete</p></td>
</tr>
<tr class="row-odd"><td><p>DM_ADV_SET_STOP_IND</p></td>
<td><p>Advertising set(s) stopped</p></td>
</tr>
<tr class="row-even"><td><p>DM_ADV_STOP_IND</p></td>
<td><p>Advertising stopped</p></td>
</tr>
<tr class="row-odd"><td><p>DM_CONN_OPEN_IND</p></td>
<td><p>Connection opened</p></td>
</tr>
<tr class="row-even"><td><p>DM_CONN_CLOSE_IND</p></td>
<td><p>Connection closed</p></td>
</tr>
<tr class="row-odd"><td><p>DM_CONN_UPDATE_IND</p></td>
<td><p>Connection update complete</p></td>
</tr>
<tr class="row-even"><td><p>DM_PRIV_RESOLVED_ADDR_IND</p></td>
<td><p>Private address resolved</p></td>
</tr>
<tr class="row-odd"><td><p>DM_REM_CONN_PARAM_REQ_IND</p></td>
<td><p>Remote connection parameter requested</p></td>
</tr>
<tr class="row-even"><td><p>DM_REMOTE_FEATURES_IND</p></td>
<td><p>Remote features from peer device</p></td>
</tr>
<tr class="row-odd"><td><p>DM_SEC_PAIR_CMPL_IND</p></td>
<td><p>Pairing completed successfully</p></td>
</tr>
<tr class="row-even"><td><p>DM_SEC_PAIR_FAIL_IND</p></td>
<td><p>Pairing failed or other security failure</p></td>
</tr>
<tr class="row-odd"><td><p>DM_SEC_ENCRYPT_IND</p></td>
<td><p>Connection encrypted</p></td>
</tr>
<tr class="row-even"><td><p>DM_SEC_ENCRYPT_FAIL_IND</p></td>
<td><p>Encryption failed</p></td>
</tr>
<tr class="row-odd"><td><p>DM_SEC_KEY_IND Security</p></td>
<td><p>key indication</p></td>
</tr>
<tr class="row-even"><td><p>DM_SEC_PAIR_IND</p></td>
<td><p>Incoming pairing request from master</p></td>
</tr>
<tr class="row-odd"><td><p>DM_SEC_LTK_REQ_IND</p></td>
<td><p>LTK requested for encyption</p></td>
</tr>
<tr class="row-even"><td><p>DM_SEC_SLAVE_REQ_IND</p></td>
<td><p>Incoming security request from slave</p></td>
</tr>
<tr class="row-odd"><td><p>DM_PRIV_SET_ADDR_RES_ENABLE_IND</p></td>
<td><p>Address resolving enable set</p></td>
</tr>
<tr class="row-even"><td><p>DM_PRIV_ADD_DEV_TO_RES_LIST_IND</p></td>
<td><p>Device added to resolving list</p></td>
</tr>
<tr class="row-odd"><td><p>DM_PRIV_REM_DEV_FROM_RES_LIST_IND</p></td>
<td><p>Device removed from resolving list</p></td>
</tr>
<tr class="row-even"><td><p>DM_SCAN_START_IND Scanning</p></td>
<td><p>started</p></td>
</tr>
<tr class="row-odd"><td><p>DM_SCAN_REPORT_IND</p></td>
<td><p>Scan data received from peer device</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>ATT Events</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ATTS_DB_HASH_CALC_CMPL_IND</p></td>
<td><p>Database hash calculation complete</p></td>
</tr>
<tr class="row-odd"><td><p>ATTS_HANDLE_VALUE_CNF</p></td>
<td><p>Handle value confirmation</p></td>
</tr>
<tr class="row-even"><td><p>ATTC_READ_BY_TYPE_RSP</p></td>
<td><p>Read by type value response</p></td>
</tr>
<tr class="row-odd"><td><p>ATTC_FIND_BY_TYPE_VALUE_RSP</p></td>
<td><p>Find by type value response</p></td>
</tr>
<tr class="row-even"><td><p>ATTC_FIND_INFO_RSP</p></td>
<td><p>Find information response</p></td>
</tr>
<tr class="row-odd"><td><p>ATTC_READ_RSP</p></td>
<td><p>Read response</p></td>
</tr>
<tr class="row-even"><td><p>ATTC_WRITE_RSP</p></td>
<td><p>Write response</p></td>
</tr>
</tbody>
</table>
<p><strong>Note</strong>: Allow the AF to manage DM and ATT operations related to these events to prevent synchronization
issues between the AF and host subsystems.</p>
</section>
<section id="af-message-processors">
<h5>AF Message Processors<a class="headerlink" href="#af-message-processors" title="Link to this heading"></a></h5>
<p>Depending on the user application’s needs, the AF provides these message processors:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>API Name</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>AppDiscProcDmMsg</p></td>
<td><p>Processes discovery-related DM messages.</p></td>
</tr>
<tr class="row-odd"><td><p>AppDiscProcAttMsg</p></td>
<td><p>Processes discovery-related ATT messages.</p></td>
</tr>
<tr class="row-even"><td><p>AppSlaveProcDmMsg</p></td>
<td><p>Processes connection-related DM messages for a slave.</p></td>
</tr>
<tr class="row-odd"><td><p>AppMasterProcDmMsg</p></td>
<td><p>Processes connection-related DM messages for a master.</p></td>
</tr>
<tr class="row-even"><td><p>AppServerProcDmMsg</p></td>
<td><p>Processes general DM messages.</p></td>
</tr>
<tr class="row-odd"><td><p>AppServerProcAttMsg</p></td>
<td><p>Processes general ATT messages.</p></td>
</tr>
<tr class="row-even"><td><p>AppSlaveSecProcDmMsg</p></td>
<td><p>Processes security-related DM messages for a slave.</p></td>
</tr>
<tr class="row-odd"><td><p>AppMasterSecProcDmMsg</p></td>
<td><p>Processes security-related DM messages for a master.</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="relationship-between-dm-and-af">
<h4>Relationship Between DM and AF<a class="headerlink" href="#relationship-between-dm-and-af" title="Link to this heading"></a></h4>
<p>The AF is a higher-level profile that relies on the DM for executing its operations. However, using the DM
directly provides a more intricate interface to the application. If an application solely utilizes the DM, certain
functionalities available in the AF will need to be manually managed by the application itself. For applications
requiring precise control over BLE behavior, it is advisable to use the DM independently of the AF.</p>
</section>
<section id="dm-capabilities">
<h4>DM Capabilities<a class="headerlink" href="#dm-capabilities" title="Link to this heading"></a></h4>
<p>This section explores the various capabilities of the DM.</p>
<section id="id1">
<h5>Bonding Information Management<a class="headerlink" href="#id1" title="Link to this heading"></a></h5>
<p>The DM itself does not persist peer bonding information. However, it offers a comprehensive set of APIs for
initiating bonding procedures and retrieving relevant data that can be stored by the application or a custom
profile.</p>
</section>
<section id="id2">
<h5>Advertising Management<a class="headerlink" href="#id2" title="Link to this heading"></a></h5>
<p>The DM provides a robust set of APIs for managing legacy, extended, and periodic advertising. These
functionalities extend beyond the AF’s capabilities and include:</p>
<ul class="simple">
<li><p>Advertising configuration including data (adv and scan response), interval and duration (also in the AF).</p></li>
<li><p>Setting advertising channel maps.</p></li>
<li><p>Advertising PHY configuration.</p></li>
<li><p>Enabling anonymous advertising or configure advertising address (see LE Privacy Management).</p></li>
<li><p>Conducting Periodic Advertising Sync Transfer (PAST).</p></li>
<li><p>Managing periodic advertiser lists.</p></li>
<li><p>Managing filter policies.</p></li>
</ul>
</section>
<section id="id3">
<h5>Synchronization Management<a class="headerlink" href="#id3" title="Link to this heading"></a></h5>
<p>Compared to the AF, the DM offers more flexible APIs for synchronizing with periodic advertisers.</p>
</section>
<section id="id4">
<h5>Scanning Management<a class="headerlink" href="#id4" title="Link to this heading"></a></h5>
<p>The DM provides all necessary APIs for conducting BLE scans supported by our chipset.</p>
<ul class="simple">
<li><p>Scanning configuration including interval and duration (also in the AF).</p></li>
</ul>
</section>
<section id="id5">
<h5>Service and Characteristic Discovery<a class="headerlink" href="#id5" title="Link to this heading"></a></h5>
<p>The DM does not offer built-in capabilities for service discovery. To perform this operation
without the AF, the application needs to directly interact with the Attribute Protocol
(ATT) subsystem. Generally, for central devices that require service discovery, using the Application Framework
is recommended. This is because central devices usually have more abundant memory resources, making it
more efficient to utilize the framework for such tasks.</p>
</section>
<section id="connection-extended-connection-management">
<h5>Connection / Extended Connection Management<a class="headerlink" href="#connection-extended-connection-management" title="Link to this heading"></a></h5>
<p>The DM exposes a range of APIs to manage BLE connections. These functionalities differ from the AF in
several ways and include:</p>
<ul class="simple">
<li><p>Connection open/close (in AF, this can be automatically handled)</p></li>
<li><p>Connection accept (in AF, this can be automatically handled)</p></li>
<li><p>Connection parameter update requests (unlike AF, the user application must tell the DM to do this when
appropriate)</p></li>
<li><p>Connection parameter update responses (user app chooses to accept or reject peer connection parameter
updates. Normally AF handles this based on the user application’s specifications)</p></li>
<li><p>Enhanced connection update (ECU)</p></li>
<li><p>Connection subrate management</p></li>
<li><p>Connection initiation parameters (central only)</p></li>
<li><p>Extended connection initiation parameters (central only)</p></li>
<li><p>Connection parameters (like AF, user app specifies desired parameters)</p></li>
<li><p>Extended connection parameters (like AF, user app specifies desired parameters)</p></li>
<li><p>Connection idle management</p></li>
<li><p>Connection data PDU length</p></li>
<li><p>Sleep clock accuracy requests</p></li>
<li><p>Authenticated payload timeout management</p></li>
<li><p>Get connection RSSI</p></li>
<li><p>PHY management, reading and setting defaults (normally partially handled by AF)</p></li>
<li><p>Read TX power from peer on ACL connection</p></li>
<li><p>Path loss reporting enable/disable/parameters</p></li>
<li><p>Read remote version info</p></li>
</ul>
</section>
<section id="le-privacy-management">
<h5>LE Privacy Management<a class="headerlink" href="#le-privacy-management" title="Link to this heading"></a></h5>
<p>The DM provides granular control over LE privacy, with functionalities for:</p>
<ul class="simple">
<li><p>Resolving Resolvable Private Addresses (RPAs)</p></li>
<li><p>Setting static random addresses</p></li>
<li><p>Managing privacy modes</p></li>
<li><p>Filter accept lists</p></li>
<li><p>Resolving lists</p></li>
</ul>
</section>
<section id="id6">
<h5>Security Management<a class="headerlink" href="#id6" title="Link to this heading"></a></h5>
<p>The DM offers comprehensive APIs to manage LE secure connections, including functionalities for:</p>
<ul class="simple">
<li><p>Pairing procedures</p></li>
<li><p>OOB pairing</p></li>
<li><p>Encryption initiation and management</p></li>
<li><p>Key management</p></li>
<li><p>Security compare procedures (SMP API mapping)</p></li>
</ul>
<p><strong>Note</strong>: Post-initialization, interaction with the SMP subsystem should solely be managed via the
DM.</p>
</section>
<section id="direction-finding">
<h5>Direction Finding<a class="headerlink" href="#direction-finding" title="Link to this heading"></a></h5>
<p>Though not fully implemented, the DM provides preliminary APIs for Constant Tone Extension (CTE)
functionalities.</p>
</section>
<section id="isochronous-channels">
<h5>Isochronous Channels<a class="headerlink" href="#isochronous-channels" title="Link to this heading"></a></h5>
<p>The DM supports isochronous features like BIS, BIG, CIS, and CIG in BLE. It also exposes APIs for codec
management; however, LE audio codec support is still under development.</p>
</section>
<section id="stack-amd-vendor-specific-functionality">
<h5>Stack amd Vendor Specific Functionality<a class="headerlink" href="#stack-amd-vendor-specific-functionality" title="Link to this heading"></a></h5>
<p>The DM includes helper APIs for BLE stack management and will soon offer vendor-specific functionalities.</p>
</section>
</section>
</section>
<section id="combined-use-of-af-and-dm">
<h3>Combined Use of AF and DM<a class="headerlink" href="#combined-use-of-af-and-dm" title="Link to this heading"></a></h3>
<p>It is possible to employ both the AF and DM in a single application. In such scenarios, it is recommended to
delegate to the AF the features it inherently supports. Additional functionalities can be safely supplemented
through direct calls to the DM if it is not managed by the AF. For a detailed guide on which features to
allocate to each profile, refer to the list of AF-supported events.</p>
<p>By adhering to these guidelines, developers can optimize the integration of the DM and AF to suit a variety of
application needs.</p>
</section>
<section id="af-to-dm-migration-guide">
<h3>AF to DM Migration Guide<a class="headerlink" href="#af-to-dm-migration-guide" title="Link to this heading"></a></h3>
<p>This guide is a simple introduction to converting an existing user application which currently uses the AF to use
the DM exclusively.</p>
<section id="configuring-advertising">
<h4>Configuring Advertising<a class="headerlink" href="#configuring-advertising" title="Link to this heading"></a></h4>
<p>This example demonstrates how to configure discoverable advertising using two distinct APIs: Application
Framework (AF) and Device Manager (DM).</p>
<section id="advertising-using-af">
<h5>Advertising using AF<a class="headerlink" href="#advertising-using-af" title="Link to this heading"></a></h5>
<p>The first code snippet is derived from the SDK’s “emb fit” example and illustrates how to configure advertising
using the Application Framework.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">void</span> <span class="n">userAppStartAdv</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">///</span> <span class="n">Configurable</span> <span class="n">parameters</span> <span class="k">for</span> <span class="n">advertising</span><span class="o">.</span>
  <span class="n">static</span> <span class="n">const</span> <span class="n">appAdvCfg_t</span> <span class="n">exampleAdvConfig</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">The</span> <span class="n">first</span> <span class="n">element</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">only</span> <span class="n">one</span> <span class="n">that</span> <span class="n">matters</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">example</span> <span class="n">because</span>
    <span class="o">//</span> <span class="n">only</span> <span class="n">using</span> <span class="mi">1</span> <span class="n">advertising</span> <span class="nb">set</span> <span class="ow">is</span> <span class="n">used</span><span class="o">.</span>
    <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="o">//</span> <span class="n">Advertising</span> <span class="n">durations</span> <span class="ow">in</span> <span class="n">ms</span> <span class="p">(</span><span class="mi">0</span> <span class="o">=</span> <span class="n">infinite</span><span class="p">)</span><span class="o">.</span>
    <span class="p">{</span><span class="mi">160</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span> <span class="o">//</span> <span class="n">Advertising</span> <span class="n">intervals</span> <span class="ow">in</span> <span class="mf">0.625</span> <span class="n">ms</span> <span class="n">units</span><span class="o">.</span>
  <span class="p">};</span>
  <span class="o">//</span> <span class="n">Setting</span> <span class="n">this</span> <span class="k">global</span> <span class="n">variable</span> <span class="n">saves</span> <span class="n">parameters</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">AF</span> <span class="n">persistent</span> <span class="n">RAM</span><span class="o">.</span>
  <span class="n">pAppAdvCfg</span> <span class="o">=</span> <span class="p">(</span><span class="n">appAdvCfg_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">exampleAdvConfig</span><span class="p">;</span>

  <span class="o">///</span> <span class="n">Advertising</span> <span class="n">data</span><span class="p">,</span> <span class="n">discoverable</span> <span class="n">mode</span><span class="o">.</span>
  <span class="n">static</span> <span class="n">const</span> <span class="n">uint8_t</span> <span class="n">advData</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Service</span> <span class="n">UUID</span> <span class="nb">list</span><span class="o">.</span>
    <span class="mi">9</span><span class="p">,</span> <span class="o">//</span> <span class="n">Length</span><span class="o">.</span>
    <span class="n">DM_ADV_TYPE_16_UUID</span><span class="p">,</span> <span class="o">//</span> <span class="n">AD</span> <span class="nb">type</span><span class="o">.</span>
    <span class="n">UINT16_TO_BYTES</span><span class="p">(</span><span class="n">ATT_UUID_HEART_RATE_SERVICE</span><span class="p">),</span>
    <span class="n">UINT16_TO_BYTES</span><span class="p">(</span><span class="n">ATT_UUID_RUNNING_SPEED_SERVICE</span><span class="p">),</span>
    <span class="n">UINT16_TO_BYTES</span><span class="p">(</span><span class="n">ATT_UUID_DEVICE_INFO_SERVICE</span><span class="p">),</span>
    <span class="n">UINT16_TO_BYTES</span><span class="p">(</span><span class="n">ATT_UUID_BATTERY_SERVICE</span><span class="p">)</span>
  <span class="p">};</span>

  <span class="o">///</span> <span class="n">Scan</span> <span class="n">data</span><span class="p">,</span> <span class="n">discoverable</span> <span class="n">mode</span><span class="o">.</span>
  <span class="n">static</span> <span class="n">const</span> <span class="n">uint8_t</span> <span class="n">scanData</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Device</span> <span class="n">name</span><span class="o">.</span>
    <span class="mi">10</span><span class="p">,</span> <span class="o">//</span> <span class="n">Length</span><span class="o">.</span>
    <span class="n">DM_ADV_TYPE_LOCAL_NAME</span><span class="p">,</span> <span class="o">//</span> <span class="n">AD</span> <span class="nb">type</span><span class="o">.</span>
    <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span>
  <span class="p">};</span>

  <span class="o">//</span> <span class="n">Set</span> <span class="n">advertising</span> <span class="ow">and</span> <span class="n">scan</span> <span class="n">response</span> <span class="n">data</span> <span class="k">for</span> <span class="n">discoverable</span> <span class="n">mode</span><span class="o">.</span>
  <span class="n">AppAdvSetData</span><span class="p">(</span><span class="n">APP_ADV_DATA_DISCOVERABLE</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">advData</span><span class="p">),</span> <span class="p">(</span><span class="n">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">advData</span><span class="p">);</span>
  <span class="n">AppAdvSetData</span><span class="p">(</span><span class="n">APP_SCAN_DATA_DISCOVERABLE</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">scanData</span><span class="p">),</span> <span class="p">(</span><span class="n">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scanData</span><span class="p">);</span>

  <span class="n">AppAdvStart</span><span class="p">(</span><span class="n">APP_MODE_DISCOVERABLE</span><span class="p">);</span>
<span class="p">}</span>

</pre></div>
</div>
</section>
<section id="advertising-using-dm">
<h5>Advertising using DM<a class="headerlink" href="#advertising-using-dm" title="Link to this heading"></a></h5>
<p>The second code snippet performs the same task, but utilizes the Device Manager API.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">void</span> <span class="n">userAppStartAdv</span><span class="p">()</span>
<span class="p">{</span>
  <span class="o">///</span> <span class="n">Advertising</span> <span class="n">data</span><span class="p">,</span> <span class="n">discoverable</span> <span class="n">mode</span><span class="o">.</span>
  <span class="n">static</span> <span class="n">const</span> <span class="n">uint8_t</span> <span class="n">advData</span><span class="p">[]</span> <span class="o">=</span>
  <span class="p">{</span>
     <span class="o">//</span> <span class="n">Service</span> <span class="n">UUID</span> <span class="nb">list</span><span class="o">.</span>
      <span class="mi">9</span><span class="p">,</span> <span class="o">//</span> <span class="n">Length</span><span class="o">.</span>
    <span class="n">DM_ADV_TYPE_16_UUID</span><span class="p">,</span> <span class="o">//</span> <span class="n">AD</span> <span class="nb">type</span><span class="o">.</span>
    <span class="n">UINT16_TO_BYTES</span><span class="p">(</span><span class="n">ATT_UUID_HEART_RATE_SERVICE</span><span class="p">),</span>
    <span class="n">UINT16_TO_BYTES</span><span class="p">(</span><span class="n">ATT_UUID_RUNNING_SPEED_SERVICE</span><span class="p">),</span>
    <span class="n">UINT16_TO_BYTES</span><span class="p">(</span><span class="n">ATT_UUID_DEVICE_INFO_SERVICE</span><span class="p">),</span>
    <span class="n">UINT16_TO_BYTES</span><span class="p">(</span><span class="n">ATT_UUID_BATTERY_SERVICE</span><span class="p">)};</span>
    <span class="o">///</span> <span class="n">Scan</span> <span class="n">data</span><span class="p">,</span> <span class="n">discoverable</span> <span class="n">mode</span><span class="o">.</span>
    <span class="n">static</span> <span class="n">const</span> <span class="n">uint8_t</span> <span class="n">scanData</span><span class="p">[]</span> <span class="o">=</span>
    <span class="p">{</span>
      <span class="o">//</span> <span class="n">Device</span> <span class="n">name</span><span class="o">.</span>
      <span class="mi">10</span><span class="p">,</span> <span class="o">//</span> <span class="n">Length</span><span class="o">.</span>
      <span class="n">DM_ADV_TYPE_LOCAL_NAME</span><span class="p">,</span> <span class="o">//</span> <span class="n">AD</span> <span class="nb">type</span><span class="o">.</span>
      <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">};</span>
      <span class="n">uint8_t</span> <span class="n">advHandle</span> <span class="o">=</span> <span class="n">DM_ADV_HANDLE_DEFAULT</span><span class="p">;</span> <span class="o">//</span> <span class="n">Only</span> <span class="mi">1</span> <span class="n">advertising</span> <span class="nb">set</span>
      <span class="n">uint8_t</span> <span class="n">maxEaEvents</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="o">//</span> <span class="n">Not</span> <span class="n">using</span> <span class="n">ext</span> <span class="n">adv</span>
      <span class="n">uint16_t</span> <span class="n">duration</span> <span class="o">=</span> <span class="mi">0</span><span class="n">U</span><span class="p">;</span> <span class="o">//</span> <span class="mi">0</span> <span class="o">=</span> <span class="n">infinite</span> <span class="n">duration</span>
      <span class="n">uint16_t</span> <span class="n">advInterval</span> <span class="o">=</span> <span class="mi">160</span><span class="n">U</span><span class="p">;</span>
      <span class="n">bdAddr_t</span> <span class="n">peerAddr</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="o">//</span> <span class="n">Only</span> <span class="n">used</span> <span class="k">for</span> <span class="n">directed</span> <span class="n">advertising</span>
      <span class="n">DmAdvSetData</span><span class="p">(</span><span class="n">DM_ADV_HANDLE_DEFAULT</span><span class="p">,</span> <span class="n">HCI_ADV_DATA_OP_COMP_FRAG</span><span class="p">,</span> <span class="n">DM_DATA_LOC_ADV</span><span class="p">,</span>
      <span class="p">(</span><span class="n">uint8_t</span><span class="p">)</span><span class="n">sizeof</span><span class="p">(</span><span class="n">advData</span><span class="p">),</span> <span class="p">(</span><span class="n">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">advData</span><span class="p">);</span>
      <span class="n">DmAdvSetData</span><span class="p">(</span><span class="n">DM_ADV_HANDLE_DEFAULT</span><span class="p">,</span> <span class="n">HCI_ADV_DATA_OP_COMP_FRAG</span><span class="p">,</span> <span class="n">DM_DATA_LOC_SCAN</span><span class="p">,</span>
      <span class="p">(</span><span class="n">uint8_t</span><span class="p">)</span><span class="n">sizeof</span><span class="p">(</span><span class="n">scanData</span><span class="p">),</span> <span class="p">(</span><span class="n">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scanData</span><span class="p">);</span>
      <span class="n">DmAdvSetInterval</span><span class="p">(</span><span class="n">DM_ADV_HANDLE_DEFAULT</span><span class="p">,</span> <span class="n">advInterval</span><span class="p">,</span> <span class="n">advInterval</span><span class="p">);</span>
      <span class="n">DmAdvConfig</span><span class="p">(</span><span class="n">DM_ADV_HANDLE_DEFAULT</span><span class="p">,</span> <span class="n">LL_ADV_SCAN_UNDIRECT</span><span class="p">,</span> <span class="n">LL_ADDR_PUBLIC</span><span class="p">,</span> <span class="n">peerAddr</span><span class="p">);</span>
      <span class="n">DmAdvStart</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">advHandle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">duration</span><span class="p">,</span> <span class="n">maxEaEvents</span><span class="p">);</span>
    <span class="p">}</span>

</pre></div>
</div>
<p><strong>Note</strong>: The Device Manager employs an internal timer to manage the duration of advertising</p>
</section>
<section id="event-sequences">
<h5>Event Sequences<a class="headerlink" href="#event-sequences" title="Link to this heading"></a></h5>
<p>This seqence diagram is exactly the same using DM or AF APIs.</p>
<a class="reference internal image-reference" href="_images/advertising_sequence_diagram.png"><img alt="_images/advertising_sequence_diagram.png" src="_images/advertising_sequence_diagram.png" style="width: 300px;" /></a>
</section>
</section>
<section id="configuring-scanning">
<h4>Configuring Scanning<a class="headerlink" href="#configuring-scanning" title="Link to this heading"></a></h4>
<p>The following example outlines how to configure and start passive scanning using both the AF and DM.</p>
<section id="scanning-using-the-af">
<h5>Scanning using the AF<a class="headerlink" href="#scanning-using-the-af" title="Link to this heading"></a></h5>
<p>The code snippet below shows how to start passive scanning using the AF.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">void</span> <span class="n">userAppStartScan</span><span class="p">()</span>
<span class="p">{</span>
  <span class="o">//</span> <span class="n">Notes</span><span class="p">:</span>
  <span class="o">//</span> <span class="o">-</span> <span class="n">AppMasterInit</span> <span class="n">must</span> <span class="n">be</span> <span class="n">called</span> <span class="n">during</span> <span class="n">initialization</span><span class="o">.</span>
  <span class="o">//</span> <span class="o">-</span> <span class="n">DmScanInit</span> <span class="n">must</span> <span class="n">be</span> <span class="n">called</span> <span class="n">during</span> <span class="n">initialization</span><span class="o">.</span>
  <span class="o">//</span> <span class="o">-</span> <span class="n">Received</span> <span class="n">scan</span> <span class="n">reports</span> <span class="n">will</span> <span class="n">be</span> <span class="n">routed</span> <span class="n">to</span> <span class="n">the</span> <span class="n">device</span> <span class="n">manager</span> <span class="n">callback</span><span class="o">.</span>
  <span class="o">//</span> <span class="n">Configurable</span> <span class="n">parameters</span> <span class="k">for</span> <span class="n">scanning</span><span class="o">.</span>
  <span class="n">static</span> <span class="n">const</span> <span class="n">appMasterCfg_t</span> <span class="n">exampleCentralConfig</span> <span class="o">=</span>
  <span class="p">{</span>
    <span class="o">.</span><span class="n">scanInterval</span> <span class="o">=</span> <span class="mi">96</span><span class="n">U</span><span class="p">,</span> <span class="o">//</span> <span class="n">Units</span> <span class="o">=</span> <span class="mf">0.625</span><span class="n">ms</span> <span class="o">|</span> <span class="mi">96</span> <span class="o">=</span> <span class="mi">60</span><span class="n">ms</span>
    <span class="o">.</span><span class="n">scanWindow</span> <span class="o">=</span> <span class="mi">48</span><span class="n">U</span><span class="p">,</span> <span class="o">//</span> <span class="n">Units</span> <span class="o">=</span> <span class="mf">0.625</span><span class="n">ms</span> <span class="o">|</span> <span class="mi">48</span> <span class="o">=</span> <span class="mi">30</span><span class="n">ms</span> <span class="p">(</span><span class="mi">50</span><span class="o">%</span> <span class="n">duty</span> <span class="n">cycle</span><span class="p">)</span>
    <span class="o">.</span><span class="n">scanDuration</span> <span class="o">=</span> <span class="mi">0</span><span class="n">U</span><span class="p">,</span> <span class="o">//</span> <span class="n">Units</span> <span class="o">=</span> <span class="mi">1</span><span class="n">ms</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">=</span> <span class="n">Infinite</span>
    <span class="o">.</span><span class="n">discMode</span> <span class="o">=</span> <span class="n">DM_DISC_MODE_NONE</span><span class="p">,</span>
    <span class="o">.</span><span class="n">scanType</span> <span class="o">=</span> <span class="n">DM_SCAN_TYPE_PASSIVE</span><span class="p">,</span>
  <span class="p">};</span>
<span class="o">//</span> <span class="n">Setting</span> <span class="n">this</span> <span class="k">global</span> <span class="n">variable</span> <span class="n">saves</span> <span class="n">parameters</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">AF</span> <span class="n">persistent</span> <span class="n">RAM</span><span class="o">.</span>
  <span class="n">pAppMasterCfg</span> <span class="o">=</span> <span class="p">(</span><span class="n">appMasterCfg_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">exampleCentralConfig</span><span class="p">;</span>
  <span class="n">AppScanStart</span><span class="p">(</span><span class="n">exampleCentralConfig</span><span class="o">.</span><span class="n">discMode</span><span class="p">,</span>
  <span class="n">exampleCentralConfig</span><span class="o">.</span><span class="n">scanType</span><span class="p">,</span> <span class="n">exampleCentralConfig</span><span class="o">.</span><span class="n">scanDuration</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="scanning-using-the-dm">
<h5>Scanning using the DM<a class="headerlink" href="#scanning-using-the-dm" title="Link to this heading"></a></h5>
<p>The code snippet below shows how to start passive scanning using the DM.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">void</span> <span class="n">userAppStartScan</span><span class="p">()</span>
<span class="p">{</span>
  <span class="o">//</span> <span class="n">Notes</span><span class="p">:</span>
  <span class="o">//</span> <span class="o">-</span> <span class="n">DmScanInit</span> <span class="n">must</span> <span class="n">be</span> <span class="n">called</span> <span class="n">during</span> <span class="n">initialization</span><span class="o">.</span>
  <span class="o">//</span> <span class="o">-</span> <span class="n">Received</span> <span class="n">scan</span> <span class="n">reports</span> <span class="n">will</span> <span class="n">be</span> <span class="n">routed</span> <span class="n">to</span> <span class="n">the</span> <span class="n">device</span> <span class="n">manager</span> <span class="n">callback</span><span class="o">.</span>
  <span class="o">//</span> <span class="o">-</span> <span class="n">DM</span> <span class="n">allows</span> <span class="n">configuration</span> <span class="k">for</span> <span class="n">scanning</span> <span class="n">on</span> <span class="n">multiple</span> <span class="n">PHYs</span><span class="o">.</span> <span class="n">In</span> <span class="n">this</span> <span class="n">example</span><span class="p">,</span> <span class="n">only</span> <span class="n">use</span> <span class="mi">1</span> <span class="n">PHY</span><span class="o">.</span>
  <span class="o">//</span> <span class="n">Configurable</span> <span class="n">parameters</span> <span class="k">for</span> <span class="n">scanning</span><span class="o">.</span>
  <span class="c1">#define NUM_SCANNING_PHYS 1U // Only scan on 1M PHY.</span>
  <span class="nb">bool</span> <span class="n">filterDuplicates</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
  <span class="n">uint16_t</span> <span class="n">period</span> <span class="o">=</span> <span class="mi">0</span><span class="n">U</span><span class="p">;</span> <span class="o">//</span> <span class="n">Units</span> <span class="o">=</span> <span class="mf">1.28</span><span class="n">s</span> <span class="o">|</span> <span class="p">(</span><span class="n">only</span> <span class="n">applicable</span> <span class="n">to</span> <span class="n">AE</span><span class="p">)</span><span class="o">.</span>
  <span class="o">//</span> <span class="n">If</span> <span class="nb">set</span> <span class="n">to</span> <span class="n">zero</span><span class="p">,</span> <span class="n">periodic</span> <span class="n">scanning</span> <span class="ow">is</span> <span class="n">disabled</span><span class="o">.</span>
  <span class="n">uint16_t</span> <span class="n">scanDuration</span> <span class="o">=</span> <span class="mi">0</span><span class="n">U</span><span class="p">;</span> <span class="o">//</span> <span class="n">Units</span> <span class="o">=</span> <span class="mi">1</span><span class="n">ms</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">=</span> <span class="n">Infinite</span>
  <span class="n">uint16_t</span> <span class="n">scanInterval</span><span class="p">[</span><span class="n">NUM_SCANNING_PHYS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">96</span><span class="n">U</span><span class="p">};</span> <span class="o">//</span> <span class="n">Units</span> <span class="o">=</span> <span class="mf">0.625</span><span class="n">ms</span> <span class="o">|</span> <span class="mi">96</span> <span class="o">=</span> <span class="mi">60</span><span class="n">ms</span>
  <span class="n">uint16_t</span> <span class="n">scanWindow</span><span class="p">[</span><span class="n">NUM_SCANNING_PHYS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">48</span><span class="n">U</span><span class="p">};</span> <span class="o">//</span> <span class="n">Units</span> <span class="o">=</span> <span class="mf">0.625</span><span class="n">ms</span> <span class="o">|</span> <span class="mi">48</span> <span class="o">=</span> <span class="mi">30</span><span class="n">ms</span> <span class="p">(</span><span class="mi">50</span><span class="o">%</span> <span class="n">duty</span> <span class="n">cycle</span><span class="p">)</span>
  <span class="n">uint8_t</span> <span class="n">discMode</span> <span class="o">=</span> <span class="n">DM_DISC_MODE_NONE</span><span class="p">;</span>
  <span class="n">uint8_t</span> <span class="n">scanType</span><span class="p">[</span><span class="n">NUM_SCANNING_PHYS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">DM_SCAN_TYPE_PASSIVE</span><span class="p">};</span>
  <span class="n">DmScanSetInterval</span><span class="p">(</span><span class="n">HCI_SCAN_PHY_LE_1M_BIT</span><span class="p">,</span> <span class="n">scanInterval</span><span class="p">,</span> <span class="n">scanWindow</span><span class="p">);</span>
  <span class="n">DmScanStart</span><span class="p">(</span><span class="n">HCI_SCAN_PHY_LE_1M_BIT</span><span class="p">,</span> <span class="n">discMode</span><span class="p">,</span> <span class="n">scanType</span><span class="p">,</span> <span class="n">filterDuplicates</span><span class="p">,</span> <span class="n">scanDuration</span><span class="p">,</span> <span class="n">period</span><span class="p">);</span>
<span class="p">}</span>

</pre></div>
</div>
</section>
<section id="id7">
<h5>Event Sequences<a class="headerlink" href="#id7" title="Link to this heading"></a></h5>
<a class="reference internal image-reference" href="_images/passive_scanning_event_sequence_diagram.png"><img alt="_images/passive_scanning_event_sequence_diagram.png" src="_images/passive_scanning_event_sequence_diagram.png" style="width: 300px;" /></a>
</section>
</section>
</section>
<section id="including-and-customizing-ble-core-features-in-applications">
<h3>Including and Customizing BLE Core Features in Applications<a class="headerlink" href="#including-and-customizing-ble-core-features-in-applications" title="Link to this heading"></a></h3>
<p>The previous sections covered the initialization and configuration of em | bleu’s BLE Host Stack.  The following section guides an applications developer through the process of including, and customizing, BLE Core features into applications.</p>
<section id="dm-and-att-message-handling">
<h4>DM and ATT Message Handling<a class="headerlink" href="#dm-and-att-message-handling" title="Link to this heading"></a></h4>
<p>An application can register a callback function to receive Device Manager (DM) and Attribute Protocol (ATT) events.  The DM and ATT events contain important information about numerous system events.</p>
<section id="registering-to-receive-dm-and-att-events">
<h5>Registering to Receive DM and ATT Events<a class="headerlink" href="#registering-to-receive-dm-and-att-events" title="Link to this heading"></a></h5>
<p>The following code block is an example of registering callback functions to receive DM and ATT events.  In this example, the appDmCback receives DM events and the appAttCback receives ATT events.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">/*</span> <span class="n">Register</span> <span class="k">for</span> <span class="n">stack</span> <span class="n">callbacks</span> <span class="o">*/</span>
  <span class="n">DmRegister</span><span class="p">(</span><span class="n">appDmCback</span><span class="p">);</span>
  <span class="n">DmConnRegister</span><span class="p">(</span><span class="n">DM_CLIENT_ID_APP</span><span class="p">,</span> <span class="n">appDmCback</span><span class="p">);</span>
  <span class="n">AttRegister</span><span class="p">(</span><span class="n">appAttCback</span><span class="p">);</span>
</pre></div>
</div>
<p>The following is an example of a DM event callback function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">void</span> <span class="n">appDmCback</span><span class="p">(</span><span class="n">dmEvt_t</span> <span class="o">*</span><span class="n">pDmEvt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">dmEvt_t</span>   <span class="o">*</span><span class="n">pMsg</span><span class="p">;</span>
  <span class="n">uint16_t</span>  <span class="nb">len</span><span class="p">;</span>
  <span class="n">uint16_t</span>  <span class="n">reportLen</span><span class="p">;</span>

  <span class="nb">len</span> <span class="o">=</span> <span class="n">DmSizeOfEvt</span><span class="p">(</span><span class="n">pDmEvt</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">pDmEvt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">.</span><span class="n">event</span> <span class="o">==</span> <span class="n">DM_SCAN_REPORT_IND</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">reportLen</span> <span class="o">=</span> <span class="n">pDmEvt</span><span class="o">-&gt;</span><span class="n">scanReport</span><span class="o">.</span><span class="n">len</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">reportLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">pMsg</span> <span class="o">=</span> <span class="n">WsfMsgAlloc</span><span class="p">(</span><span class="nb">len</span> <span class="o">+</span> <span class="n">reportLen</span><span class="p">))</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">pMsg</span><span class="p">,</span> <span class="n">pDmEvt</span><span class="p">,</span> <span class="nb">len</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pDmEvt</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">.</span><span class="n">event</span> <span class="o">==</span> <span class="n">DM_SCAN_REPORT_IND</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">pMsg</span><span class="o">-&gt;</span><span class="n">scanReport</span><span class="o">.</span><span class="n">pData</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="n">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pMsg</span> <span class="o">+</span> <span class="nb">len</span><span class="p">);</span>
      <span class="n">memcpy</span><span class="p">(</span><span class="n">pMsg</span><span class="o">-&gt;</span><span class="n">scanReport</span><span class="o">.</span><span class="n">pData</span><span class="p">,</span> <span class="n">pDmEvt</span><span class="o">-&gt;</span><span class="n">scanReport</span><span class="o">.</span><span class="n">pData</span><span class="p">,</span> <span class="n">reportLen</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">WsfMsgSend</span><span class="p">(</span><span class="n">pawrCb</span><span class="o">.</span><span class="n">handlerId</span><span class="p">,</span> <span class="n">pMsg</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There are two purposes of this callback function.  The first is to context switch to the app task handler before processing the DM event.  This context switch prevents deep call stacks.  The second purpose of the callback functions is to copy the DM event’s information, which may have been allocated on the stack by the DM, into a WSF buffer.</p>
<p>Most DM events are copied to a message buffer as is.  Some events, like scan reports, have pointers to data and must be copied in multiple parts before being sent to the application task.  In these cases, the length of the message buffer allocation is the length of the message plus the length of the additional data to be copied.  The extra data is then set to a pointer in the event structure extra data is copied.</p>
<p>In the example above, a legacy scan report’s data is copied into the message buffer.  If an application uses extended scanning, then the DM_EXT_SCAN_REPORT_IND should be similarly handled.</p>
<p>The following is an example of an ATT event callback function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">void</span> <span class="n">pawrAttCback</span><span class="p">(</span><span class="n">attEvt_t</span> <span class="o">*</span><span class="n">pEvt</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">attEvt_t</span> <span class="o">*</span><span class="n">pMsg</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">pMsg</span> <span class="o">=</span> <span class="n">WsfMsgAlloc</span><span class="p">(</span><span class="n">sizeof</span><span class="p">(</span><span class="n">attEvt_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">pEvt</span><span class="o">-&gt;</span><span class="n">valueLen</span><span class="p">))</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">pMsg</span><span class="p">,</span> <span class="n">pEvt</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">attEvt_t</span><span class="p">));</span>
    <span class="n">pMsg</span><span class="o">-&gt;</span><span class="n">pValue</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pMsg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">pMsg</span><span class="o">-&gt;</span><span class="n">pValue</span><span class="p">,</span> <span class="n">pEvt</span><span class="o">-&gt;</span><span class="n">pValue</span><span class="p">,</span> <span class="n">pEvt</span><span class="o">-&gt;</span><span class="n">valueLen</span><span class="p">);</span>
    <span class="n">WsfMsgSend</span><span class="p">(</span><span class="n">pawrCb</span><span class="o">.</span><span class="n">handlerId</span><span class="p">,</span> <span class="n">pMsg</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The ATT event callback function’s purpose is similar to the DM function’s.</p>
<p>Every ATT event has pLen bytes of data in the pValue parameter that must be copied to the newly allocated buffer before sending the message to the application task.</p>
<p>A complete list of DM events can be found in an enum in ble-host/include/dm_api.h beginning with the DM_CBACK_START event value.</p>
<p>A complete list of ATT events can be found in an enum in ble-host/include/att_api.h beginning with the ATT_CBACK_START event value.</p>
</section>
<section id="dm-reset-event">
<h5>DM Reset Event<a class="headerlink" href="#dm-reset-event" title="Link to this heading"></a></h5>
<p>The last initialization function called by an application is always DmDevReset. The DmDevReset function starts a procedure that resets the BLE Controller and loads device information from the controller.  After the reset process completes, the DM sends the DM_RESET_CMPL_IND event to the DM event callback function.</p>
<p>After receiving DM_RESET_CMPL_IND, the application is free to begin using the BLE radio. Some of the tasks that may take place in an application’s DM_RESET_CMPL_IND event handler include:</p>
<ul class="simple">
<li><p>Calculating the ATT database hash.</p></li>
<li><p>Generating an ECC key for use by LE Secure Connections.</p></li>
<li><p>Restoring the app database from NVM.</p></li>
<li><p>Restoring the resolving list of private addresses.</p></li>
<li><p>Starting scanning.</p></li>
<li><p>Starting advertising.</p></li>
</ul>
<p>Not all applications will initiate all of these features.  For example, if a device doesn’t resolve private addresses, then it won’t need to restore the resolving list.</p>
<p>Sometimes it is necessary to serialize activities that take place after DM_RESET_IND.  This can be performed with a state machine.</p>
</section>
</section>
<section id="application-state-machine">
<h4>Application State Machine<a class="headerlink" href="#application-state-machine" title="Link to this heading"></a></h4>
<p>BLE application execution is driven by function callouts into the BLE stack and processing callback functions from the BLE Stack.  An ideal design methodology for implementing an application in this type of callout/callback environment is called a state machine.  In a state machine, the application keeps track of the application’s state in a global variable.  In each state, there is a function that performs a state-specific action for each valid system event.  The following code is an example of a state machine for an application that scans for a device and initiates a connection to a device:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">uint8_t</span> <span class="n">state</span><span class="p">;</span>

<span class="n">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">case</span> <span class="n">APP_WAIT_RESET_STATE</span><span class="p">:</span>
    <span class="n">appProcessEvtResetState</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="k">case</span> <span class="n">APP_SCANNING_STATE</span><span class="p">:</span>
    <span class="n">appProcessEvtScanningState</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>

<span class="k">case</span> <span class="n">APP_CONNECTING_STATE</span><span class="p">:</span>
    <span class="n">appProcessEvtConnectingState</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>

<span class="k">case</span> <span class="n">APP_ACTIVE_STATE</span><span class="p">:</span>
    <span class="n">appProcessEvtActiveState</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>

<span class="k">case</span> <span class="n">APP_IDLE_STATE</span><span class="p">:</span>
    <span class="n">appProcessEvtIdleState</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When the application begins, the application state is the <code class="docutils literal notranslate"><span class="pre">APP_WAIT_RESET_STATE</span></code> state. In the wait reset state, the application waits for the DM_RESET_IND event.  On receipt of the DM_RESET_IND event, the <code class="docutils literal notranslate"><span class="pre">appProcessEvtResetState</span></code> function performs the first reset task.  On the callback indicating the first reset operation is complete, the application can begin the second reset operation, and so on.  When all reset operations are complete, the application can call AppScanStart or AppExtScanStart to begin scanning.  A second state variable that is specific to the reset state can be used to maintain the state of the reset process if necessary.</p>
<p>When the application receives the DM_SCAN_START_IND or the DM_EXT_SCAN_START_IND, the app can transition to the <code class="docutils literal notranslate"><span class="pre">APP_SCANNING_STATE</span></code>.  In the <code class="docutils literal notranslate"><span class="pre">APP_SCANNING_STATE</span></code>, the application processes DM_SCAN_REPORT_IND or DM_EXT_SCAN_REPORT_IND events from the BLE stack to search for a device to connect with.  After finding the right device, the application can stop scanning with the AppScanStop or AppExtScanStop function.</p>
<p>When the application receives the DM_SCAN_STOP_IND or the DM_EXT_SCAN_STOP_IND, the application may transition to the APP_CONNECTING_STATE and call AppConnOpen or AppExtConnOpen to initiate a connection to the peer.  If no device was found while scanning, the application may scan again or go into a low-power idle state.</p>
<p>If the application receives the DM_CONN_OPEN_IND event, the application’s state can transition to the APP_ACTIVE_STATE and the application can communicate with the peer device via one of the BLE Profiles.  When the connection closes, the application will receive the DM_CONN_CLOSE_IND event, and the application can enter a low-power state and transition the application state machine to the IDLE state.</p>
<p>As features are added or removed from a particular application, the state machine will change.  However, in general, a state machine is likely to be the best possible architecture for a BLE application.</p>
</section>
<section id="advertising">
<h4>Advertising<a class="headerlink" href="#advertising" title="Link to this heading"></a></h4>
<section id="initializing-for-advertising">
<h5>Initializing for Advertising<a class="headerlink" href="#initializing-for-advertising" title="Link to this heading"></a></h5>
<p>The <em>DmAdvInit</em> function initializes the DM for legacy advertising.  The <em>DmExtAdvInit</em> function initializes the DM for extended advertising. Extended advertising has the option of advertising with legacy PDUs and therefore can be backward compatible with legacy advertising.</p>
</section>
<section id="advertisement-data-format">
<h5>Advertisement Data Format<a class="headerlink" href="#advertisement-data-format" title="Link to this heading"></a></h5>
<p>Advertisements are constructed from advertising data (AD) values.  Each value has a 1-byte length field followed by a 1-byte AD type field followed by data associated with the AD type.</p>
</section>
<section id="setting-advertising-data-in-legacy-advertising">
<h5>Setting Advertising Data in Legacy Advertising<a class="headerlink" href="#setting-advertising-data-in-legacy-advertising" title="Link to this heading"></a></h5>
<p>There is only one 31-byte advertisement in legacy advertising.  The advertisement can be set by creating an array with an advertisement and calling <em>AppAdvSetData</em>.  AppAdvSetData takes three parameters, location, len, and pData.</p>
<p>The location parameter of AppAdvSetData can be one of the following values:</p>
<ul class="simple">
<li><p>APP_ADV_DATA_CONNECTABLE</p></li>
<li><p>APP_SCAN_DATA_CONNECTABLE</p></li>
<li><p>APP_ADV_DATA_DISCOVERABLE</p></li>
<li><p>APP_SCAN_DATA_DISCOVERABLE</p></li>
</ul>
<p>The <em><em>CONNECTABLE locations are used to set data for connectable mode.  The <em><em>DISCOVERABLE locations is used to set data for discoverable mode.  The ADV_DATA</em></em> locations are used to set advertising data that is transmitted for receipt by passive scanners.  The SCAN_DATA</em></em> locations are used to set scan response data that will be transmitted in response to active scans.</p>
<p>The len parameter of AppAdvSetData is the number of bytes in the pData parameter.  The len can be 31 bytes or less.  The pData parameter is a pointer to the advertising or scan data.</p>
<p>Advertisement data can be added or modified by calling the <em>AppAdvSetAdValue</em>.  The parameters to AppAdvSetAdValue are location, type, len, pValue.  The return value is a boolean.  The return value is true if the element was added or updated.  The return value is false if the operation failed.  The location parameter is one of the same values as the location parameter to the AppAdvSetData function above.  The type parameter contains the AD Type.  The AD Types are defined in the BLE specification.  The len parameter is the size of the pValue parameter in bytes.  The pValue contains the value of the advertisement element.</p>
<p>The AppSetAdvType is used to set the advertising type to one of the following:</p>
<ul class="simple">
<li><p>DM_ADV_CONN_UNDIRECT</p></li>
<li><p>DM_ADV_CONN_DIRECT</p></li>
<li><p>DM_ADV_SCAN_UNDIRECT</p></li>
<li><p>DM_ADV_NONCONN_UNDIRECT</p></li>
<li><p>DM_ADV_CONN_DIRECT_LO_DUTY</p></li>
</ul>
<p>The DM_ADV_CONN_* types tell the controller to set a flag indicating the device is connectable.  The  DM_ADV_NONCONN_UNDIRECT type tells the controller to set a flag indicating the device is not connectable. The *_UNDIRECT types tell the controller the advertisement is not directed at a particular device address.  The *_DIRECT indicates the advertisement is targeted for a particular address.</p>
<p>The AppSetAdvPeerAddr sets the peer address for directed advertising.</p>
</section>
<section id="starting-and-stopping-legacy-advertising">
<h5>Starting and Stopping Legacy Advertising<a class="headerlink" href="#starting-and-stopping-legacy-advertising" title="Link to this heading"></a></h5>
<p>To start legacy advertising, call AppAdvStart.  Immediately after advertising begins, the DM will send the DM_ADV_START_IND to the application.  The AppAdvStart function takes one parameter, mode.  The mode is the connectable mode of the device and can be one of the following values:</p>
<ul class="simple">
<li><p>APP_MODE_CONNECTABLE</p></li>
<li><p>APP_MODE_DISCOVERABLE</p></li>
<li><p>APP_MODE_AUTO_INIT</p></li>
</ul>
<p>The APP_MODE_AUTO_INIT mode uses bonding information in the AF device database to determine if the device is connectable.  If the device has a bond, then the advertisement indicates the device is discoverable but not connectable.  If there is no bond, the advertisement indicates the device is connectable.</p>
<p>To stop legacy advertising, call AppAdvStop.  Immediately after advertising stops, the DM will send the DM_ADV_STOP_IND to the application.</p>
</section>
<section id="setting-advertising-data-in-extended-advertising">
<h5>Setting Advertising Data in Extended Advertising<a class="headerlink" href="#setting-advertising-data-in-extended-advertising" title="Link to this heading"></a></h5>
<p>In extended advertising, the BLE controller can support multiple sets of advertisements.  Each advertisement set is configured individually and the advertisements run simultaneously.</p>
<p>The DM_NUM_ADV_SETS configuration macro configures the maximum number of advertisement sets for an application.</p>
<p>The App Framework functions for setting advertising data in extended advertising operate similarly to their legacy advertising counterparts:</p>
<ul class="simple">
<li><p>AppExtAdvSetData</p></li>
<li><p>AppExtAdvSetAdValue</p></li>
<li><p>AppExtAdvAppendAdValue</p></li>
<li><p>AppExtSetAdvType</p></li>
<li><p>AppExtSetAdvPeerAddr</p></li>
<li><p>AppPerAdvSetData</p></li>
<li><p>AppPerAdvSetAdValue</p></li>
</ul>
</section>
<section id="starting-and-stopping-extended-advertising">
<h5>Starting and Stopping Extended Advertising<a class="headerlink" href="#starting-and-stopping-extended-advertising" title="Link to this heading"></a></h5>
<p>The *AppExtAdvStart *is used to start extended advertising.  The AppExtAdvStart function takes 3 parameters, numSets, pAdvHandles, and mode.  The numSets parameter is the number of advertising handles in the pAdvHandles parameter.  The pAdvHandles parameter is a list of advertising handles representing the advertisements being started.  The mode parameter can be one of the following values:</p>
<ul class="simple">
<li><p>APP_MODE_CONNECTABLE</p></li>
<li><p>APP_MODE_DISCOVERABLE</p></li>
<li><p>APP_MODE_AUTO_INIT</p></li>
</ul>
<p>These mode values have the same functions as in legacy advertising.</p>
<p>The *AppExtAdvStop *is used to stop extended advertising.  AppExtAdvStop function takes 2 parameters, numSets and pAdvHandles.  The numSets parameter is the number of handles in pAdvHandles.  The pAdvHandles parameter is a list of advertisements to be stopped.</p>
</section>
<section id="legacy-pdus-in-extended-advertisements">
<h5>Legacy PDUs in Extended Advertisements<a class="headerlink" href="#legacy-pdus-in-extended-advertisements" title="Link to this heading"></a></h5>
<p>Extended advertising can use the legacy PDU to be backward compatible with older BLE devices.  To enable legacy PDUs for an advertisement, set the useLegacyPdu[i] to true in the appExtAdvCfg_t configuration structure for the application.  Note that useLegacyPdu is an array and the index of each element in the array corresponds to an advertising handle.  When extended advertisements use the legacy PDU, the advertisement’s length is limited to 31 bytes.</p>
</section>
</section>
<section id="periodic-advertising">
<h4>Periodic Advertising<a class="headerlink" href="#periodic-advertising" title="Link to this heading"></a></h4>
<p>Periodic Advertising was added to BLE LE in version 5.0 of the Core BLE Specification.  Periodic advertisements are advertisements that are repeated at predictable time intervals.  Periodic advertisements permit low-power broadcast communication.  Listening devices synchronize with periodic advertisements and may remain in a low-power mode when not receiving advertisement data.</p>
<section id="initializing-the-host-for-periodic-advertising">
<h5>Initializing the Host for Periodic Advertising<a class="headerlink" href="#initializing-the-host-for-periodic-advertising" title="Link to this heading"></a></h5>
<p>To initialize the stack to use Periodic Advertising, call <em>DmExtAdvInit</em>.</p>
</section>
<section id="starting-and-stopping-periodic-advertising">
<h5>Starting and Stopping Periodic Advertising<a class="headerlink" href="#starting-and-stopping-periodic-advertising" title="Link to this heading"></a></h5>
<p>To start periodic advertising, first start extended advertising as described in previous sections.  On receipt of the DM_ADV_SET_START_IND call *AppPerAdvSetData *to set the periodic advertising data.  Then call *AppPerAdvStart *to start periodic advertising.  Immediately after periodic advertising starts the DM will send the DM_PER_ADV_SET_START_IND event to the application.</p>
<p>The AppPerAdvStart function takes two parameters, advHandle and advInterval.  The advHandle is a number used to identify the periodic advertisement.  The advHandle is the same handle as the extended advertisement the periodic advertisement originates from.  The advInterval is the period between periodic Advertisements in 0.625 ms time units.</p>
<p>A periodic advertisement train will continue after the extended advertisement stops.  To stop periodic advertising, call the *AppPerAdvStop *function.  Immediately after periodic advertising stops, the DM will send the DM_PER_ADV_SET_STOP_IND event to the application.  The AppPerAdvStop function takes one parameter, advHandle.  The advHandle is the same identifier as was used in AppPerAdvStart to start the advertisement.</p>
</section>
<section id="changing-periodic-advertising-data">
<h5>Changing Periodic Advertising Data<a class="headerlink" href="#changing-periodic-advertising-data" title="Link to this heading"></a></h5>
<p>*AppPerAdvSetData *can be called at any time during periodic advertising to change the periodic advertisement data.  The parameters of AppPerAdvSetData are advHandle, len, pData, and bufLen.  The advHandle is the handle passed into AppPerAdvStart to start periodic advertising.  The len parameter is the number of bytes in pData.  pData is a pointer to the new advertising data. The bufLen parameter is the number of bytes after the pData pointer that are reserved for the advertisement. The bufLen parameter is used by AppPerAdvSetAdValue when a change to a particular value results in an increase in the length of the advertisement.  If the resulting advertisement length is less than bufLen, then the change is permitted, else the change is not allowed.</p>
<p>*AppPerAdvSetAdValue *can be called at any time during periodic advertising to change an AD value in the advertisement.  The parameters to AppPerAdvSetAdValue are advHandle, adType, len, and pValue.  The advHandle is the handle passed into AppPerAdvStart to start the periodic advertisement.  The adType is the AD type of the advertisement element to change.  The len is the number of bytes in pValue.  The pValue is a pointer to the new value for the advertisement element. The return value of AppPerAdvSetAdValue is a boolean. The return value is true is the element’s value was changed, else the return value is false.  The AppPerAdvSetAdValue function can handle changes in the lengths of element values and the resulting length of an advertisement may change after a call to AppPerAdvSetAdValue.</p>
</section>
<section id="periodic-advertisement-handles">
<h5>Periodic Advertisement Handles<a class="headerlink" href="#periodic-advertisement-handles" title="Link to this heading"></a></h5>
<p>The DM_NUM_ADV_SETS configuration parameter defines the maximum number of advertisement sets managed by the AF layer.  The advertisement handle passed into AF periodic advertisement functions is used as an index into a list of advertisement set control information.  The periodic advertising handle is the same handle as the extended advertising handle for the extended advertisement the periodic advertisement originated from.</p>
</section>
</section>
<section id="scanning-for-advertisements">
<h4>Scanning for Advertisements<a class="headerlink" href="#scanning-for-advertisements" title="Link to this heading"></a></h4>
<section id="initializing-for-scan">
<h5>Initializing for Scan<a class="headerlink" href="#initializing-for-scan" title="Link to this heading"></a></h5>
<p>The <em>DmScanInit</em> function initializes the DM for legacy scanning.  The <em>DmExtScanInit</em> function initializes the DM for extended scanning.</p>
</section>
<section id="starting-and-stopping-scan">
<h5>Starting and Stopping Scan<a class="headerlink" href="#starting-and-stopping-scan" title="Link to this heading"></a></h5>
<p>When the DM is initialized for scan using DmScanInit, scanning is started with the *AppScanStart *function and stopped with the *AppScanStop *function.  Likewise, when the DM is initialized for a scan using DmExtScanInit, scanning is started with the *AppExtScanStart *function and stopped with the *AppExtScanStop *function.</p>
<p>The parameters to AppScanStart follow:</p>
<ul class="simple">
<li><p>mode - Scan discovery mode</p></li>
<li><p>scanType - Scan type</p></li>
<li><p>duration - Scan duration</p></li>
</ul>
<p>The parameters to AppExtScanStart follow:</p>
<ul class="simple">
<li><p>scanPhys - Scanner PHY</p></li>
<li><p>mode - Scan discovery mode</p></li>
<li><p>scanType - Scan type</p></li>
<li><p>duration - Scan duration</p></li>
<li><p>period - Scan period in 1.28 sec units</p></li>
</ul>
<p>The discovery mode is one of the following values:</p>
<ul class="simple">
<li><p>DM_DISC_MODE_NONE</p></li>
<li><p>DM_DISC_MODE_LIMITED</p></li>
<li><p>DM_DISC_MODE_GENERAL</p></li>
</ul>
<p>When advertising, devices set discoverability flags in their advertisements. Devices can advertise their discoverability as none, general, or limited. General discoverability means the device is always discoveryable. Limited discoverability means the device is discoverable for a short period of time. Non-discoverable means the device is not discoverable.</p>
<p>The controller can filter on an advertisement’s discoverability mode.  The scan discovery mode parameter of the AppScanStart and AppExtScanStart tells the DM layer to set a filter policy when scanning.  General scan mode sets the filter policy to limited and general advertisements.  Limited scan mode sets the filter policy to limited advertisements only.  No scan mode sets no filter policy.</p>
<p>The scan type must be one of the following values:</p>
<ul class="simple">
<li><p>DM_SCAN_TYPE_PASSIVE</p></li>
<li><p>DM_SCAN_TYPE_ACTIVE</p></li>
</ul>
<p>When active scanning, scan PDUs are sent by the scanning device.  Scan request PDUs are messages sent by the controller indicating the BD Address of the scanner. Advertising devices can respond to the scan request with a scan response PDU containing the advertiser’s BD address. When passive scanning, no scan request PDU is sent by the scanner.  The scanner listens for advertisements from all advertising devices that meet the controller’s filter policy.</p>
<p>When using extended scanning, the scan type is an array of size DM_NUM_PHYS.  Each element in the array corresponds to one of the scan PHY bits.  The DM_NUM_PHYS indicates the maximum number of PHYs the application makes use of.</p>
<p>The scan duration is the number of milliseconds to scan.</p>
<p>The scan PHY is a bitmask of the following values:</p>
<ul class="simple">
<li><p>HCI_SCAN_PHY_LE_1M_BIT</p></li>
<li><p>HCI_SCAN_PHY_LE_2M_BIT</p></li>
<li><p>HCI_SCAN_PHY_LE_CODED_BIT</p></li>
</ul>
<p>The scan PHY instructs the controller to use a physical channel for the scan.  The scan PHY is only used in extended scanning.</p>
<p>The scan period is a period of time in 1.28-sec units until the controller repeats the scan.  Set to zero to disable periodic scanning.  The scan period is only used in extended scanning.</p>
<p>Scan DM Events</p>
<p>The following scan-related DM events can be processed in the application:</p>
<ul class="simple">
<li><p>DM_SCAN_START</p></li>
<li><p>DM_EXT_SCAN_START_IND</p></li>
<li><p>DM_SCAN_STOP_IND</p></li>
<li><p>DM_EXT_SCAN_STOP_IND</p></li>
<li><p>DM_SCAN_REPORT_IND</p></li>
<li><p>DM_EXT_SCAN_REPORT_IND</p></li>
</ul>
<p>The DM_SCAN_START and DM_EXT_SCAN_START_IND events are sent to the application after scanning starts with an HCI_SECCESS status or an error code explaining why the scan didn’t start. DM_SCAN_START is used in legacy scanning and DM_EXT_SCAN_START is used in extended scanning.</p>
<p>The DM_SCAN_STOP and DM_EXT_SCAN_STOP_IND events are set to the application when scan stops. DM_SCAN_STOP is used in legacy scanning and DM_EXT_SCAN_STOP is used in extended scanning.</p>
<p>The DM_SCAN_REPORT_IND and DM_EXT_SCAN_REPORT_IND events are set to the application when a device’s advertisement is received. DM_SCAN_REPORT_INDis used in legacy scanning and DM_EXT_SCAN_REPORT_INDis used in extended scanning.</p>
</section>
<section id="processing-reports">
<h5>Processing Reports<a class="headerlink" href="#processing-reports" title="Link to this heading"></a></h5>
<p>The DM_SCAN_REPORT_IND and DM_EXT_SCAN_REPORT_IND events contain a scan report.  Extended scan reports have the hciLeExtAdvReportEvt_t type and are stored in the extScanReport in the union of DM event messages (dmEvt_t).  Legacy scan reports have the hciLeAdvReportEvt_t type and are stored in the scanReport in the union of DM event messages (dmEvt_t).</p>
<p>The structure of the legacy scan report follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>typedef struct
{
  wsfMsgHdr_t         hdr;            /*!&lt; Event header. */
  uint8_t             *pData;         /*!&lt; advertising or scan response data. */
  uint8_t             len;            /*!&lt; length of advertising or scan response data. */
  int8_t              rssi;           /*!&lt; RSSI. */
  uint8_t             eventType;      /*!&lt; Advertising event type. */
  uint8_t             addrType;       /*!&lt; Address type. */
  bdAddr_t            addr;           /*!&lt; Device address. */

  /* \brief direct fields */
  uint8_t             directAddrType; /*!&lt; Direct advertising address type. */
  bdAddr_t            directAddr;     /*!&lt; Direct advertising address. */
} hciLeAdvReportEvt_t;
</pre></div>
</div>
<p>The structure of the extended scan report follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>typedef struct
{
  wsfMsgHdr_t         hdr;            /*!&lt; Event header. */
  uint16_t            eventType;      /*!&lt; Event type. */
  uint8_t             addrType;       /*!&lt; Address type. */
  bdAddr_t            addr;           /*!&lt; Address. */
  uint8_t             priPhy;         /*!&lt; Primary PHY. */
  uint8_t             secPhy;         /*!&lt; Secondary PHY. */
  uint8_t             advSid;         /*!&lt; Advertising SID. */
  int8_t              txPower;        /*!&lt; Tx Power. */
  int8_t              rssi;           /*!&lt; RSSI. */
  int16_t             perAdvInter;    /*!&lt; Periodic advertising interval. */
  uint8_t             directAddrType; /*!&lt; Directed address type. */
  bdAddr_t            directAddr;     /*!&lt; Directed address. */
  uint16_t            len;            /*!&lt; Data buffer length. */
  uint8_t             *pData;         /*!&lt; Data buffer. */
} hciLeExtAdvReportEvt_t;
</pre></div>
</div>
<p>There are many ways to make use of the scan report, but the most common use is to find a peer device to establish a connection.  The following code is an example of using the advertising data in pData to find a device with a particular manufacturer ID.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">((</span><span class="n">pData</span> <span class="o">=</span> <span class="n">DmFindAdType</span><span class="p">(</span><span class="n">DM_ADV_TYPE_MANUFACTURER</span><span class="p">,</span> <span class="n">pMsg</span><span class="o">-&gt;</span><span class="n">scanReport</span><span class="o">.</span><span class="n">len</span><span class="p">,</span>
                                 <span class="n">pMsg</span><span class="o">-&gt;</span><span class="n">scanReport</span><span class="o">.</span><span class="n">pData</span><span class="p">))</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="o">/*</span> <span class="n">check</span> <span class="n">length</span> <span class="ow">and</span> <span class="n">vendor</span> <span class="n">ID</span> <span class="o">*/</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pData</span><span class="p">[</span><span class="n">DM_AD_LEN_IDX</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">BYTES_UINT16_CMP</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pData</span><span class="p">[</span><span class="n">DM_AD_DATA_IDX</span><span class="p">],</span> <span class="n">HCI_ID_PACKETCRAFT</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">connect</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>The DmFindAdType function scans advertising data looking for an advertisement type.</p>
</section>
</section>
<section id="synchronizing-with-periodic-advertisements">
<h4>Synchronizing with Periodic Advertisements<a class="headerlink" href="#synchronizing-with-periodic-advertisements" title="Link to this heading"></a></h4>
<p>Periodic advertisements repeat at predefined intervals.  A device that scans and listens to periodic advertisements must synchronize with the periodic advertisement.  The AppSyncStart function is used to synchronize with a periodic advertisement.  AppSyncStart takes the following parameters:</p>
<ul class="simple">
<li><p>advSid</p></li>
<li><p>advAddrType</p></li>
<li><p>pAdvAddr</p></li>
<li><p>skip</p></li>
<li><p>syncTimeout</p></li>
<li><p>syncCteType</p></li>
</ul>
<p>The advSid identifies the advertisement on the peer device.  The Sid value can be found in the syncHandle parameter of the perAdvReport element if the DM_PER_ADV_REPORT_IND DM event.</p>
<p>The advAddrType and pAdvAddr are the BD Address type and value of the advertising device.</p>
<p>The skip parameter is for power savings and indicates the number of advertising packets that can be skipped after each successfully received periodic advertisement.</p>
<p>The syncTimeout is the period of time to attempt to sync to the periodic advertisement before giving up and its units are 10ms.</p>
<p>The syncCteType parameter is used to determine which types of constant tones to synchronize with when using CTE.</p>
</section>
<section id="periodic-advertising-with-response-pawr">
<h4>Periodic Advertising with Response (PAWR)<a class="headerlink" href="#periodic-advertising-with-response-pawr" title="Link to this heading"></a></h4>
<p>Periodic Advertising with Response (PAWR) was added to the BLE specification in version 5.4.  PAwR permits periodic advertisements with subevent data and responses to periodic advertisements.</p>
<section id="initializing-for-pawr">
<h5>Initializing for PAWR<a class="headerlink" href="#initializing-for-pawr" title="Link to this heading"></a></h5>
<p>To include PAWR advertisements in an app, call DmExtPawrAdvInit at stack initialization.</p>
<p>To include support for scanning and synchronizing to PAWR in an app, call DmExtPawrScanInit at stack initialization.</p>
<p>To include initiation of Connections from PAWR in an app, call DmExtPawrConnMasterInit at stack initialization.</p>
<p>Note: Only initialize extended advertising, scanning, and connection master once. When modifying an application that already initializes extended advertising with DmExtAdvInit, replace DmExtAdvInit with DmExtPawrAdvInit. Similarly, to initialize initiating connection from PAWR, replace DmExtConnMasterInit with DmExtPawrConnMasterInit.</p>
</section>
</section>
<section id="advertising-with-pawr">
<h4>Advertising with PAWR<a class="headerlink" href="#advertising-with-pawr" title="Link to this heading"></a></h4>
<section id="apppawradvcfg-t">
<h5>appPawrAdvCfg_t<a class="headerlink" href="#apppawradvcfg-t" title="Link to this heading"></a></h5>
<p>To advertise with PAWR via the applications layer, begin by creating an extended periodic advertisement without PAWR. Then add an appPawrAdvCfg_t structure with the PAWR slot timing. Then in the application initialization, set pAppPawrCfg to point to the appPawrAdvCfg_t structure.</p>
</section>
<section id="dmperadvwithrspsetupsubevtslots">
<h5>DmPerAdvWithRspSetupSubEvtSlots<a class="headerlink" href="#dmperadvwithrspsetupsubevtslots" title="Link to this heading"></a></h5>
<p>To advertise with PAWR via a direct call to the DM, begin by creating an extended periodic advertisement without PAWR. Then add a call to DmPerAdvWithRspSetupSubEvtSlots. Calling DmPerAdvWithRspSetupSubEvtSlots with <code class="docutils literal notranslate"><span class="pre">numSubevents</span></code> greater than 0 turns on PAWR for the advertisement. Calling DmPerAdvWithRspSetupSubEvtSlots with <code class="docutils literal notranslate"><span class="pre">numSubevents</span></code> equal to 0 will revert to basic periodic advertising.</p>
<p>Note: DmPerAdvWithRspSetupSubEvtSlots is called during advertisement setup prior to starting advertising.</p>
</section>
<section id="dm-per-adv-sub-evt-data-req-ind">
<h5>DM_PER_ADV_SUB_EVT_DATA_REQ_IND<a class="headerlink" href="#dm-per-adv-sub-evt-data-req-ind" title="Link to this heading"></a></h5>
<p>The controller will send HCI events requesting Sub-Event Data. In the DM, the HCI event is changed into the DM_PER_ADV_SUB_EVT_DATA_REQ_IND event. When an application receives the DM_PER_ADV_SUB_EVT_DATA_REQ_IND event, the application must call DmPerAdvWithRspSetSubEvtData one or more times to set the sub-event data.</p>
</section>
<section id="dmperadvwithrspsetsubevtdata">
<h5>DmPerAdvWithRspSetSubEvtData<a class="headerlink" href="#dmperadvwithrspsetsubevtdata" title="Link to this heading"></a></h5>
<p>DmPerAdvWithRspSetSubEvtData is called by the application one or more times in response to the DM_PER_ADV_SUB_EVT_DATA_REQ_IND event to set sub-event data.</p>
</section>
<section id="dm-per-adv-rsp-report-ind">
<h5>DM_PER_ADV_RSP_REPORT_IND<a class="headerlink" href="#dm-per-adv-rsp-report-ind" title="Link to this heading"></a></h5>
<p>When the DM receives HCI events with subevent response data, the DM will call the application callback with the DM_PER_ADV_RSP_REPORT_IND event containing the response data.</p>
</section>
</section>
<section id="scanning-with-pawr">
<h4>Scanning with PAWR<a class="headerlink" href="#scanning-with-pawr" title="Link to this heading"></a></h4>
<p>The PAWR scan process is the same as periodic advertising without response.</p>
<section id="synchronization">
<h5>Synchronization<a class="headerlink" href="#synchronization" title="Link to this heading"></a></h5>
<p>Synchronizing with a periodic advertisement with response uses the same process as periodic advertising without response. However, there are two additional API functions, DmSyncSetRspData and DmSyncSetSyncSubevent.</p>
</section>
<section id="dmsyncsetsyncsubevent">
<h5>DmSyncSetSyncSubevent<a class="headerlink" href="#dmsyncsetsyncsubevent" title="Link to this heading"></a></h5>
<p>DmSyncSetSyncSubevent can used to instruct the controller to synchronize with a subset of subevents in a periodic advertisement train. DmSyncSetSyncSubevent is called from the application after receipt of the DM_PER_ADV_SYNC_TRSF_EST_IND event.</p>
</section>
<section id="dmsyncsetrspdata">
<h5>DmSyncSetRspData<a class="headerlink" href="#dmsyncsetrspdata" title="Link to this heading"></a></h5>
<p>DmSyncSetRspData can be called to set the response data in the controller. DmSyncSetRspData is generally called on the DM_PER_ADV_REPORT_IND event to set the response data in the controller to be transmitted on the given slot.</p>
</section>
</section>
<section id="connecting-from-a-pwar">
<h4>Connecting From a PWAR<a class="headerlink" href="#connecting-from-a-pwar" title="Link to this heading"></a></h4>
<p>To connect from a PAWR, replace the DmExtConnMasterInit initialization function with the DmExtPawrConnMasterInit initialization function. Then use the AppPawrConnOpen function to establish the connection.</p>
</section>
<section id="resolvable-private-addresses-rpa">
<h4>Resolvable Private Addresses (RPA)<a class="headerlink" href="#resolvable-private-addresses-rpa" title="Link to this heading"></a></h4>
<p>RPA, Resolvable Private Addresses, are pseudo-random BT Addresses that consist of a random number and a CMAC hash of the random number.  To use an RPA, the following must be added to an application:</p>
<ul class="simple">
<li><p>DM Privacy Initialization Functions</p></li>
<li><p>IRK, Identity Resolving Key</p></li>
<li><p>Add devices to the Resolving List</p></li>
<li><p>Enable Privacy</p></li>
<li><p>Add the Resolvable Private Address Only (RPAO) characteristic to GAP (optional)</p></li>
</ul>
<section id="dm-privacy-initialization">
<h5>DM Privacy Initialization<a class="headerlink" href="#dm-privacy-initialization" title="Link to this heading"></a></h5>
<p>Adding DmPrivInit to the application initialization routines will enable the resolving of private addresses.  Adding DmDevPrivInit to the application initialization routines will enable the generation of resolvable private addresses.</p>
</section>
<section id="fixed-identity-resolving-key-irk">
<h5>Fixed Identity Resolving Key (IRK)<a class="headerlink" href="#fixed-identity-resolving-key-irk" title="Link to this heading"></a></h5>
<p>The IRK can fixed on all devices.  To fix an IRK, add a global IRK to the application and set the IRK with the DmSecSetLocalIrk functions</p>
</section>
<section id="irk-exchange-with-smp">
<h5>IRK Exchange with SMP<a class="headerlink" href="#irk-exchange-with-smp" title="Link to this heading"></a></h5>
<p>An alternative to using a fixed IRK is to exchange an IRK with the SMP.  Use the following steps to configure the SMP to exchange an IRK during pairing.</p>
<p>Add the DM_KEY_DIST_IRK to the appSecCfg_t structure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/*! configurable parameters for security */
static const appSecCfg_t tagSecCfg =
{
  DM_AUTH_BOND_FLAG,                      /*! Authentication and bonding flags */
  DM_KEY_DIST_IRK,                        /*! Initiator key distribution flags */
  DM_KEY_DIST_LTK | DM_KEY_DIST_IRK,      /*! Responder key distribution flags */
  false,                                  /*! true if Out-of-band pairing data is present */
  false                                   /*! true to initiate security upon connection */
};
</pre></div>
</div>
<p>Add an IRK to the application.  The IRK can be const in memory or can be randomly generated.  However, once the IRK is exchanged it cannot change without exchanging keys again.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/*! local IRK */
static uint8_t localIrk[] =
{
  0x95, 0xC8, 0xEE, 0x6F, 0xC5, 0x0D, 0xEF, 0x93, 0x35, 0x4E, 0x7C, 0x57, 0x08, 0xE2, 0xA3, 0x85
};

</pre></div>
</div>
<p>Set the IRK in the application startup.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">/*</span> <span class="n">Set</span> <span class="n">IRK</span> <span class="k">for</span> <span class="n">the</span> <span class="n">local</span> <span class="n">device</span> <span class="o">*/</span>
  <span class="n">DmSecSetLocalIrk</span><span class="p">(</span><span class="n">localIrk</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="resolvable-private-address-only-rpao-gap-characteristic">
<h5>Resolvable Private Address Only (RPAO) GAP Characteristic<a class="headerlink" href="#resolvable-private-address-only-rpao-gap-characteristic" title="Link to this heading"></a></h5>
<p>If a device contains the Resolvable Private Address Only (RPAO) GAP Characteristic, then resolvable private addresses must be used after bonding.  To expose the RPAO characteristic in GAP, call the *SvcCoreGapAddRpaoCh *function.</p>
<p>During discovery, if a peer exposes the RPAO in GAP, then the application should set the Peer’s RPAO value in the app database after discovery.  The following code is taken from the TAG sample application and demonstrates how to set the peer RPAO in the app database after GAP discovery is complete.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">void</span> <span class="n">tagDiscGapCmpl</span><span class="p">(</span><span class="n">dmConnId_t</span> <span class="n">connId</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">appDbHdl_t</span> <span class="n">dbHdl</span><span class="p">;</span>

  <span class="o">/*</span> <span class="k">if</span> <span class="n">RPA</span> <span class="n">Only</span> <span class="n">attribute</span> <span class="n">found</span> <span class="n">on</span> <span class="n">peer</span> <span class="n">device</span> <span class="o">*/</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">pTagGapHdlList</span><span class="p">[</span><span class="n">GAP_RPAO_HDL_IDX</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ATT_HANDLE_NONE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
      <span class="p">((</span><span class="n">dbHdl</span> <span class="o">=</span> <span class="n">AppDbGetHdl</span><span class="p">(</span><span class="n">connId</span><span class="p">))</span> <span class="o">!=</span> <span class="n">APP_DB_HDL_NONE</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="o">/*</span> <span class="n">update</span> <span class="n">DB</span> <span class="o">*/</span>
    <span class="n">AppDbSetPeerRpao</span><span class="p">(</span><span class="n">dbHdl</span><span class="p">,</span> <span class="n">true</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="resolving-an-address">
<h5>Resolving an Address<a class="headerlink" href="#resolving-an-address" title="Link to this heading"></a></h5>
<p>The *DmPrivResolveAddr *function can be called to resolve a private address.  When the resolve address process is complete, the DM sends the DM_PRIV_RESOLVED_ADDR_IND event to the application.</p>
<p>The parameters to *DmPrivResolveAddr *are pAddr, pIrk, and param.  pAddr is the address to resolve. The pIrk parameter is the resolving key that was shared with the peer device by the SMP during pairing. The param parameter is a value that the DM will include in the param field of the DM_PRIV_RESOLVED_ADDR_IND event.</p>
</section>
<section id="add-devices-to-the-resolving-list">
<h5>Add Devices to the Resolving List<a class="headerlink" href="#add-devices-to-the-resolving-list" title="Link to this heading"></a></h5>
<p>The BLE controller can manage resolvable addresses for the host.  To enable address resolution in the controller, a peer device’s addresses must be added to the controller’s resolving list.</p>
<p>The *DmPrivAddDevToResList *function can be called to add a device to the resolving list.  The DM will send the DM_PRIV_ADD_DEV_TO_RES_LIST_IND event to the application when the add operation is complete. The *DmPrivRemDevFromResList *function can be called to remove a device from the resolving list.  The DM will send the DM_PRIV_REM_DEV_FROM_RES_LIST_IND event to the app when the remove operation is complete. *DmPrivClearResList *can be called to clear the entire resolving list.  The DM will send the DM_PRIV_CLEAR_RES_LIST_IND event to the application when the clear operation is complete.</p>
<p>Note:  One resolving list operation can take place in the controller.  Therefore, an application should queue and serialize calls to the <em>DmPrivAddDevToResList, DmPrivRemDevFromResList, and DmPrivClearResList <em>functions</em>.</em></p>
</section>
<section id="enable-privacy">
<h5>Enable Privacy<a class="headerlink" href="#enable-privacy" title="Link to this heading"></a></h5>
<p>To enable privacy, call <em>DmDevPrivStart</em>.  This function will tell the DM to begin using a private BD Address and also to change the private BD Address periodically (the period is the number of seconds passed int DmDevPrivStart). Privacy can be disabled with a call to <em>DmDevPrivStop</em>.</p>
</section>
</section>
<section id="enhanced-connection-update">
<h4>Enhanced Connection Update<a class="headerlink" href="#enhanced-connection-update" title="Link to this heading"></a></h4>
<p>The Enhanced Connection Update (ECU) procedure was added to BLE in v5.3 of the BLE Core Specification.  ECU provides faster updates to connection parameters which in turn lowers power consumption and improves user experience.</p>
<section id="initializing-ecu">
<h5>Initializing ECU<a class="headerlink" href="#initializing-ecu" title="Link to this heading"></a></h5>
<p>To include ECU functionality, an application must call DmEcuInit during application initialization.</p>
</section>
<section id="hcisubrateparam-t">
<h5>HciSubrateParam_t<a class="headerlink" href="#hcisubrateparam-t" title="Link to this heading"></a></h5>
<p>The HciSubrateParam_t structure contains subrate information for a connection.  The HciSubrateParam_t has the following members:</p>
<ul class="simple">
<li><p>srMin</p></li>
<li><p>srMax</p></li>
<li><p>maxLatency</p></li>
<li><p>contNum</p></li>
<li><p>svt</p></li>
</ul>
<p>The srMin and srMax are the min and max subrate values.  The subrate value provides devices with the ability to use a reduced number of connection intervals.  Devices only transmit on subrate connection events and may remain in low power mode for the remaining time.  The range of a subrate is 1 to 500.  The subrate indicates the number of events to skip before becoming active.</p>
<p>The maxLatency parameter is the maximum peripheral latency.  This latency permits a peripheral device to further reduce its number of active connection events.  The maxLatency is the maximum number of subrate events that the peripheral may skip listening to a central device.</p>
<p>The contNum specifies the number of connection intervals to remain active after a packet is transmitted or received.</p>
<p>The svt is the supervision timeout.  The supervision timeout is the period of time without communication before the connection is terminated.  The supervision timeout is in units of 10ms and can range from 100 ms to 32 seconds.</p>
</section>
<section id="dmecusetdefsubrate">
<h5>DmEcuSetDefSubrate<a class="headerlink" href="#dmecusetdefsubrate" title="Link to this heading"></a></h5>
<p>The *DmEcuSetDefSubrate *function Is used to set the initial subrate of all connections.  The DmEcuSetDefSubrate function takes one parameter, pSubrate which is a pointer to an HciSubrateParam_t structure with the initial subrate.</p>
</section>
<section id="dmecuupdatesubrate">
<h5>DmEcuUpdateSubrate<a class="headerlink" href="#dmecuupdatesubrate" title="Link to this heading"></a></h5>
<p>The DmEcuUpdateSubrate function Is used to change the subrate of a connection.  The DmEcuUpdateSubrate function takes two parameters, connId and pSubrate.  The connId is the connection identifier for the connection to update.  The pSubrate parameter is a pointer to an HciSubrateParam_t structure with the initial subrate.</p>
</section>
</section>
<section id="updating-phy">
<h4>Updating PHY<a class="headerlink" href="#updating-phy" title="Link to this heading"></a></h4>
<p>The original BLE 4.0 specification defined a 1 Mbps physical link (PHY). New physical links were added to the BLE v5.0 Specification.  These PHY’s include a 2 Mbps physical link and a long-range coded physical link with 4 times the range but with a lower data rate.</p>
<section id="phy-specific-advertisements">
<h5>PHY Specific Advertisements<a class="headerlink" href="#phy-specific-advertisements" title="Link to this heading"></a></h5>
<p>By default, advertisements are sent using the 1M PHY.  Extended advertisements may use the 2M and Coded PHY.</p>
</section>
<section id="phy-specific-scanning">
<h5>PHY Specific Scanning<a class="headerlink" href="#phy-specific-scanning" title="Link to this heading"></a></h5>
<p>By default, scanning takes place using the 1M PHY.  Extended scanning may use the 2M and Coded PHY.  The scanPhys parameter of AppExtScanStart can be used to set a bitmask of PHYs to scan.  The scanPhys parameter can be one or more of the following:</p>
<ul class="simple">
<li><p>HCI_PHY_LE_1M_BIT</p></li>
<li><p>HCI_PHY_LE_2M_BIT</p></li>
<li><p>HCI_PHY_LE_CODED_BIT</p></li>
</ul>
<p>PHY Specific Connections</p>
<p>By default, connections take place using the 1M PHY.  Extended connect may use the 2M and Coded PHY.  The initPhys parameter of AppExtConnOpen indicates a bitmask of PHYs to advertise to open the connection.  The initPhys parameter can be one or more of the following:</p>
<ul class="simple">
<li><p>HCI_PHY_LE_1M_BIT</p></li>
<li><p>HCI_PHY_LE_2M_BIT</p></li>
<li><p>HCI_PHY_LE_CODED_BIT</p></li>
</ul>
</section>
<section id="dmsetphy">
<h5>DmSetPhy<a class="headerlink" href="#dmsetphy" title="Link to this heading"></a></h5>
<p>The *DmSetPhy *function can be used to set the PHY of a connection.  The DmSetPhy function has the following parameters:</p>
<ul class="simple">
<li><p>connId</p></li>
<li><p>allPhys</p></li>
<li><p>txPhys</p></li>
<li><p>rxPhys</p></li>
<li><p>phyOptions</p></li>
</ul>
<p>The connId parameter is the connection identifier of the link to be updated.</p>
<p>The allPhys parameter is a bitfield indicating the PHY preference for a PHY for both tx and rx.  The allPhy parameter can be one or more of the following:</p>
<ul class="simple">
<li><p>HCI_ALL_PHY_ALL_PREFERENCES</p></li>
<li><p>HCI_ALL_PHY_TX_PREFERENCE_BIT</p></li>
<li><p>HCI_ALL_PHY_RX_PREFERENCE_BIT</p></li>
</ul>
<p>The txPhys parameter is a bitfield indicating the PHY preference for transmission.</p>
<p>The rxPhy parameter is a bitfield indicating the PHY preference for the receiver.</p>
<p>The txPhy and rxPhy can be one or more of the following values:</p>
<ul class="simple">
<li><p>HCI_PHY_NONE</p></li>
<li><p>HCI_PHY_LE_1M_BIT</p></li>
<li><p>HCI_PHY_LE_2M_BIT</p></li>
<li><p>HCI_PHY_LE_CODED_BIT</p></li>
</ul>
<p>When multiple preferences are set, the controller negotiates the PHY based on the local and peer hardware capabilities.</p>
<p>The phyOptions parameter can be one of the following values and indicates the coded PHY preference:</p>
<ul class="simple">
<li><p>HCI_PHY_OPTIONS_NONE</p></li>
<li><p>HCI_PHY_OPTIONS_S2_PREFERRED</p></li>
<li><p>HCI_PHY_OPTIONS_S8_PREFERRED</p></li>
</ul>
<p>The following code is an example of how to switch from to a 2M PHY:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DmSetPhy</span><span class="p">(</span><span class="n">connId</span><span class="p">,</span> <span class="n">HCI_ALL_PHY_ALL_PREFERENCES</span><span class="p">,</span> <span class="n">HCI_PHY_LE_2M_BIT</span><span class="p">,</span> <span class="n">HCI_PHY_LE_2M_BIT</span><span class="p">,</span>
         <span class="n">HCI_PHY_OPTIONS_NONE</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="constant-tone-extension">
<h4>Constant Tone Extension<a class="headerlink" href="#constant-tone-extension" title="Link to this heading"></a></h4>
<p>Constant Tone Extension (CTE) is a BLE v5.1 feature that permits Angle of Arrival (AoA) and Angle of Departure (AoD) direction finding.</p>
<section id="including-cte">
<h5>Including CTE<a class="headerlink" href="#including-cte" title="Link to this heading"></a></h5>
<p>To include CTE in the stack, call *DmConnCteInit *from the application’s initialization routine and call *dmConnCteMsgHandler *from the application’s event handler.</p>
</section>
<section id="configuring-cte-for-transmit">
<h5>Configuring CTE for Transmit<a class="headerlink" href="#configuring-cte-for-transmit" title="Link to this heading"></a></h5>
<p>The *DmConnCteTxConfig *function is used to configure a connection for CTE.  DmConnCteTxConfig takes the following parameters:</p>
<ul class="simple">
<li><p>connId</p></li>
<li><p>cteTypeBits</p></li>
<li><p>switchPatternLen</p></li>
<li><p>pAntennaIDs</p></li>
</ul>
<p>The connId parameter is the connection identifier for the link that is being configured for CTE.</p>
<p>The cteTypeBits is one of the following values:</p>
<ul class="simple">
<li><p>HCI_CTE_TYPE_PERMIT_AOA_RSP_BIT</p></li>
<li><p>HCI_CTE_TYPE_PERMIT_AOD_RSP_1_US_BIT</p></li>
<li><p>HCI_CTE_TYPE_PERMIT_AOD_RSP_2_US_BIT</p></li>
</ul>
<p>The switchPatternLen parameter contains the number of antenna identifiers in pAntennaIDs.</p>
<p>The pAntennaIDs parameter is a pointer to an array of bytes that contains the antenna identifiers for the antenna used in the CTE.</p>
</section>
<section id="starting-cte-transmit">
<h5>Starting CTE Transmit<a class="headerlink" href="#starting-cte-transmit" title="Link to this heading"></a></h5>
<p>The *DmConnCteReqStart *function is used to start transmitting CTE packets.  The DmConnCteReqStart function takes the following parameters:</p>
<ul class="simple">
<li><p>connId</p></li>
<li><p>cteReqInt</p></li>
<li><p>reqCteLen</p></li>
<li><p>reqCteType</p></li>
</ul>
<p>The connId parameter is the connection identifier for the link that is starting CTE.</p>
<p>The cteReqInt parameter is the number of connection events before starting CTE.  A value of zero indicates CTE should start immediately.</p>
<p>The reqCteLen parameter is the minimum length of the tone in 8 us units.  The value ma be between 0x02 and 0x14.</p>
<p>The reqCteType is one of the following values:</p>
<ul class="simple">
<li><p>HCI_CTE_TYPE_PERMIT_AOA_RSP_BIT</p></li>
<li><p>HCI_CTE_TYPE_PERMIT_AOD_RSP_1_US_BIT</p></li>
<li><p>HCI_CTE_TYPE_PERMIT_AOD_RSP_2_US_BIT</p></li>
</ul>
</section>
<section id="stopping-cte-transmit">
<h5>Stopping CTE Transmit<a class="headerlink" href="#stopping-cte-transmit" title="Link to this heading"></a></h5>
<p>The *DmConnCteReqStop *function can be called to stop CTE transmission.  The DmConnCteReqStop function has one parameter called connId.  The connId is the connection identifier for the link transmitting CTE.</p>
</section>
<section id="starting-cte-response">
<h5>Starting CTE Response<a class="headerlink" href="#starting-cte-response" title="Link to this heading"></a></h5>
<p>The *DmConnCteRspStart *function can be called to start CTE response. The DmConnCteRspStart function has one parameter called connId. The connId is the connection identifier for the link responding to CTE.</p>
</section>
<section id="stopping-cte-response">
<h5>Stopping CTE Response<a class="headerlink" href="#stopping-cte-response" title="Link to this heading"></a></h5>
<p>The *DmConnCteRspStop *function can be called to stop CTE response.  The DmConnCteRspStop function has one parameter called connId.  The connId is the connection identifier for the link responding to CTE.</p>
</section>
<section id="dm-conn-iq-report-ind">
<h5>DM_CONN_IQ_REPORT_IND<a class="headerlink" href="#dm-conn-iq-report-ind" title="Link to this heading"></a></h5>
<p>During CTE, the controller sends connection IQ reports to the host.  The DM notifies the application of the connection IQ reports with the DM_CONN_IQ_REPORT_IND event.  The DM_CONN_IQ_REPORT_IND event is sent with an hciLeConnIQReportEvt_t structure.  The hciLeConnIQReportEvt_t structure contains the following members:</p>
<ul class="simple">
<li><p>handle</p></li>
<li><p>rxPhy</p></li>
<li><p>dataChIdx</p></li>
<li><p>rssi</p></li>
<li><p>rssiAntennaId</p></li>
<li><p>cteType</p></li>
<li><p>slotDuration</p></li>
<li><p>pktStatus</p></li>
<li><p>sampleCnt</p></li>
<li><p>iSample</p></li>
<li><p>qSample</p></li>
</ul>
<p>The handle is the controller handle for the connection.  The connId can be found in the hdr.param wsfMsgHdr_t member.</p>
<p>The rxPhy is 1 for 1M PHY connections and 2 for 2M PHY connections.</p>
<p>The dataChIdx is the index of the data channel on which the data physical channel PDU was received.  The value can be from 0x00 to 0x24.</p>
<p>The rssi parameter is the RSSI on the connection in 0.1 dBm units in the range from -1270 to +200.</p>
<p>The rssiAntennaId is the antenna identifier of the antenna that measured the RSSI.</p>
<p>The cteType is one of the following values:</p>
<ul class="simple">
<li><p>HCI_CTE_TYPE_PERMIT_AOA_RSP_BIT</p></li>
<li><p>HCI_CTE_TYPE_PERMIT_AOD_RSP_1_US_BIT</p></li>
<li><p>HCI_CTE_TYPE_PERMIT_AOD_RSP_2_US_BIT</p></li>
</ul>
<p>The slotDuration is 1 when switching and sampling slots are i us each and 2 when the slots are 2 us each.</p>
<p>The pktStatus is one of the following values:</p>
<ul class="simple">
<li><p>HCI_CTE_PKT_STATUS_OK</p></li>
<li><p>HCI_CTE_PKT_STATUS_CRC_FAIL_CTE_FIELD</p></li>
<li><p>HCI_CTE_PKT_STATUS_CRC_FAIL_VS_CTE</p></li>
<li><p>HCI_CTE_PKT_STATUS_INSUFFICIENT_RESOURCES</p></li>
</ul>
<p>The sampleCnt contains the number of samples in iSample and qSample.  The values can be 0x00 for no samples, or 0x09 to 0x52.</p>
<p>The iSample parameter is an array of I samples.  Each byte in the array is the I sample for the RDU or 0x80 for no valid sample.</p>
<p>The qSample parameter is an array of Q samples.  Each byte in the array is the Q sample for the RDU or 0x80 for no valid sample.</p>
</section>
<section id="dm-cte-req-fail-ind">
<h5>DM_CTE_REQ_FAIL_IND<a class="headerlink" href="#dm-cte-req-fail-ind" title="Link to this heading"></a></h5>
<p>If the DM receives an error from the controller while configuring, starting, or stopping CTE, the DM will notify the application of the error with the DM_CTE_REQ_FAIL_IND event.</p>
</section>
<section id="iq-samples">
<h5>IQ Samples<a class="headerlink" href="#iq-samples" title="Link to this heading"></a></h5>
<p>I Samples (in-phase samples) and Q Samples (quadrature samples) are samples of an incoming signal that are taken 90 degrees out of phase of each other. Because the samples are measured 90 degrees out of phase, the samples’ amplitudes form a vector whereby the angle of the vector from the origin is the phase of the input signal.  The phase of the input sample can then be calculated from the IQ sample where tan(phase) = (Q/I).</p>
</section>
</section>
<section id="controller-filter-policy">
<h4>Controller Filter Policy<a class="headerlink" href="#controller-filter-policy" title="Link to this heading"></a></h4>
<p>The BLE controller can be configured to filter BLE traffic.  The filter is controlled with the *DmDevSetFilterPolicy *function.  DmDevSetFilterPolicy takes two parameters, mode and policy.  The mode parameter is the mode of operation to apply the filter policy.  The policy parameter is the filter policy to apply.</p>
<p>The policy modes are:</p>
<ul class="simple">
<li><p>DM_FILT_POLICY_MODE_ADV</p></li>
<li><p>DM_FILT_POLICY_MODE_SCAN</p></li>
<li><p>DM_FILT_POLICY_MODE_INIT</p></li>
<li><p>DM_FILT_POLICY_MODE_SYNC</p></li>
</ul>
<p>The filter policies are:</p>
<ul class="simple">
<li><p>HCI_FILT_NONE - Accept all advertising packets</p></li>
<li><p>HCI_FILT_WHITE_LIST - Accept from While List only</p></li>
<li><p>HCI_FILT_RES_INIT - Accept directed advertisements with RPAs</p></li>
<li><p>HCI_FILT_WHITE_LIST_RES_INIT - Accept from White List or directed advertisements with RPAs</p></li>
<li><p>HCI_FILT_PER_ADV_PARAM - Listen to the advertiser specified by creating sync command parameters</p></li>
<li><p>HCI_FILT_PER_ADV_LIST - Listen to advertisers from Periodic Advertiser List only</p></li>
</ul>
<p>An example of using the filter policy to only report scan reports from a whitelist of devices follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DmDevSetFilterPolicy</span><span class="p">(</span><span class="n">DM_FILT_POLICY_MODE_SCAN</span><span class="p">,</span> <span class="n">HCI_FILT_WHITE_LIST</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="whitelist">
<h4>Whitelist<a class="headerlink" href="#whitelist" title="Link to this heading"></a></h4>
<p>When using a whitelist filter policy, the *DmDevWhiteListAdd *and *DmDevWhiteListRemove *functions can be called to add devices to and remove devices from, a whitelist.  Additionally, *DmDevWhiteListClear *can be called to clear all devices in the whitelist.</p>
</section>
</section>
</section>
<section id="creating-a-new-profile-and-service">
<h2>Creating a New Profile and Service<a class="headerlink" href="#creating-a-new-profile-and-service" title="Link to this heading"></a></h2>
<p>This section is a step-by-step guide for developing new BLE profiles and services.</p>
<section id="ble-profile-and-service-file-locations">
<h3>BLE Profile and Service File Locations<a class="headerlink" href="#ble-profile-and-service-file-locations" title="Link to this heading"></a></h3>
<p>Service source code is located in ble-profiles\sources\services.</p>
<p>Profile source code is located in ble-profiles\sources\profiles.</p>
<section id="battery-service-example">
<h4>Battery Service Example<a class="headerlink" href="#battery-service-example" title="Link to this heading"></a></h4>
<p>The battery service will be referenced in this section as a simple example of a service and profile.  The battery service is located in ble-profiles\sources\services\svc_batt.c and svc_batt.h.</p>
</section>
</section>
<section id="service-and-attribute-design">
<h3>Service and Attribute Design<a class="headerlink" href="#service-and-attribute-design" title="Link to this heading"></a></h3>
<p>When designing a service, first define all data exposed by a Server to a Client. The client profile will use these data points to get information and control the server. For example, consider designing a service for a light bulb. For this particular light bulb, a user can turn the bulb on and off, set the brightness, and set the color of the light.  Our goal is to make a list of data the service will expose that will permit control of these three activities (light on/off, brightness, color). Let’s look at a few options for data to expose on the service.</p>
<p>Option 1: Three service characteristics that follow:</p>
<ul class="simple">
<li><p>State - enumeration, &lt;On, Off&gt;</p></li>
<li><p>Brightness - 8-bit integer, 0-255</p></li>
<li><p>Color - 24-bit integer with RGB value</p></li>
</ul>
<p>In this option, there is one characteristic for each parameter of the lightbulb.  In this case, writing off to the state attribute will turn the light off.  Writing a number to the brightness attribute will modify the luminosity of the bulb.  Writing an RGB value to the color attribute changes the light’s color.</p>
<p>Option 2: One characteristic that takes an opcode and a parameter:</p>
<ul class="simple">
<li><p>Control point - opcode, (optional) parameter</p></li>
</ul>
<p>In this second option, the control point data is a two to four-byte command.  The first byte in the command contains an opcode and the remaining bytes contain an optional value.  The opcodes might be:</p>
<ul class="simple">
<li><p>Set light state - value on/off</p></li>
<li><p>Set light brightness - value from 0-155</p></li>
<li><p>Set Light color - 24-bit RGB</p></li>
</ul>
<p>When the client writes to the control point, the profile parses the data and processes the opcode and parameter value permitting the same three actions to control the lightbulb as option #1.</p>
<p>These two approaches appear identical at first but consider a third option with more opcodes:</p>
<p>Option 3: Add three new opcodes to Option 2:</p>
<ul class="simple">
<li><p>Raise brightness</p></li>
<li><p>Lower brightness</p></li>
<li><p>Cycle to the next color in the spectrum</p></li>
</ul>
<p>In options #1 and #2, increasing brightness one notch required two ATT operations.  One ATT read to get the current brightness and one ATT write to set the new brightness. In the third option, a device can send a single message to raise brightness, and the bulb will calculate the new brightness value itself without the light switch needing to be aware of the current brightness.  This third option cuts the number of messages sent over the air in half and therefore extends the battery life of the light switch.</p>
<p>A complete process for designing a profile and service is out of the scope of this document.  However, as we can see from the above example, decisions made early in a Service’s design will have an influence on power management, code complexity, and performance in the final product.</p>
</section>
<section id="service-header-file">
<h3>Service Header File<a class="headerlink" href="#service-header-file" title="Link to this heading"></a></h3>
<p>Every em | bleu BLE service has a header file and an ANSI C source code file.  The header file for a service contains:</p>
<ul class="simple">
<li><p>Enumeration of attribute handles.</p></li>
<li><p>Function prototypes for adding and removing the service.</p></li>
</ul>
<p>Attribute handles are 16-bit identifiers, and are used in ATT operations such as read and write. Attribute handles are assigned by an application. During Service Discovery, a client will discover a peer device’s attribute handles.</p>
<p>Note:  Within an application, all attribute handles must be unique.  For example, the battery service attribute handles range from 0x60 to 0x63.  None of the attributes from another service in the application can use a handle in the range 0x60 to 0x63.</p>
<p>The following is an example of an attribute handle enumeration taken from the Battery Service header file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
#define BATT_START_HDL                    0x60                /*!&lt; Service start handle. */
#define BATT_END_HDL                      (BATT_MAX_HDL - 1)  /*!&lt; Service end handle. */

/*! \brief Battery Service Handles */
enum
{
  BATT_SVC_HDL = BATT_START_HDL,        /*!&lt; Battery service declaration */
  BATT_LVL_CH_HDL,                      /*!&lt; Battery level characteristic */
  BATT_LVL_HDL,                         /*!&lt; Battery level */
  BATT_LVL_CH_CCC_HDL,                  /*!&lt; Battery level CCCD */
  BATT_MAX_HDL                          /*!&lt; Maximum handle. */
};

</pre></div>
</div>
</section>
<section id="service-source-code-file">
<h3>Service Source Code File<a class="headerlink" href="#service-source-code-file" title="Link to this heading"></a></h3>
<p>The source code files for BLE Services are generally structured in a similar way from the top down as follows:</p>
<ul class="simple">
<li><p>Macros for the attribute security permissions.</p></li>
<li><p>Static variables with attribute data and attribute lengths.</p></li>
<li><p>Const array of attsAttr_t</p></li>
<li><p>Each item in the array contains a UUID, data, length, max length, settings, and permissions for one of the service attributes.</p></li>
<li><p>An attsGroup_t structure for the service.</p></li>
<li><p>Add and remove group functions.</p></li>
</ul>
<p>Embedded BLE devices have limited resources.  Therefore, the attribute descriptors are constructed from const arrays wherever possible to limit RAM usage.</p>
<p>Note: The Host can create and modify services at runtime using a functional API called the Dynamic ATT.  The Dynamic ATT constructs the attsAttr_t array at run-time in RAM. See section <TBD> for more information about the Dynamic ATT.</p>
<p>The following sections cover the structure of BLE Service C files in more detail.</p>
<section id="security-permission-macros">
<h4>Security Permission Macros<a class="headerlink" href="#security-permission-macros" title="Link to this heading"></a></h4>
<p>Most of BLE Services have macros for security permissions that can be overridden in the makefile for the applications.  The following example is taken from the Battery Service:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/*! Characteristic read permissions */
#ifndef BATT_SEC_PERMIT_READ
#define BATT_SEC_PERMIT_READ SVC_SEC_PERMIT_READ
#endif

/*! Characteristic write permissions */
#ifndef BATT_SEC_PERMIT_WRITE
#define BATT_SEC_PERMIT_WRITE SVC_SEC_PERMIT_WRITE
#endif
</pre></div>
</div>
<p>Making the security permissions configurable from the Makefile helps with debugging and portability.  A packet sniffer will not require a key to decode traffic when security is disabled.  The same Service C files will work in applications with different security needs.</p>
</section>
<section id="attribute-value-arrays">
<h4>Attribute Value Arrays<a class="headerlink" href="#attribute-value-arrays" title="Link to this heading"></a></h4>
<p>The service C file contains const and dynamic arrays that hold the value and length of each attribute.  These arrays are referenced from the attsAttr_t objects in the attribute list.</p>
<section id="primary-service">
<h5>Primary Service<a class="headerlink" href="#primary-service" title="Link to this heading"></a></h5>
<p>The first attribute in a service identifies the service. This first attribute generally has the primary service UUID (<code class="docutils literal notranslate"><span class="pre">attPrimSvcUuid</span></code>).  The pValue for the primary service attribute contains the UUID for the service.  This UUID can be a 2-byte service UUID reserved by the SIG or a 128-bit proprietary UUID that you can generate with an online UUID generator. The following is an example of the pValue and pLen of the primary service attribute taken from the Battery Service:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">const</span> <span class="n">uint8_t</span> <span class="n">battValSvc</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">UINT16_TO_BYTES</span><span class="p">(</span><span class="n">ATT_UUID_BATTERY_SERVICE</span><span class="p">)};</span>
<span class="n">static</span> <span class="n">const</span> <span class="n">uint16_t</span> <span class="n">battLenSvc</span> <span class="o">=</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">battValSvc</span><span class="p">);</span>
</pre></div>
</div>
<p>These two variables are then referenced in the pValue and pLen parameters of the first attsAttr_t object in the attribute list:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">/*</span> <span class="n">Service</span> <span class="n">declaration</span> <span class="o">*/</span>
  <span class="p">{</span>
    <span class="n">attPrimSvcUuid</span><span class="p">,</span>
    <span class="p">(</span><span class="n">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">battValSvc</span><span class="p">,</span>
    <span class="p">(</span><span class="n">uint16_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">battLenSvc</span><span class="p">,</span>
    <span class="n">sizeof</span><span class="p">(</span><span class="n">battValSvc</span><span class="p">),</span>
    <span class="mi">0</span><span class="p">,</span>
    <span class="n">ATTS_PERMIT_READ</span>
  <span class="p">},</span>
</pre></div>
</div>
</section>
<section id="characteristic-declaration">
<h5>Characteristic Declaration<a class="headerlink" href="#characteristic-declaration" title="Link to this heading"></a></h5>
<p>The first attribute of a characteristic is the characteristic declaration.  The declaration is an array that contains three fields:</p>
<ul class="simple">
<li><p>Bitmask of characteristic properties (1 or 2 bytes depending on the next bit)</p></li>
<li><p>Characteristic value attribute handle (2 bytes)</p></li>
<li><p>16-bit or 128-bit characteristic UUID</p></li>
</ul>
<p>The battery level characteristic declaration follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">ATT_PROP_READ</span> <span class="o">|</span> <span class="n">ATT_PROP_NOTIFY</span><span class="p">,</span> <span class="n">UINT16_TO_BYTES</span><span class="p">(</span><span class="n">BATT_LVL_HDL</span><span class="p">),</span> <span class="n">UINT16_TO_BYTES</span><span class="p">(</span><span class="n">ATT_UUID_BATTERY_LEVEL</span><span class="p">)}</span>
</pre></div>
</div>
<p>The battery level has two properties: Read and Notify.  The handle field contains the handle of the attribute that contains the battery-level value.  The UUID is the 16-bit UUID for a battery level.</p>
<section id="characteristic-properties">
<h6>Characteristic Properties<a class="headerlink" href="#characteristic-properties" title="Link to this heading"></a></h6>
<p>Characteristic properties can be one of more of the following bits:</p>
<ul class="simple">
<li><p>ATT_PROP_BROADCAST</p></li>
<li><p>ATT_PROP_READ</p></li>
<li><p>ATT_PROP_WRITE_NO_RSP</p></li>
<li><p>ATT_PROP_WRITE</p></li>
<li><p>ATT_PROP_NOTIFY</p></li>
<li><p>ATT_PROP_INDICATE</p></li>
<li><p>ATT_PROP_AUTHENTICATED</p></li>
<li><p>ATT_PROP_EXTENDED</p></li>
</ul>
<p>The extended properties follow:</p>
<ul class="simple">
<li><p>ATT_EXT_PROP_RELIABLE_WRITE</p></li>
<li><p>ATT_EXT_PROP_WRITEABLE_AUX</p></li>
</ul>
</section>
</section>
</section>
<section id="attribute-lengths">
<h4>Attribute Lengths<a class="headerlink" href="#attribute-lengths" title="Link to this heading"></a></h4>
<p>The attribute lengths are stored as pointers to uint16_t.  The uint16_t are generally const to conserve RAM.  In cases where the attribute length can change, make the length non-const and set the ATTS_SET_VARIABLE_LEN attribute setting.</p>
</section>
<section id="attribute-structure-attsattr-t">
<h4>Attribute Structure (attsAttr_t)<a class="headerlink" href="#attribute-structure-attsattr-t" title="Link to this heading"></a></h4>
<p>The attsAttr_t structure contains the following information about each attribute:</p>
<ul class="simple">
<li><p>pUuid: Attribute UUID.</p></li>
<li><p>pValue: A pointer to the attribute’s data.</p></li>
<li><p>pLen: The length of pValue in bytes.</p></li>
<li><p>maxLen: The maximum length of pValue.</p></li>
<li><p>settings: A bitmask of attribute settings.</p></li>
<li><p>permissions: A bitmask of attribute permissions.</p></li>
</ul>
<section id="attribute-uuid">
<h5>Attribute UUID<a class="headerlink" href="#attribute-uuid" title="Link to this heading"></a></h5>
<p>For a complete list of attribute UUID, see the att_uuid.h header file.  UUID are used in multiple places in service descriptor tables.  In this section, we are looking at the pUUID parameter of the attsAttr_t structure.  These UUIDs can be GATT UUID, Descriptor UUID, or Characteristic UUID.</p>
<p>The most common GATT UUID is the primary service UUID (attPrimSvcUuid).  This is generally the pUUID of the first attribute in the attribute list.</p>
<p>Characteristics are constructed from 2 or more attributes.  The first attribute in a characteristic will always have a pUuid of the GATT characteristic UUID (attChUuid). The second attribute’s pUuid is the UUID that identifies the characteristic. Optionally, if the characteristic supports notify or indicate, the third attribute will have a pUuid of attCliChCfgUuid.  This indicates the attribute is the client characteristic configuration, and is used to enable or disable notifications and/or indications for the characteristic.</p>
</section>
<section id="attribute-settings">
<h5>Attribute Settings<a class="headerlink" href="#attribute-settings" title="Link to this heading"></a></h5>
<p>The attribute settings can be one or more of the following bits:</p>
<ul class="simple">
<li><p>ATTS_SET_UUID_128</p></li>
<li><p>ATTS_SET_WRITE_CBACK</p></li>
<li><p>ATTS_SET_READ_CBACK</p></li>
<li><p>ATTS_SET_VARIABLE_LEN</p></li>
<li><p>ATTS_SET_ALLOW_OFFSET</p></li>
<li><p>ATTS_SET_CCC</p></li>
<li><p>ATTS_SET_ALLOW_SIGNED</p></li>
<li><p>ATTS_SET_REQ_SIGNED</p></li>
</ul>
<p>The ATTS_SET_UUID_128 setting tells the ATT layer to treat the pUuid as a 128-bit UUID instead of a 16-bit UUID.</p>
<p>The ATTS_SET_WRITE_CBACK and ATTS_SET_READ_CBACK settings instruct the ATT layer to call the callback function for the attribute group (attsGroup_t) object.  This callback function can be used to calculate attribute data or read hardware as opposed to completing the operation with data defined in the service.</p>
<p>ATTS_SET_VARIABLE_LEN tells the ATT layer that the length of the attribute data can change.</p>
<p>ATTS_SET_ALLOW_OFFSET tells the ATT layer that the peer can access the attribute using an offset.</p>
<p>ATTS_SET_CCC tells the ATT layer that the attribute is a client characteristic configuration.</p>
<p>ATTS_SET_ALLOW_SIGNED and ATTS_SET_REQ_SIGNED are used in signed ATT reads and writes.  Signed reads and writes are generally considered to be depreciated.  However, the ATT layer provides support for signed reads and writes.</p>
</section>
<section id="attribute-permissions">
<h5>Attribute Permissions<a class="headerlink" href="#attribute-permissions" title="Link to this heading"></a></h5>
<p>The attribute permissions can be one or more of the following:</p>
<ul class="simple">
<li><p>ATTS_PERMIT_READ</p></li>
<li><p>ATTS_PERMIT_READ_AUTH</p></li>
<li><p>ATTS_PERMIT_READ_AUTHORIZ</p></li>
<li><p>ATTS_PERMIT_READ_ENC</p></li>
<li><p>ATTS_PERMIT_WRITE</p></li>
<li><p>ATTS_PERMIT_WRITE_AUTH</p></li>
<li><p>ATTS_PERMIT_WRITE_AUTHORIZ</p></li>
<li><p>ATTS_PERMIT_WRITE_ENC</p></li>
</ul>
<p>ATTS_PERMIT_READ and ATTS_PERMIT_WRITE permit reading and writing without any security considerations.</p>
<p>ATTS_PERMIT_READ_AUTH and ATTS_PERMIT_WRITE_AUTH indicate to the ATT that the attribute can only be read or written when the link is authenticated.</p>
<p>ATTS_PERMIT_READ_AUTHORIZ and ATTS_PERMIT_WRITE_AUTHORIZ indicate to the ATT that a callback should be used to get authorization from the application before permitting a read or write. The authorCback is set with the *AttsAuthorRegister *function.</p>
<p>ATTS_PERMIT_READ_ENC and ATTS_PERMIT_WRITE_ENC indicate to the ATT that the attribute can only be read or written when the link is encrypted.</p>
<p>Note: Some combinations may have unexpected results.  ATTS_PERMIT_READ | ATTS_PERMIT_READ_ENC might be processed as either case in the stack. Either an attribute can be read without encryption or with encryption.  Not both.</p>
</section>
</section>
<section id="client-configuration-characteristic-ccc">
<h4>Client Configuration Characteristic (CCC)<a class="headerlink" href="#client-configuration-characteristic-ccc" title="Link to this heading"></a></h4>
<p>A Client Configuration Characteristic is an optional third attribute of a characteristic.  The CCC attribute has the attCliChCfgUuid UUID and the ATTS_SET_CCC setting bit.  The CCC value and max len are always 1 byte long.</p>
</section>
<section id="attribute-group-structure-attsgroup-t">
<h4>Attribute Group Structure (attsGroup_t)<a class="headerlink" href="#attribute-group-structure-attsgroup-t" title="Link to this heading"></a></h4>
<p>The Attribute group structure is a node in a linked list of attribute lists.  Adding a service results in inserting an attsGroup_t into the ATT Layer’s linked list of service attributes.  Removing a service results in removing a node from the linked list.</p>
<p>The attsGroup_t structure contains the following:</p>
<ul class="simple">
<li><p>pNext</p></li>
<li><p>pAttr</p></li>
<li><p>readCback</p></li>
<li><p>writeCback</p></li>
<li><p>startHandle</p></li>
<li><p>endHandle</p></li>
</ul>
<p>The pNext is managed by the ATT Layer.  The pAttr contains a pointer to the services attribute list.  The readCback and writeCback are functions called when an attribute has the ATTS_SET_WRITE_CBACK and ATTS_SET_READ_CBACK settings bit set.  The startHandle and endHandler are the first and last attribute handles in the group.</p>
<p>The following is an example of an attribute group taken from the battery service:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Battery</span> <span class="n">group</span> <span class="n">structure</span> <span class="o">*/</span>
<span class="n">static</span> <span class="n">attsGroup_t</span> <span class="n">svcBattGroup</span> <span class="o">=</span>
<span class="p">{</span>
  <span class="n">NULL</span><span class="p">,</span>
  <span class="p">(</span><span class="n">attsAttr_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">battList</span><span class="p">,</span>
  <span class="n">NULL</span><span class="p">,</span>
  <span class="n">NULL</span><span class="p">,</span>
  <span class="n">BATT_START_HDL</span><span class="p">,</span>
  <span class="n">BATT_END_HDL</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="adding-and-removing-a-service">
<h4>Adding and Removing a Service<a class="headerlink" href="#adding-and-removing-a-service" title="Link to this heading"></a></h4>
<p>A service is added to the ATT by calling AttsAddGroup with the services attsGroup_t object.  A service is removed by calling AttsRemoveGroup with the start handle for the group.</p>
</section>
<section id="registering-service-callback-functions">
<h4>Registering Service Callback Functions<a class="headerlink" href="#registering-service-callback-functions" title="Link to this heading"></a></h4>
<p>Services that use read-and-write callback functions generally provide a function for the application or profile to register callback functions.  The following is an example from the Battery Service:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">SvcBattCbackRegister</span><span class="p">(</span><span class="n">attsReadCback_t</span> <span class="n">readCback</span><span class="p">,</span> <span class="n">attsWriteCback_t</span> <span class="n">writeCback</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">svcBattGroup</span><span class="o">.</span><span class="n">readCback</span> <span class="o">=</span> <span class="n">readCback</span><span class="p">;</span>
  <span class="n">svcBattGroup</span><span class="o">.</span><span class="n">writeCback</span> <span class="o">=</span> <span class="n">writeCback</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="client-profile">
<h3>Client Profile<a class="headerlink" href="#client-profile" title="Link to this heading"></a></h3>
<p>This section covers how to develop a Profile Client.</p>
<section id="client-profile-file-location-and-naming-convention">
<h4>Client Profile File Location and Naming Convention<a class="headerlink" href="#client-profile-file-location-and-naming-convention" title="Link to this heading"></a></h4>
<p>Client Profile code is located in ble-profiles/sources/profiles.  The naming convention for client profile folders and file prefix is the acronym for the profile followed by ‘pc’, for the profile’s client. For example, the Client Profile for the Asset Tracking Profile is named <em>atpc.</em></p>
</section>
<section id="id8">
<h4>Discovery<a class="headerlink" href="#id8" title="Link to this heading"></a></h4>
<p>The Application Framework (AF) attribute discovery process relies on functions and data structures in the client profile.  Client Profiles include the following to enable attribute discovery:</p>
<ul class="simple">
<li><p>Discovery Characteristics Table</p></li>
<li><p>Discovery Function</p></li>
<li><p>Set Handle List Function</p></li>
</ul>
<section id="discovery-characteristics-table">
<h5>Discovery Characteristics Table<a class="headerlink" href="#discovery-characteristics-table" title="Link to this heading"></a></h5>
<p>The Client Profile’s discovery characteristics table is an array of pointers to attcDiscChar_t.  Each attcDiscChar_t of the table contains the UUID of a characteristic to discover and discovery settings.  The settings parameter is a bitmask that can be one or more of the following values:</p>
<ul class="simple">
<li><p>ATTC_SET_UUID_128</p></li>
<li><p>ATTC_SET_REQUIRED</p></li>
<li><p>ATTC_SET_DESCRIPTOR</p></li>
</ul>
<p>Setting the ATTC_SET_UUID_128 bit indicates the UUID is a 128-bit UUID.  If the ATTC_SET_UUID_128 bit is not set, the UUID is a standard 16-bit UUID.  Setting the ATTC_SET_REQUIRED bit indicates the characteristic must be discovered for the Client Profile to function properly.  The ATTC_SET_DESCRIPTOR bit indicates the discovery of a client configuration characteristic for the previous characteristic in the discovery characteristics table.</p>
<p>An example from the Health Thermometer Profile follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/*! Temperature measurement */
static const attcDiscChar_t htpcHtsTm =
{
  attTmChUuid,
  ATTC_SET_REQUIRED
};

/*! Temperature measurement CCC descriptor */
static const attcDiscChar_t htpcHtsTmCcc =
{
  attCliChCfgUuid,
  ATTC_SET_REQUIRED | ATTC_SET_DESCRIPTOR
};

/*! Intermediate temperature */
static const attcDiscChar_t htpcHtsIt =
{
  attItChUuid,
  0
};

/*! Intermediate temperature CCC descriptor */
static const attcDiscChar_t htpcHtsItCcc =
{
  attCliChCfgUuid,
  ATTC_SET_DESCRIPTOR
};

/*! Temperature type */
static const attcDiscChar_t htpcHtsTt =
{
  attTtChUuid,
  0
};

/*! List of characteristics to be discovered; order matches handle index enumeration  */
static const attcDiscChar_t *htpcHtsDiscCharList[] =
{
  &amp;htpcHtsTm,                    /*! Temperature measurement */
  &amp;htpcHtsTmCcc,                 /*! Temperature measurement CCC descriptor */
  &amp;htpcHtsIt,                    /*! Intermediate temperature */
  &amp;htpcHtsItCcc,                 /*! Intermediate temperature CCC descriptor */
  &amp;htpcHtsTt                     /*! Temperature type */
};
</pre></div>
</div>
</section>
<section id="discovery-function">
<h5>Discovery Function<a class="headerlink" href="#discovery-function" title="Link to this heading"></a></h5>
<p>The Client Profile’s discovery function is called from the application to start service discovery.  The Client Profile’s discovery function calls AppDiscFindService with the discovery characteristics table.  An example of a discovery function follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">HtpcHtsDiscover</span><span class="p">(</span><span class="n">dmConnId_t</span> <span class="n">connId</span><span class="p">,</span> <span class="n">uint16_t</span> <span class="o">*</span><span class="n">pHdlList</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">AppDiscFindService</span><span class="p">(</span><span class="n">connId</span><span class="p">,</span> <span class="n">ATT_16_UUID_LEN</span><span class="p">,</span> <span class="p">(</span><span class="n">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">attHtsSvcUuid</span><span class="p">,</span>
                     <span class="n">HTPC_HTS_HDL_LIST_LEN</span><span class="p">,</span> <span class="p">(</span><span class="n">attcDiscChar_t</span> <span class="o">**</span><span class="p">)</span> <span class="n">htpcHtsDiscCharList</span><span class="p">,</span> <span class="n">pHdlList</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="set-handle-list-function">
<h5>Set Handle List Function<a class="headerlink" href="#set-handle-list-function" title="Link to this heading"></a></h5>
<p>The Client Profile may require a local copy of the pHdlList parameter from the Discovery Function. If a Client Profile stores a local copy of the pHdlList and the application supports bonding, then a Set Handle List function is required. The set handle list function is called by the application after discovery or after a connection is established with a bonded device.  An example set handle list function follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">CpSetHandles</span><span class="p">(</span><span class="n">dmConnId_t</span> <span class="n">connId</span><span class="p">,</span> <span class="n">uint16_t</span> <span class="o">*</span><span class="n">pHdlList</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">/*</span> <span class="n">Record</span> <span class="n">handle</span> <span class="nb">list</span> <span class="k">for</span> <span class="n">connection</span> <span class="o">*/</span>
  <span class="n">cpCcb</span><span class="o">.</span><span class="n">connCb</span><span class="p">[</span><span class="n">connId</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pHdlList</span> <span class="o">=</span> <span class="n">pHdlList</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="value-update">
<h4>Value Update<a class="headerlink" href="#value-update" title="Link to this heading"></a></h4>
<p>The value update function is called by the application to notify the Client Profile that a characteristic value changed.  This function is called by the application when a client receives an ATT notify or indicate from a server.</p>
</section>
<section id="initialization-function">
<h4>Initialization Function<a class="headerlink" href="#initialization-function" title="Link to this heading"></a></h4>
<p>A Client Profile may include an initialization function that is called from the application’s handler init function.  The initialization function can be used to initialize the Client Profile’s control block, load pointers to callback functions, etc.</p>
</section>
<section id="system-event-handler">
<h4>System Event Handler<a class="headerlink" href="#system-event-handler" title="Link to this heading"></a></h4>
<p>A Client Profile may include an event handler function.  The application calls a Client Profile’s event handler function from the application handler.  The Client Profile’s event handler function gives the Client Profile access to system events.  For example, if a Client Profile needs to clear information in a control block at the beginning of every connection, the event handler function can switch on the system event, and clear the control block on a DM_CONN_OPEN_IND event.  In addition to DM events, the Client Profile may also act on ATT events like ATTC_HANDLE_VALUE_NTF.</p>
</section>
<section id="notifications-and-indications">
<h4>Notifications and Indications<a class="headerlink" href="#notifications-and-indications" title="Link to this heading"></a></h4>
<p>A Client Profile may process notifications and indications sent from a server by processing the ATTC_HANDLE_VALUE_NTF and ATTC_HANDLE_VALUE_IND in its event handler function.</p>
</section>
<section id="attribute-read-and-write-functions">
<h4>Attribute Read and Write Functions<a class="headerlink" href="#attribute-read-and-write-functions" title="Link to this heading"></a></h4>
<p>The Client Profile may include functions to read and write service characteristics on the server.</p>
<section id="read-function">
<h5>Read Function<a class="headerlink" href="#read-function" title="Link to this heading"></a></h5>
<p>A characteristic read function calls AttcReadReq with the connection ID and the handle of the attribute.  The attribute handle is found in the pHdlList passed to the discovery function.  An example read function follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">CpReadAttributeOne</span><span class="p">(</span><span class="n">dmConnId_t</span> <span class="n">connId</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">uint16_t</span> <span class="o">*</span><span class="n">pHdlList</span> <span class="o">=</span> <span class="n">cpCcb</span><span class="o">.</span><span class="n">connCb</span><span class="p">[</span><span class="n">connId</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pHdlList</span><span class="p">;</span>

  <span class="n">WSF_ASSERT</span><span class="p">(</span><span class="n">pHdlList</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">pHdlList</span><span class="p">[</span><span class="n">CP_ATTR_ONE_HDL_IDX</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ATT_HANDLE_NONE</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="o">/*</span> <span class="n">send</span> <span class="n">message</span> <span class="o">*/</span>
    <span class="n">AttcReadReq</span><span class="p">(</span><span class="n">connId</span><span class="p">,</span> <span class="n">pHdlList</span><span class="p">[</span><span class="n">CP_ATTR_ONE_HDL_IDX</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The application calls characteristic read functions to read the value of a characteristic from a server. When the server responds to the read, the ATT layer will send the ATTC_READ_RSP event to the application. A client profile with characteristic read functions should process ATTC_READ_RSP events in the profile’s Event Handler. When a ATTC_WRITE_RSP is received with the handle of the read in progress, the Client Profile may parse the read response data and pass the data to the application.  One method for passing the read response data to the application is through callback function(s) registered with the Client Profile at application startup.</p>
</section>
<section id="write-function">
<h5>Write Function<a class="headerlink" href="#write-function" title="Link to this heading"></a></h5>
<p>An attribute write function calls AttcWriteReq with the connection ID, the handle of the attribute, and the data to write to the attribute. The attribute handle is found in the pHdlList passed to the discovery function.  An example write function follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define CP_ATTR_TWO_DATA_LEN        6</span>

<span class="n">void</span> <span class="n">CpWriteAttrTwo</span><span class="p">(</span><span class="n">dmConnId_t</span> <span class="n">connId</span><span class="p">,</span> <span class="n">uint16_t</span> <span class="n">val1</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">val2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">uint16_t</span> <span class="o">*</span><span class="n">pHdlList</span> <span class="o">=</span> <span class="n">cpCcb</span><span class="o">.</span><span class="n">connCb</span><span class="p">[</span><span class="n">connId</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pHdlList</span><span class="p">;</span>
  <span class="n">uint8_t</span>   <span class="n">data</span><span class="p">[</span><span class="n">CP_ATTR_TWO_DATA_LEN</span><span class="p">]</span>
  <span class="n">uint8_t</span>  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

  <span class="n">WSF_ASSERT</span><span class="p">(</span><span class="n">pHdlList</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">);</span>

  <span class="o">/*</span> <span class="n">pack</span> <span class="n">the</span> <span class="n">data</span> <span class="o">*/</span>
  <span class="n">UINT16_TO_BSTREAM</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">val1</span><span class="p">);</span>
  <span class="n">UINT32_TO_BSTREAM</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">val2</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">pHdlList</span><span class="p">[</span><span class="n">CP_ATTR_TWO_HDL_IDX</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ATT_HANDLE_NONE</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="o">/*</span> <span class="n">send</span> <span class="n">message</span> <span class="o">*/</span>
    <span class="n">AttcWriteReq</span><span class="p">(</span><span class="n">connId</span><span class="p">,</span> <span class="n">pHdlList</span><span class="p">[</span><span class="n">CP_ATTR_TWO_HDL_IDX</span><span class="p">],</span> <span class="n">CP_ATTR_TWO_DATA_LEN</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The application calls Client Profile to write functions to write the value of a characteristic on a server.  The profile’s event handler can process the ATTC_WRITE_RSP to get the status of the operation.</p>
</section>
<section id="multiple-att-read-and-write-operations">
<h5>Multiple ATT Read and Write Operations<a class="headerlink" href="#multiple-att-read-and-write-operations" title="Link to this heading"></a></h5>
<p>The ATT Layer only supports one operation per ATT bearer at a time.  The profile and application are responsible for ensuring multiple ATT read and write operations are performed in serial. This may require a state machine that performs one operation and waits for a response before performing the next operation.  Some applications may require a queue system.</p>
</section>
</section>
</section>
<section id="server-profile">
<h3>Server Profile<a class="headerlink" href="#server-profile" title="Link to this heading"></a></h3>
<p>This section covers how to develop a Server Profile.</p>
<section id="server-profile-file-location-and-naming-convention">
<h4>Server Profile File Location and Naming Convention<a class="headerlink" href="#server-profile-file-location-and-naming-convention" title="Link to this heading"></a></h4>
<p>The server profile code is located in ble-profiles/sources/profiles.  The naming convention for server profile folders and file prefix is the acronym for the profile followed by ‘ps’, for the profile’s server. For example, the Server Profile for the Asset Tracking Profile is named <em>atps.</em></p>
</section>
<section id="id9">
<h4>System Event Handler<a class="headerlink" href="#id9" title="Link to this heading"></a></h4>
<p>A Server Profile may include an event handler function.  The application calls a Server Profile’s event handler function from the application’s event handler.  The Server Profile’s event handler function gives the Server Profile access to system events.  For example, if a Server Profile needs to clear information in a control block at the beginning of every connection, the profile’s event handler function can switch on the system event, and clear the control block on a DM_CONN_OPEN_IND event.  The Server Profile may also act on ATT events like ATTS_HANDLE_VALUE_CNF.</p>
</section>
<section id="client-characteristic-configuration">
<h4>Client Characteristic Configuration<a class="headerlink" href="#client-characteristic-configuration" title="Link to this heading"></a></h4>
<p>The client writes to Client Characteristic Configuration (CCC) attributes to enable or disable notifications and indications.  The Server Profile uses the AttsCccEnabled function to determine if a notification or indication can be sent based on the CCC value.</p>
<p>Each connection has one CCC table that is shared by all profiles in the application. The structure of the CCC table is defined in the application. The Server Profile needs to know how to map service characteristics to indices in the CCC table.  One design for selecting CCC indices follows:</p>
<ul class="simple">
<li><p>The application calls a function in the profile to set an offset into the CCC table for the profile</p></li>
<li><p>The profile API header file contains an enum with CCC identifiers.</p></li>
<li><p>The application uses the values in the enum to structure the CCC values at the CCC offset for the profile.</p></li>
</ul>
<p>In this method, the CCC index is always the offset + the CCC’s identifier in the enum.</p>
</section>
<section id="notify-and-indication-functions">
<h4>Notify and Indication Functions<a class="headerlink" href="#notify-and-indication-functions" title="Link to this heading"></a></h4>
<p>A Server Profile may include functions that send notifications and indications to a Client.  These functions pack the data to notify and call AttsHandleValueNtf or AttsHandleValueInd to send notifications or indications.  An example of a notify function follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#define CP_ATTR_ONE_DATA_LEN        3</span>

<span class="n">void</span> <span class="n">CpSendAttributeOne</span><span class="p">(</span><span class="n">dmConnId_t</span> <span class="n">connId</span><span class="p">,</span> <span class="n">uint8_t</span> <span class="n">val1</span><span class="p">,</span> <span class="n">uint16_t</span> <span class="n">val2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">/*</span> <span class="n">check</span> <span class="k">if</span> <span class="n">notifications</span> <span class="n">are</span> <span class="n">enabled</span> <span class="o">*/</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">AttsCccEnabled</span><span class="p">(</span><span class="n">connId</span><span class="p">,</span> <span class="n">CP_ATTR_ONE_CCC_IDX</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">uint8_t</span> <span class="n">data</span><span class="p">[</span><span class="n">CP_ATTR_ONE_DATA_LEN</span><span class="p">]</span>
    <span class="n">uint8_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">pack</span> <span class="n">the</span> <span class="n">data</span> <span class="o">*/</span>
    <span class="n">UINT8_TO_BSTREAM</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">val1</span><span class="p">);</span>
    <span class="n">UINT16_TO_BSTREAM</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">val2</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">send</span> <span class="n">message</span> <span class="o">*/</span>
    <span class="n">AttsHandleValueNtf</span><span class="p">(</span><span class="n">connId</span><span class="p">,</span> <span class="n">CP_ATTR_ONE_HDL</span><span class="p">,</span> <span class="n">CP_ATTR_ONE_DATA_LEN</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="multiple-att-notify-and-indicate-operations">
<h5>Multiple ATT Notify and Indicate Operations<a class="headerlink" href="#multiple-att-notify-and-indicate-operations" title="Link to this heading"></a></h5>
<p>The ATT Layer only supports one operation per ATT bearer at a time.  The profile and application ensure multiple ATT notify and indicate are performed in serial. This may require a state machine that performs one operation and waits for a response before performing the next operation.  Some applications may require a queue system.</p>
</section>
</section>
<section id="service-attribute-read-and-write-callback-functions">
<h4>Service Attribute Read and Write Callback Functions<a class="headerlink" href="#service-attribute-read-and-write-callback-functions" title="Link to this heading"></a></h4>
<p>Services may optionally set the ATTS_SET_WRITE_CBACK and/or ATTS_SET_READ_CBACK bits in an attribute’s settings. A Server Profile registers callback functions with the service to process the ATT reads and writes on these attributes.  An example of registering for a write callback taken from the ATPS profile follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">AtpsInit</span><span class="p">(</span><span class="n">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">SvcCteCbackRegister</span><span class="p">(</span><span class="n">atpsCteWriteCback</span><span class="p">);</span>
  <span class="n">SvcCteAddGroup</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="att-read-callback">
<h5>ATT Read Callback<a class="headerlink" href="#att-read-callback" title="Link to this heading"></a></h5>
<p>An ATT Read Callback has a function prototype that matches the attsReadCback_t datatype.  The callback function’s parameters follow:</p>
<ul class="simple">
<li><p>connId</p></li>
<li><p>handle</p></li>
<li><p>operation</p></li>
<li><p>offset</p></li>
<li><p>pAttr</p></li>
</ul>
<p>The connId parameter is the connection identifier for the link that received the ATT read operation.</p>
<p>The handle parameter is the handle of the attribute being read.</p>
<p>The operation parameter is the ATT PDU of the message that resulted in the read.  Common read PDU follows:</p>
<ul class="simple">
<li><p>ATT_PDU_READ_REQ</p></li>
<li><p>ATT_PDU_READ_BLOB_REQ</p></li>
<li><p>ATT_PDU_READ_MULT_REQ</p></li>
</ul>
<p>The offset parameter is the offset in the attribute value being read.</p>
<p>The pAttr value is a pointer to the service’s attsAttr_t structure for the attribute.</p>
<p>The read callback sets the pLen and pValue in the pAttr and returns the status of the operation.  Then the ATT layer uses the status, pAttr-&gt;pLen, and pAttr-&gt;pValue to send a read response to the client.</p>
</section>
<section id="att-write-callback">
<h5>ATT Write Callback<a class="headerlink" href="#att-write-callback" title="Link to this heading"></a></h5>
<p>An ATT Write Callback has a function prototype that matches the attsWriteCback_t datatype.  The callback function’s parameters follow:</p>
<ul class="simple">
<li><p>connId</p></li>
<li><p>handle</p></li>
<li><p>operation</p></li>
<li><p>offset</p></li>
<li><p>len</p></li>
<li><p>pValue</p></li>
<li><p>pAttr</p></li>
</ul>
<p>The connId parameter is the connection identifier for the link that received the ATT write operation.</p>
<p>The handle parameter is the handle of the attribute being written.</p>
<p>The operation parameter is the ATT PDU of the message that resulted in the write.  Common write PDU follows:</p>
<ul class="simple">
<li><p>ATT_PDU_WRITE_REQ</p></li>
<li><p>ATT_PDU_WRITE_CMD</p></li>
<li><p>ATT_PDU_SIGNED_WRITE_CMD</p></li>
<li><p>ATT_PDU_EXEC_WRITE_REQ</p></li>
</ul>
<p>The offset parameter is the offset of the write into the attribute’s value.</p>
<p>The len parameter is the number of bytes in pValue.</p>
<p>The pValue parameter is a pointer to the data being written.</p>
<p>The pAttr value is a pointer to the service’s attsAttr_t structure for the attribute.</p>
<p>The return value of the write callback function is the status of the operation to be returned to the client in the write response message.</p>
</section>
</section>
</section>
</section>
<section id="dynamic-att">
<h2>Dynamic ATT<a class="headerlink" href="#dynamic-att" title="Link to this heading"></a></h2>
<p>The Dynamic ATT provides a functional interface for creating services.  Furthermore, the Dynamic ATT permits changes to services during run-time.  The Dynamic ATT stores attribute descriptors in RAM, and is therefore not recommended in cases where a Service’s attributes are constant.</p>
<p>To include the Dynamic ATT, an application adds the atts_dyn.c file to the application’s makefile and calls AttsDynInit at application startup.</p>
<p>The following example of the Dynamic ATT is taken from the HID Service:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="o">*</span><span class="n">SvcHidAddGroupDyn</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">void</span> <span class="o">*</span><span class="n">pSHdl</span><span class="p">;</span>
  <span class="n">uint8_t</span> <span class="n">initCcc</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">UINT16_TO_BYTES</span><span class="p">(</span><span class="mh">0x0000</span><span class="p">)};</span>

  <span class="o">/*</span> <span class="n">Create</span> <span class="n">the</span> <span class="n">service</span> <span class="o">*/</span>
  <span class="n">pSHdl</span> <span class="o">=</span> <span class="n">AttsDynCreateGroup</span><span class="p">(</span><span class="n">HID_START_HDL</span><span class="p">,</span> <span class="n">HID_END_HDL</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">pSHdl</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="o">/*</span> <span class="n">Primary</span> <span class="n">service</span> <span class="o">*/</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attPrimSvcUuid</span><span class="p">,</span> <span class="n">hidValSvc</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidValSvc</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ATTS_PERMIT_READ</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">HID</span> <span class="n">Info</span> <span class="o">*/</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attChUuid</span><span class="p">,</span> <span class="n">hidInfoCh</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidInfoCh</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ATTS_PERMIT_READ</span><span class="p">);</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attHidiChUuid</span><span class="p">,</span> <span class="n">hidInfoVal</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidInfoVal</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">HID</span> <span class="n">Report</span> <span class="n">Map</span> <span class="o">*/</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attChUuid</span><span class="p">,</span> <span class="n">hidRmCh</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidRmCh</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ATTS_PERMIT_READ</span><span class="p">);</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attHidRmChUuid</span><span class="p">,</span> <span class="n">hidReportMap</span><span class="p">,</span> <span class="n">hidReportMapLen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">HID</span> <span class="n">External</span> <span class="n">Report</span> <span class="n">Reference</span> <span class="o">*/</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attHidErmUuid</span><span class="p">,</span> <span class="n">hidExtReport</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidExtReport</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">HID</span> <span class="n">Control</span> <span class="n">Point</span> <span class="o">*/</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attChUuid</span><span class="p">,</span> <span class="n">hidCpCh</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidCpCh</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ATTS_PERMIT_READ</span><span class="p">);</span>
    <span class="n">AttsDynAddAttr</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attHidcpChUuid</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ATTS_SET_WRITE_CBACK</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_WRITE</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">HID</span> <span class="n">Boot</span> <span class="n">Keyboard</span> <span class="n">In</span> <span class="o">*/</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attChUuid</span><span class="p">,</span> <span class="n">hidBkiCh</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidBkiCh</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ATTS_PERMIT_READ</span><span class="p">);</span>
    <span class="n">AttsDynAddAttr</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attHidBkiChUuid</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">HID_MAX_REPORT_LEN</span><span class="p">,</span> <span class="n">HID_MAX_REPORT_LEN</span><span class="p">,</span>
                   <span class="n">ATTS_SET_VARIABLE_LEN</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span><span class="p">);</span>
    <span class="n">AttsDynAddAttr</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attCliChCfgUuid</span><span class="p">,</span> <span class="n">initCcc</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">uint16_t</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">uint16_t</span><span class="p">),</span>
                   <span class="n">ATTS_SET_CCC</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span> <span class="o">|</span> <span class="n">HID_SEC_PERMIT_WRITE</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">HID</span> <span class="n">Boot</span> <span class="n">Keyboard</span> <span class="n">Out</span> <span class="o">*/</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attChUuid</span><span class="p">,</span> <span class="n">hidBkoCh</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidBkoCh</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ATTS_PERMIT_READ</span><span class="p">);</span>
    <span class="n">AttsDynAddAttr</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attHidBkoChUuid</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">HID_MAX_REPORT_LEN</span><span class="p">,</span> <span class="n">HID_MAX_REPORT_LEN</span><span class="p">,</span>
        <span class="n">ATTS_SET_WRITE_CBACK</span> <span class="o">|</span> <span class="n">ATTS_SET_VARIABLE_LEN</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span> <span class="o">|</span> <span class="n">HID_SEC_PERMIT_WRITE</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">HID</span> <span class="n">Boot</span> <span class="n">Mouse</span> <span class="n">In</span> <span class="o">*/</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attChUuid</span><span class="p">,</span> <span class="n">hidBmiCh</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidBmiCh</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ATTS_PERMIT_READ</span><span class="p">);</span>
    <span class="n">AttsDynAddAttr</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attHidBmiChUuid</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">HID_MAX_REPORT_LEN</span><span class="p">,</span> <span class="n">HID_MAX_REPORT_LEN</span><span class="p">,</span>
                   <span class="n">ATTS_SET_VARIABLE_LEN</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span><span class="p">);</span>
    <span class="n">AttsDynAddAttr</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attCliChCfgUuid</span><span class="p">,</span> <span class="n">initCcc</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">uint16_t</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">uint16_t</span><span class="p">),</span>
                   <span class="n">ATTS_SET_CCC</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span> <span class="o">|</span> <span class="n">HID_SEC_PERMIT_WRITE</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">HID</span> <span class="n">Input</span> <span class="n">Report</span> <span class="c1">#1 (HIDAPP_REMOTE_REPORT_ID) */</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attChUuid</span><span class="p">,</span> <span class="n">hidIRep1Ch</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidIRep1Ch</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ATTS_PERMIT_READ</span><span class="p">);</span>
    <span class="n">AttsDynAddAttr</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attHidRepChUuid</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">HID_MAX_REPORT_LEN</span><span class="p">,</span> <span class="n">HID_MAX_REPORT_LEN</span><span class="p">,</span>
                   <span class="n">ATTS_SET_VARIABLE_LEN</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span><span class="p">);</span>
    <span class="n">AttsDynAddAttr</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attCliChCfgUuid</span><span class="p">,</span> <span class="n">initCcc</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">uint16_t</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">uint16_t</span><span class="p">),</span>
                   <span class="n">ATTS_SET_CCC</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span> <span class="o">|</span> <span class="n">HID_SEC_PERMIT_WRITE</span><span class="p">);</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attHidRimUuid</span><span class="p">,</span> <span class="n">hidValIRep1IdMap</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidValIRep1IdMap</span><span class="p">),</span>
                        <span class="mi">0</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">HID</span> <span class="n">Input</span> <span class="n">Report</span> <span class="c1">#2 (HIDAPP_KEYBOARD_REPORT_ID) */</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attChUuid</span><span class="p">,</span> <span class="n">hidIRep2Ch</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidIRep2Ch</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ATTS_PERMIT_READ</span><span class="p">);</span>
    <span class="n">AttsDynAddAttr</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attHidRepChUuid</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">HID_MAX_REPORT_LEN</span><span class="p">,</span> <span class="n">HID_MAX_REPORT_LEN</span><span class="p">,</span>
                   <span class="n">ATTS_SET_VARIABLE_LEN</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span><span class="p">);</span>
    <span class="n">AttsDynAddAttr</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attCliChCfgUuid</span><span class="p">,</span> <span class="n">initCcc</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">uint16_t</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">uint16_t</span><span class="p">),</span>
                   <span class="n">ATTS_SET_CCC</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span> <span class="o">|</span> <span class="n">HID_SEC_PERMIT_WRITE</span><span class="p">);</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attHidRimUuid</span><span class="p">,</span> <span class="n">hidValIRep2IdMap</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidValIRep2IdMap</span><span class="p">),</span>
                        <span class="mi">0</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">HID</span> <span class="n">Input</span> <span class="n">Report</span> <span class="c1">#3 (HIDAPP_MOUSE_REPORT_ID) */</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attChUuid</span><span class="p">,</span> <span class="n">hidIRep3Ch</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidIRep3Ch</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ATTS_PERMIT_READ</span><span class="p">);</span>
    <span class="n">AttsDynAddAttr</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attHidRepChUuid</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">HID_MAX_REPORT_LEN</span><span class="p">,</span> <span class="n">HID_MAX_REPORT_LEN</span><span class="p">,</span>
                   <span class="n">ATTS_SET_VARIABLE_LEN</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span><span class="p">);</span>
    <span class="n">AttsDynAddAttr</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attCliChCfgUuid</span><span class="p">,</span> <span class="n">initCcc</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">uint16_t</span><span class="p">),</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">uint16_t</span><span class="p">),</span>
                   <span class="n">ATTS_SET_CCC</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span> <span class="o">|</span> <span class="n">HID_SEC_PERMIT_WRITE</span><span class="p">);</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attHidRimUuid</span><span class="p">,</span> <span class="n">hidValIRep3IdMap</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidValIRep3IdMap</span><span class="p">),</span>
                        <span class="mi">0</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">HID</span> <span class="n">Output</span> <span class="n">Report</span> <span class="o">*/</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attChUuid</span><span class="p">,</span> <span class="n">hidORepCh</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidORepCh</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ATTS_PERMIT_READ</span><span class="p">);</span>
    <span class="n">AttsDynAddAttr</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attHidRepChUuid</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">HID_MAX_REPORT_LEN</span><span class="p">,</span> <span class="n">HID_MAX_REPORT_LEN</span><span class="p">,</span>
        <span class="n">ATTS_SET_WRITE_CBACK</span> <span class="o">|</span> <span class="n">ATTS_SET_VARIABLE_LEN</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span> <span class="o">|</span> <span class="n">HID_SEC_PERMIT_WRITE</span><span class="p">);</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attHidRimUuid</span><span class="p">,</span> <span class="n">hidValORepIdMap</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidValORepIdMap</span><span class="p">),</span>
                        <span class="mi">0</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">HID</span> <span class="n">Feature</span> <span class="n">Report</span> <span class="o">*/</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attChUuid</span><span class="p">,</span> <span class="n">hidFRepCh</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidFRepCh</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ATTS_PERMIT_READ</span><span class="p">);</span>
    <span class="n">AttsDynAddAttr</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attHidRepChUuid</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="n">HID_MAX_REPORT_LEN</span><span class="p">,</span> <span class="n">HID_MAX_REPORT_LEN</span><span class="p">,</span>
        <span class="n">ATTS_SET_WRITE_CBACK</span> <span class="o">|</span> <span class="n">ATTS_SET_VARIABLE_LEN</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span> <span class="o">|</span> <span class="n">HID_SEC_PERMIT_WRITE</span><span class="p">);</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attHidRimUuid</span><span class="p">,</span> <span class="n">hidValFRepIdMap</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidValFRepIdMap</span><span class="p">),</span>
                        <span class="mi">0</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">HID</span> <span class="n">Protocol</span> <span class="n">Mode</span> <span class="o">*/</span>
    <span class="n">AttsDynAddAttrConst</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attChUuid</span><span class="p">,</span> <span class="n">hidPmCh</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidPmCh</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ATTS_PERMIT_READ</span><span class="p">);</span>
    <span class="n">AttsDynAddAttr</span><span class="p">(</span><span class="n">pSHdl</span><span class="p">,</span> <span class="n">attHidPmChUuid</span><span class="p">,</span> <span class="n">hidPmVal</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">hidPmVal</span><span class="p">),</span>  <span class="n">sizeof</span><span class="p">(</span><span class="n">hidPmVal</span><span class="p">),</span>
                   <span class="n">ATTS_SET_WRITE_CBACK</span><span class="p">,</span> <span class="n">HID_SEC_PERMIT_READ</span> <span class="o">|</span> <span class="n">HID_SEC_PERMIT_WRITE</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">pSHdl</span><span class="p">;</span>
<span class="p">}</span>

</pre></div>
</div>
<section id="dynamic-att-api">
<h3>Dynamic ATT API<a class="headerlink" href="#dynamic-att-api" title="Link to this heading"></a></h3>
<p>The AttsDynInit function is used to initialize the Dynamic ATT.</p>
<p>The following functions are used to construct a dynamic attribute descriptor for a service:</p>
<ul class="simple">
<li><p>AttsDynCreateGroup</p></li>
<li><p>AttsDynRegister</p></li>
<li><p>AttsDynAddAttr</p></li>
<li><p>AttsDynAddAttrConst</p></li>
</ul>
<p>The AttsDynDeleteGroup function can be used to remove a dynamic service.</p>
<p>The following constants are conditionally compilable and define the heap size and memory alignment of the Dynamic ATT:</p>
<ul class="simple">
<li><p>ATTS_DYN_HEAP_SIZE</p></li>
<li><p>ATTS_DYN_ALIGNMENT</p></li>
</ul>
<section id="atts-dyn-heap-size">
<h4>ATTS_DYN_HEAP_SIZE<a class="headerlink" href="#atts-dyn-heap-size" title="Link to this heading"></a></h4>
<p>The ATTS_DYN_HEAP_SIZE defines the amount of RAM reserved for attribute descriptor tables in the Dynamic ATT.  This number should be tuned to its smallest required value.</p>
</section>
<section id="atts-dyn-alignment">
<h4>ATTS_DYN_ALIGNMENT<a class="headerlink" href="#atts-dyn-alignment" title="Link to this heading"></a></h4>
<p>The ATTS_DYN_ALIGNMENT defines the memory alignment on the target MCU.  In 32-bit processers, the ATTS_DYN_ALIGNMENT is generally 4.  The ATTS allocates memory from its heap using the attsDynAlloc function.  The attsDynAlloc function rounds up the size being allocated to be a multiple of the ATTS_DYN_ALIGNMENT.  Allocating on ATTS_DYN_ALIGNMENT boundaries ensures the address of every allocation is aligned with the addressing capability of the MCU.</p>
</section>
<section id="attsdyninit">
<h4>AttsDynInit<a class="headerlink" href="#attsdyninit" title="Link to this heading"></a></h4>
<p>Applications that use the Dynamic ATT must call AttsDynInit from the application initialization function.</p>
</section>
<section id="attsdyncreategroup">
<h4>AttsDynCreateGroup<a class="headerlink" href="#attsdyncreategroup" title="Link to this heading"></a></h4>
<p>The first step in creating a dynamic attribute table is to call AttsDynCreateGroup.  This function takes the start handle and end handle of the attributes and returns the service handle for the dynamic service.  AttsDynCreateGroup returns NULL if the operation fails.</p>
</section>
<section id="attsdyndeletegroup">
<h4>AttsDynDeleteGroup<a class="headerlink" href="#attsdyndeletegroup" title="Link to this heading"></a></h4>
<p>The AttsDynDeleteGroup function can be called to free a Dynamic ATT group.</p>
<p>Note: Due to heap fragmentation limitations, this function cannot free memory from the Dynamic ATT heap until all dynamic services are deleted.</p>
</section>
<section id="attsdynregister">
<h4>AttsDynRegister<a class="headerlink" href="#attsdynregister" title="Link to this heading"></a></h4>
<p>The AttsDynRegister function is used to set the attribute read and write callback functions for the dynamic service.</p>
</section>
<section id="attsdynaddattr-and-attsdynaddattrconst">
<h4>AttsDynAddAttr and AttsDynAddAttrConst<a class="headerlink" href="#attsdynaddattr-and-attsdynaddattrconst" title="Link to this heading"></a></h4>
<p>The AttsDynAddAttr and AttsDynAddAttrConst functions are called to add attributes.  The const version of the function should be called when the value of the attribute passed into AttsDynAddAttrConst doesn’t change.  Alternatively, the AttsDynAddAttr version of the function puts the value of the attribute on the dynamic att heap which allows the value of the attribute to change.</p>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024 EM Microelectronic.  All rights reserved..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>